<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>docker 中安装 ElasticSearch</title>
    <url>/posts/988360c9/</url>
    <content><![CDATA[<h2 id="1-安装说明"><a class="markdownIt-Anchor" href="#1-安装说明"></a> 1 安装说明</h2>
<p>在平时工作的时候，开发环境大多数会安装单机<code>ElasticSearch</code>，但生产环境基本会安装<code>ElasticSearch</code>集群版，所以我们接下来实现一下<code>ElasticSearch</code>单机安装，下一节实现集群安装，但安装也大多数采用<code>Docker</code>安装。不过中文搜索，会实现分词器集成，可以采用IK分词器。<code>ElasticSearch</code>采用<code>Kibana</code>实现数据可视化分析也是当前主流，所以我们除了安装<code>ElasticSearch</code>和<code>IK</code>分词器外，还需要安装<code>Kibana</code>。</p>
<p>安装实践:</p>
<div class="highlight-container" data-rel="Properties"><figure class="iseeu highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">1</span>:<span class="string">ElasticSearch单机安装</span></span><br><span class="line"></span><br><span class="line"><span class="attr">2</span>:<span class="string">IK分词器安装</span></span><br><span class="line"></span><br><span class="line"><span class="attr">3</span>:<span class="string">Kibana安装</span></span><br></pre></td></tr></table></figure></div>
<p></p>
<h2 id="2-docker安装elasticsearch"><a class="markdownIt-Anchor" href="#2-docker安装elasticsearch"></a> 2 Docker安装ElasticSearch</h2>
<p>当前<code>ElasticSearch</code>已经到了<code>8.0</code>，新版本都有很多新特性，性能和功能都有大幅提升，我们建议使用较高版本，这里将采用<code>7.12.1</code>版本。</p>
<p></p>
<h3 id="21-网络创建"><a class="markdownIt-Anchor" href="#21-网络创建"></a> 2.1 网络创建</h3>
<p>高版本安装<code>Kibana</code>的时候需要和<code>ElasticSearch</code>在同一网段内，所以采用<code>docker</code>安装首先要确认网段，为了方便操作，我们直接创建一个网络，创建脚本如下:</p>
<div class="highlight-container" data-rel="Properties"><figure class="iseeu highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">docker</span> <span class="string">network create itmentu-net</span></span><br></pre></td></tr></table></figure></div>
<p></p>
<h3 id="22-elasticsearch安装"><a class="markdownIt-Anchor" href="#22-elasticsearch安装"></a> 2.2 ElasticSearch安装</h3>
<p>安装<code>ElasticSearch</code>脚本如下:</p>
<div class="highlight-container" data-rel="Properties"><figure class="iseeu highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">docker</span> <span class="string">run -d \</span></span><br><span class="line"><span class="string">	--name elasticsearch \</span></span><br><span class="line"><span class="string">    -e &quot;ES_JAVA_OPTS=-Xms512m -Xmx512m&quot; \</span></span><br><span class="line"><span class="string">    -e &quot;discovery.type=single-node&quot; \</span></span><br><span class="line"><span class="string">    -v es-data:/usr/share/elasticsearch/data \</span></span><br><span class="line"><span class="string">    -v es-plugins:/usr/share/elasticsearch/plugins \</span></span><br><span class="line"><span class="string">    --privileged \</span></span><br><span class="line"><span class="string">    --network itmentu-net \</span></span><br><span class="line"><span class="string">    -p 9200:9200 \</span></span><br><span class="line"><span class="string">    -p 9300:9300 \</span></span><br><span class="line"><span class="string">elasticsearch:7.12.1</span></span><br></pre></td></tr></table></figure></div>
<p>命令说明：</p>
<ul>
<li><code>-e &quot;cluster.name=es-docker-cluster&quot;</code>：设置集群名称</li>
<li><code>-e &quot;http.host=0.0.0.0&quot;</code>：监听的地址，可以外网访问</li>
<li><code>-e &quot;ES_JAVA_OPTS=-Xms512m -Xmx512m&quot;</code>：内存大小</li>
<li><code>-e &quot;discovery.type=single-node&quot;</code>：非集群模式</li>
<li><code>-v es-data:/usr/share/elasticsearch/data</code>：挂载逻辑卷，绑定<code>elasticsearch</code>的数据目录</li>
<li><code>-v es-logs:/usr/share/elasticsearch/logs</code>：挂载逻辑卷，绑定<code>elasticsearch</code>的日志目录</li>
<li><code>-v es-plugins:/usr/share/elasticsearch/plugins</code>：挂载逻辑卷，绑定<code>elasticsearch</code>的插件目录</li>
<li><code>--privileged</code>：授予逻辑卷访问权</li>
<li><code>--network itmentu-net</code> ：加入一个名为<code>itmentu-net</code>的网络中</li>
<li><code>-p 9200:9200</code>：端口映射配置</li>
</ul>
<p></p>
<p><code>Docker</code>安装<code>ElasticSearch</code>下载可能会比较慢，需要耐心等待，效果如下：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ffa4c684eb7f40eaaebe149053f3c04e~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp"
                      alt="image-20220102123013210" 
                ></p>
<p></p>
<p>安装完成后，在浏览器中输入：<a class="link"   href="https://link.juejin.cn?target=http%3A%2F%2F192.168.211.130%3A9200%2F" >http://192.168.211.130:9200/ <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a> 即可看到<code>elasticsearch</code>的响应结果：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/fe45cf37b43c49839538683f5ddf0f15~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp"
                      alt="image-20220102122738908" 
                ></p>
<p></p>
<h2 id="3-安装kibana"><a class="markdownIt-Anchor" href="#3-安装kibana"></a> 3 安装Kibana</h2>
<p>我们可以基于<code>Http</code>请求操作<code>ElasticSearch</code>，但基于<code>Http</code>操作比较麻烦，我们可以采用<code>Kibana</code>实现可视化操作。</p>
<p></p>
<h3 id="31-kibana介绍"><a class="markdownIt-Anchor" href="#31-kibana介绍"></a> 3.1 Kibana介绍</h3>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4bdb2b2c21f44a18af80bfd15a8bfd79~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp"
                      alt="image-20220102122520286" 
                ></p>
<p><code>Kibana</code> 是一个免费且开放的用户界面，能够让您对 <code>Elasticsearch</code> 数据进行可视化，并让您在 <code>Elastic Stack </code>中进行导航。您可以进行各种操作，从跟踪查询负载，到理解请求如何流经您的整个应用，都能轻松完成。</p>
<p><code>Kibana</code> 让您能够自由地选择如何呈现自己的数据。不过借助 <code>Kibana</code> 的交互式可视化，您可以先从一个问题出发，看看能够从中发现些什么。</p>
<p></p>
<p>可视化界面如下：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e2d7f768a8184c90a5112ef05985423d~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp"
                      alt="image-20220102122626497" 
                ></p>
<p></p>
<h3 id="32-kibana安装"><a class="markdownIt-Anchor" href="#32-kibana安装"></a> 3.2 Kibana安装</h3>
<p>使用<code>Docker</code>安装<code>Kibana</code>非常简单，只需要执行如下命令即可，但是执行命令需要注意<code>Kibana</code>操作的<code>ElasticSearch</code>地址，因为<code>Kibana</code>是需要连接<code>ElasticSearch</code>进行操作的，命令如下:</p>
<div class="highlight-container" data-rel="Properties"><figure class="iseeu highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">docker</span> <span class="string">run -d \</span></span><br><span class="line"><span class="string">--name kibana \</span></span><br><span class="line"><span class="string">-e ELASTICSEARCH_HOSTS=http://192.168.211.130:9200 \</span></span><br><span class="line"><span class="string">--network itmentu-net \</span></span><br><span class="line"><span class="string">-p 5601:5601  \</span></span><br><span class="line"><span class="string">kibana:7.12.1</span></span><br></pre></td></tr></table></figure></div>
<p>命令说明：</p>
<ul>
<li><code>--network itmentu-net</code> ：加入一个名为<code>itmentu-net</code>的网络中，与<code>elasticsearch</code>在同一个网络中</li>
<li><code>-e ELASTICSEARCH_HOSTS=http://192.168.211.130:9200&quot;</code>：设置<code>elasticsearch</code>的地址，因为<code>kibana</code>已经与<code>elasticsearch</code>在一个网络，因此可以用容器名直接访问<code>elasticsearch</code>，也可以写IP地址实现访问。</li>
<li><code>-p 5601:5601</code>：端口映射配置</li>
</ul>
<p></p>
<p>安装的时候如果没有镜像，会下载镜像，效果如下：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6a1161c1c5094472bc5fa1ccf5736d80~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp"
                      alt="image-20220102123516823" 
                ></p>
<p><code>kibana</code>安装会比较耗时间，也需要耐心等待下载安装完成，如果想实时知道服务安装运行的状态，可以通过查看日志实现，查看日志如下：</p>
<div class="highlight-container" data-rel="Properties"><figure class="iseeu highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">properties</span></span><br><span class="line"><span class="attr">复制代码docker</span> <span class="string">logs -f kibana</span></span><br></pre></td></tr></table></figure></div>
<p>日志中如果出现了<code>http://0.0.0.0:5601</code>即可访问<code>Kibana</code>后台服务，日志如下：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ccc91500ccaf46e79afb4faf37d7505a~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp"
                      alt="image-20220102123646972" 
                ></p>
<p></p>
<p>访问<code>http://192.168.211.130:5601</code>效果如下：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/549cd772a85648d987d4aea267f96248~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp"
                      alt="image-20220102123829118" 
                ></p>
<p>可以点击<code>Add data</code>，添加示例数据，如下图，随意选一个即可，不选其实也是可以的。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/08d1c881b1944ea294348708f7beadc5~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp"
                      alt="image-20220102123929231" 
                ></p>
<p></p>
<h3 id="33-kibana中文配置"><a class="markdownIt-Anchor" href="#33-kibana中文配置"></a> 3.3 Kibana中文配置</h3>
<p>我们发现<code>Kibana</code>是英文面板，看起来不是很方便，但<code>Kibana</code>是支持中文配置，所以我们可以把<code>Kibana</code>配置成中文版，便于我们操作。</p>
<p>切换中文操作如下:</p>
<div class="highlight-container" data-rel="Properties"><figure class="iseeu highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="comment">#进入容器</span></span><br><span class="line"><span class="attr">docker</span> <span class="string">exec -it kibana /bin/bash</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">#进入配置文件目录</span></span><br><span class="line"><span class="attr">cd</span> <span class="string">/usr/share/kibana/config</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">#编辑文件kibana.yml</span></span><br><span class="line"><span class="attr">vi</span> <span class="string">kibana.yml</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">#在最后一行添加如下配置</span></span><br><span class="line"><span class="attr">i18n.locale</span>: <span class="string">zh-CN</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">#保存退出</span></span><br><span class="line"><span class="attr">exit</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">#并重启容器</span></span><br><span class="line"><span class="attr">docker</span> <span class="string">restart kibana</span></span><br></pre></td></tr></table></figure></div>
<p></p>
<p>等待<code>Kibana</code>容器启动，再次访问<a class="link"   href="https://link.juejin.cn?target=http%3A%2F%2F192.168.211.130%3A5601%2F%E6%95%88%E6%9E%9C%E5%A6%82%E4%B8%8B%EF%BC%9A" >http://192.168.211.130:5601/效果如下： <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1f0f6300557340e4b3adb6e37473f147~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp"
                      alt="image-20220102124446277" 
                ></p>
<p></p>
<h2 id="4-ik分词器安装"><a class="markdownIt-Anchor" href="#4-ik分词器安装"></a> 4 IK分词器安装</h2>
<p>我们打开<code>Kibana</code>，点击开发工具，操作如下：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/813ac36dc02e4ef1a9b0fb0fae69294b~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp"
                      alt="image-20220102130545516" 
                ></p>
<p>输入如下操作，用于查询分词：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/567f9030d0c4414db43b9f21851cdbc4~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp"
                      alt="image-20220102130749934" 
                ></p>
<p>上图测试代码如下:</p>
<div class="highlight-container" data-rel="Properties"><figure class="iseeu highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">GET</span> <span class="string">/_analyze</span></span><br><span class="line"><span class="attr">&#123;</span></span><br><span class="line">  <span class="attr">&quot;analyzer&quot;</span>: <span class="string">&quot;standard&quot;,</span></span><br><span class="line">  <span class="attr">&quot;text&quot;</span>: <span class="string">&quot;IT门徒，带你打开通往梦想的门！&quot;</span></span><br><span class="line"><span class="attr">&#125;</span></span><br></pre></td></tr></table></figure></div>
<p>表示使用<code>standard</code>对<code>IT门徒，带你打开通往梦想的门！</code>进行分词。</p>
<p><code>分词</code>：提取一句话或者一篇文章中的词语。</p>
<p>我们在使用<code>ElasticSearch</code>的时候，默认用<code>standard</code>分词器，但<code>standard</code>分词器使用的是按空格分词，这种分词操作方法不符合中文分词标准，我们需要额外安装中文分词器。</p>
<p></p>
<h3 id="41-ik分词器介绍"><a class="markdownIt-Anchor" href="#41-ik分词器介绍"></a> 4.1 IK分词器介绍</h3>
<p><code>IK Analyzer</code>是一个开源的，基于java语言开发的轻量级的中文分词工具包。从2006年12月推出1.0版开始， <code>IKAnalyzer</code>已经推出了多个大版本。最初，它是以开源项目<code>Luence</code>为应用主体的，结合词典分词和文法分析算法的中文分词组件。<code>IK Analyzer</code>则发展为面向<code>Java</code>的公用分词组件，独立于<code>Lucen</code>e项目，同时提供了对<code>Lucene</code>的默认优化实现。</p>
<p></p>
<p><code>ElasticSearch</code>内核其实就是基于<code>Lucene</code>，所以我们可以直接在<code>ElasticSearch</code>中集成IK分词器，<code>IK</code>分词器集成<code>ElasticSearch</code>下载地址：<a class="link"   href="https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fmedcl%2Felasticsearch-analysis-ik%2Freleases" >github.com/medcl/elast… <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/96f25eb5318a40ec96e5b4ab8caf287d~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp"
                      alt="image-20220102125305738" 
                ></p>
<p></p>
<h3 id="42-ik分词器配置"><a class="markdownIt-Anchor" href="#42-ik分词器配置"></a> 4.2 IK分词器配置</h3>
<p>下载安装包<code>elasticsearch-analysis-ik-7.12.1.zip</code>后，并解压，目录如下：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ef21870531ec423a8dfe4f1badb51671~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp"
                      alt="image-20220102125602923" 
                ></p>
<p>我们只需要将上面<code>elasticsearch-analysis-ik-7.12.1</code>拷贝到<code>ElasticSearch</code>的<code>plugins</code>目录中即可，但由于当前服务采用的是<code>docker</code>安装，所以需要将文件拷贝到<code>docker</code>容器的<code>plugins</code>目录才行。</p>
<p>操作如下：</p>
<div class="highlight-container" data-rel="Properties"><figure class="iseeu highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="comment">#为了方便配置，我们将elasticsearch-analysis-ik-7.12.1改成ik文件夹</span></span><br><span class="line"><span class="attr">mv</span> <span class="string">elasticsearch-analysis-ik-7.12.1 ik</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">#将ik文件夹拷贝到elasticsearch容器中</span></span><br><span class="line"><span class="attr">docker</span> <span class="string">cp ik elasticsearch:/usr/share/elasticsearch/plugins</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">#重启容器</span></span><br><span class="line"><span class="attr">docker</span> <span class="string">restart elasticsearch</span></span><br></pre></td></tr></table></figure></div>
<p>操作效果如下：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/aac9883b11b947aca79e6df463322d87~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp"
                      alt="image-20220102130217434" 
                ></p>
<p></p>
<h3 id="43-分词测试"><a class="markdownIt-Anchor" href="#43-分词测试"></a> 4.3 分词测试</h3>
<p><code>IK</code>分词器包含两种模式：</p>
<ul>
<li><code>ik_smart</code>：最少切分</li>
<li><code>ik_max_word</code>：最细切分</li>
</ul>
<p></p>
<p>前面使用默认的<code>standard</code>分词器，对中文分词非常难用，安装IK分词器后，我们可以使用IK分词器测试，测试代码如下：</p>
<div class="highlight-container" data-rel="Properties"><figure class="iseeu highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">GET</span> <span class="string">/_analyze</span></span><br><span class="line"><span class="attr">&#123;</span></span><br><span class="line">  <span class="attr">&quot;analyzer&quot;</span>: <span class="string">&quot;ik_max_word&quot;,</span></span><br><span class="line">  <span class="attr">&quot;text&quot;</span>: <span class="string">&quot;IT门徒，带你打开通往梦想的门！&quot;</span></span><br><span class="line"><span class="attr">&#125;</span></span><br></pre></td></tr></table></figure></div>
<p>测试效果如下：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f2910ef87aad430097bc7e32fa620e31~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp"
                      alt="image-20220102131106766" 
                ></p>
<p>我们可以发现对中文的分词效果是比较不错的，但也存在一些不足，比如<code>梦想的门</code>我们希望它是一个词，而<code>带你</code>我们希望它不被识别一个词，又该如何实现呢？</p>
<p></p>
<h3 id="44-ik自定义词典"><a class="markdownIt-Anchor" href="#44-ik自定义词典"></a> 4.4 IK自定义词典</h3>
<p>IK分词器支持自定义词典，包括自定义分词，也包含自定义停用分词，操作起来也非常简单。我们接下来实现一下自定义词典和停用词典。</p>
<p></p>
<h4 id="441-自定义词典"><a class="markdownIt-Anchor" href="#441-自定义词典"></a> 4.4.1 自定义词典</h4>
<p>自定义词典，需要先创建自己的词典，再引用自己的词典即可。</p>
<div class="highlight-container" data-rel="Properties"><figure class="iseeu highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">1</span>:<span class="string">创建词典</span></span><br><span class="line"><span class="attr">2</span>:<span class="string">引用词典</span></span><br></pre></td></tr></table></figure></div>
<p></p>
<p>1)创建词典</p>
<p>在<code>config</code>中创建自己的词典，例如叫<code>itmentu_ext.dic</code>，在文件中添加自定义的词语，操作如下：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/fbc91a1096ce4be6a6baa031d4ed01b5~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp"
                      alt="image-20220102133144102" 
                ></p>
<p>我们把自定义的词典<code>梦想的门</code>添加到了<code>itmentu_ext.dic</code>中了，这就是创建词典，如果后多个自定义次，需要换行加入，这里一定要注意中文分词设置编码格式为<code>UTF-8</code>。</p>
<p></p>
<p>2)引用词典</p>
<p>修改<code>config/IKAnalyzer.cfg.xml</code>引用自己创建的<code>itmentu_ext.dic</code>词典，配置如下:</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/047904c3f26e4ccd83fdfe414d9bcab2~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp"
                      alt="image-20220102131927984" 
                ></p>
<p>上图代码如下：</p>
<div class="highlight-container" data-rel="Xml"><figure class="iseeu highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">properties</span> <span class="keyword">SYSTEM</span> <span class="string">&quot;http://java.sun.com/dtd/properties.dtd&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">comment</span>&gt;</span>IK Analyzer 扩展配置<span class="tag">&lt;/<span class="name">comment</span>&gt;</span></span><br><span class="line">	<span class="comment">&lt;!--用户可以在这里配置自己的扩展字典 --&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">entry</span> <span class="attr">key</span>=<span class="string">&quot;ext_dict&quot;</span>&gt;</span>itmentu_ext.dic<span class="tag">&lt;/<span class="name">entry</span>&gt;</span></span><br><span class="line">	 <span class="comment">&lt;!--用户可以在这里配置自己的扩展停止词字典--&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">entry</span> <span class="attr">key</span>=<span class="string">&quot;ext_stopwords&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">entry</span>&gt;</span></span><br><span class="line">	<span class="comment">&lt;!--用户可以在这里配置远程扩展字典 --&gt;</span></span><br><span class="line">	<span class="comment">&lt;!-- &lt;entry key=&quot;remote_ext_dict&quot;&gt;words_location&lt;/entry&gt; --&gt;</span></span><br><span class="line">	<span class="comment">&lt;!--用户可以在这里配置远程扩展停止词字典--&gt;</span></span><br><span class="line">	<span class="comment">&lt;!-- &lt;entry key=&quot;remote_ext_stopwords&quot;&gt;words_location&lt;/entry&gt; --&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br></pre></td></tr></table></figure></div>
<p>我们将改好的文件重新上传到<code>elasticsearch</code>容器的<code>/usr/share/elasticsearch/plugins</code>目录下，重启<code>elasticsearch</code>容器即可。</p>
<p>操作如下:</p>
<div class="highlight-container" data-rel="Properties"><figure class="iseeu highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">properties</span></span><br><span class="line"><span class="attr">复制代码#将上传的config拷贝到服务器</span></span><br><span class="line"><span class="comment">#将ik文件夹拷贝到elasticsearch容器中</span></span><br><span class="line"><span class="attr">docker</span> <span class="string">cp ik elasticsearch:/usr/share/elasticsearch/plugins</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">#重启容器</span></span><br><span class="line"><span class="attr">docker</span> <span class="string">restart elasticsearch</span></span><br></pre></td></tr></table></figure></div>
<p></p>
<p>在使用<code>Kibana</code>测试 <code>http://192.168.211.130:5601/app/dev_tools#/console</code> 效果如下：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c9d7b0f09a1348b8bc487b9351d0b517~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp"
                      alt="image-20220102133431459" 
                ></p>
<p></p>
<h4 id="442-自定义停用词汇"><a class="markdownIt-Anchor" href="#442-自定义停用词汇"></a> 4.4.2 自定义停用词汇</h4>
<p>自定义停用词典和自定义词典一样，需要先创建自己的词典，再引用自己的词典即可。</p>
<div class="highlight-container" data-rel="Properties"><figure class="iseeu highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">properties</span></span><br><span class="line"><span class="attr">复制代码1</span>:<span class="string">创建词典</span></span><br><span class="line"><span class="attr">2</span>:<span class="string">引用词典</span></span><br></pre></td></tr></table></figure></div>
<p></p>
<p>1)创建词典</p>
<p>在<code>config</code>中创建自己的停用词典，例如叫<code>itmentu_stop.dic</code>，在文件中添加自定义的停用词语，操作如下：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e9bc84adf9c84a8aab3301070f4328cb~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp"
                      alt="image-20220102133606560" 
                ></p>
<p></p>
<p>2)引用词典</p>
<p>修改<code>config/IKAnalyzer.cfg.xml</code>引用自己创建的<code>itmentu_stop.dic</code>停用词典，配置如下:</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d66ae26953e34c19ab228ad3bab10307~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp"
                      alt="image-20220102133807712" 
                ></p>
<p>上图代码如下:</p>
<div class="highlight-container" data-rel="Xml"><figure class="iseeu highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">properties</span> <span class="keyword">SYSTEM</span> <span class="string">&quot;http://java.sun.com/dtd/properties.dtd&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">comment</span>&gt;</span>IK Analyzer 扩展配置<span class="tag">&lt;/<span class="name">comment</span>&gt;</span></span><br><span class="line">	<span class="comment">&lt;!--用户可以在这里配置自己的扩展字典 --&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">entry</span> <span class="attr">key</span>=<span class="string">&quot;ext_dict&quot;</span>&gt;</span>itmentu_ext.dic<span class="tag">&lt;/<span class="name">entry</span>&gt;</span></span><br><span class="line">	 <span class="comment">&lt;!--用户可以在这里配置自己的扩展停止词字典--&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">entry</span> <span class="attr">key</span>=<span class="string">&quot;ext_stopwords&quot;</span>&gt;</span>itmentu_stop.dic<span class="tag">&lt;/<span class="name">entry</span>&gt;</span></span><br><span class="line">	<span class="comment">&lt;!--用户可以在这里配置远程扩展字典 --&gt;</span></span><br><span class="line">	<span class="comment">&lt;!-- &lt;entry key=&quot;remote_ext_dict&quot;&gt;words_location&lt;/entry&gt; --&gt;</span></span><br><span class="line">	<span class="comment">&lt;!--用户可以在这里配置远程扩展停止词字典--&gt;</span></span><br><span class="line">	<span class="comment">&lt;!-- &lt;entry key=&quot;remote_ext_stopwords&quot;&gt;words_location&lt;/entry&gt; --&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br></pre></td></tr></table></figure></div>
<p>我们将改好的文件重新上传到<code>elasticsearch</code>容器的<code>/usr/share/elasticsearch/plugins</code>目录下，重启<code>elasticsearch</code>容器即可。</p>
<p>操作如下:</p>
<div class="highlight-container" data-rel="Properties"><figure class="iseeu highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="comment">#将上传的config拷贝到服务器</span></span><br><span class="line"><span class="comment">#将ik文件夹拷贝到elasticsearch容器中</span></span><br><span class="line"><span class="attr">docker</span> <span class="string">cp ik elasticsearch:/usr/share/elasticsearch/plugins</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">#重启容器</span></span><br><span class="line"><span class="attr">docker</span> <span class="string">restart elasticsearch</span></span><br></pre></td></tr></table></figure></div>
<p></p>
<p>在使用<code>Kibana</code>测试 <code>http://192.168.211.130:5601/app/dev_tools#/console</code> 效果如下：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f134ad6b05464045956bb870300a672e~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp"
                      alt="image-20220102134039836" 
                ></p>
<p>我们可以发现，不再有<code>带你</code>的分词了，说明停用分词也生效了。</p>
]]></content>
      <categories>
        <category>docker</category>
        <category>镜像安装</category>
      </categories>
      <tags>
        <tag>docker</tag>
        <tag>ElasticSearch</tag>
      </tags>
  </entry>
  <entry>
    <title>分布式理论基础-BASE</title>
    <url>/posts/21c5149c/</url>
    <content><![CDATA[<blockquote>
<p>BASE是“Basically Available, Soft state, Eventually consistent(基本可用、软状态、最终一致性)”的首字母缩写。其中的软状态和最终一致性这两种技巧擅于对付存在分区的场合，并因此提高了可用性。</p>
</blockquote>
<h2 id="什么是base"><a class="markdownIt-Anchor" href="#什么是base"></a> 什么是BASE</h2>
<p>eBay 的架构师 Dan Pritchett 源于对大规模分布式系统的实践总结，在 ACM 上发表文章提出 BASE 理论，BASE 理论是对 CAP 理论的延伸，核心思想是即使无法做到强一致性（Strong Consistency，CAP 的一致性就是强一致性），但应用可以采用适合的方式达到最终一致性（Eventual Consitency）。</p>
<ul>
<li>
<p><code>Basically Available（基本可用）</code>分布式系统在出现不可预知故障的时候，允许损失部分可用性</p>
</li>
<li>
<p><code>Soft state（软状态）</code>软状态也称为弱状态，和硬状态相对，是指允许系统中的数据存在中间状态，并认为该中间状态的存在不会影响系统的整体可用性，即允许系统在不同节点的数据副本之间进行数据同步的过程存在延时。</p>
</li>
<li>
<p><code>Eventually consistent（最终一致性）</code>最终一致性强调的是系统中所有的数据副本，在经过一段时间的同步后，最终能够达到一个一致的状态。因此，最终一致性的本质是需要系统保证最终数据能够达到一致，而不需要实时保证系统数据的强一致性。</p>
</li>
</ul>
<h2 id="cap-与-base-关系"><a class="markdownIt-Anchor" href="#cap-与-base-关系"></a> CAP 与 BASE 关系</h2>
<p>BASE是对CAP中一致性和可用性权衡的结果，其来源于对大规模互联网系统分布式实践的结论，是基于CAP定理逐步演化而来的，其核心思想是即使无法做到强一致性（Strong consistency），更具体地说，是对 CAP 中 AP 方案的一个补充。其基本思路就是：通过业务，牺牲强一致性而获得可用性，并允许数据在一段时间内是不一致的，但是最终达到一致性状态。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://pdai.tech/images/arch/arch-cap-2.png"
                      alt="img" 
                ></p>
<h2 id="cap-与-acid-关系"><a class="markdownIt-Anchor" href="#cap-与-acid-关系"></a> CAP 与 ACID 关系</h2>
<p>ACID 是传统数据库常用的设计理念，追求强一致性模型。BASE 支持的是大型分布式系统，提出通过牺牲强一致性获得高可用性。</p>
<p>ACID 和 BASE 代表了两种截然相反的设计哲学，在分布式系统设计的场景中，系统组件对一致性要求是不同的，因此 ACID 和 BASE 又会结合使用。</p>
]]></content>
      <categories>
        <category>分布式</category>
        <category>基础理论</category>
      </categories>
      <tags>
        <tag>分布式基础理论</tag>
        <tag>BASE</tag>
      </tags>
  </entry>
  <entry>
    <title>docker 中安装 nacos-server</title>
    <url>/posts/9ebe3fdc/</url>
    <content><![CDATA[<h2 id="拉取镜像"><a class="markdownIt-Anchor" href="#拉取镜像"></a> 拉取镜像</h2>
<div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="code"><pre><span class="line">docker pull nacos/nacos-server</span><br></pre></td></tr></table></figure></div>
<h2 id="挂载目录"><a class="markdownIt-Anchor" href="#挂载目录"></a> 挂载目录</h2>
<ol>
<li>
<p>新建logs目录</p>
<div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="code"><pre><span class="line">mkdir -p /usr/local/nacos/logs/</span><br></pre></td></tr></table></figure></div>
</li>
<li>
<p>新建配置目录</p>
<div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="code"><pre><span class="line">mkdir -p /usr/local/nacos/init.d/</span><br></pre></td></tr></table></figure></div>
</li>
<li>
<p>添加配置文件</p>
 <div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="code"><pre><span class="line">vim /usr/local/nacos/init.d/custom.properties</span><br></pre></td></tr></table></figure></div>
</li>
<li>
<p>修改配置文件custom.properties</p>
<div class="highlight-container" data-rel="Properties"><figure class="iseeu highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">server.contextPath</span>=<span class="string">/nacos</span></span><br><span class="line"><span class="attr">server.servlet.contextPath</span>=<span class="string">/nacos</span></span><br><span class="line"><span class="attr">server.port</span>=<span class="string">8848</span></span><br><span class="line"></span><br><span class="line"><span class="attr">spring.datasource.platform</span>=<span class="string">mysql</span></span><br><span class="line"><span class="attr">db.num</span>=<span class="string">1</span></span><br><span class="line"><span class="attr">db.url.0</span>=<span class="string">jdbc:mysql://xx.xx.xx.x:3306/nacos_devtest_prod?characterEncoding=utf8&amp;connectTimeout=1000&amp;socketTimeout=3000&amp;autoReconnect=true</span></span><br><span class="line"><span class="attr">db.user</span>=<span class="string">user</span></span><br><span class="line"><span class="attr">db.password</span>=<span class="string">pass</span></span><br><span class="line"></span><br><span class="line"><span class="attr">nacos.cmdb.dumpTaskInterval</span>=<span class="string">3600</span></span><br><span class="line"><span class="attr">nacos.cmdb.eventTaskInterval</span>=<span class="string">10</span></span><br><span class="line"><span class="attr">nacos.cmdb.labelTaskInterval</span>=<span class="string">300</span></span><br><span class="line"><span class="attr">nacos.cmdb.loadDataAtStart</span>=<span class="string">false</span></span><br><span class="line"><span class="attr">management.metrics.export.elastic.enabled</span>=<span class="string">false</span></span><br><span class="line"><span class="attr">management.metrics.export.influx.enabled</span>=<span class="string">false</span></span><br><span class="line"><span class="attr">server.tomcat.accesslog.enabled</span>=<span class="string">true</span></span><br><span class="line"><span class="attr">server.tomcat.accesslog.pattern</span>=<span class="string">%h %l %u %t &quot;%r&quot; %s %b %D %&#123;User-Agent&#125;i</span></span><br><span class="line"><span class="attr">nacos.security.ignore.urls</span>=<span class="string">/,/**/*.css,/**/*.js,/**/*.html,/**/*.map,/**/*.svg,/**/*.png,/**/*.ico,/console-fe/public/**,/v1/auth/login,/v1/console/health/**,/v1/cs/**,/v1/ns/**,/v1/cmdb/**,/actuator/**,/v1/console/server/**</span></span><br><span class="line"><span class="attr">nacos.naming.distro.taskDispatchThreadCount</span>=<span class="string">1</span></span><br><span class="line"><span class="attr">nacos.naming.distro.taskDispatchPeriod</span>=<span class="string">200</span></span><br><span class="line"><span class="attr">nacos.naming.distro.batchSyncKeyCount</span>=<span class="string">1000</span></span><br><span class="line"><span class="attr">nacos.naming.distro.initDataRatio</span>=<span class="string">0.9</span></span><br><span class="line"><span class="attr">nacos.naming.distro.syncRetryDelay</span>=<span class="string">5000</span></span><br><span class="line"><span class="attr">nacos.naming.data.warmup</span>=<span class="string">true</span></span><br><span class="line"><span class="attr">nacos.naming.expireInstance</span>=<span class="string">true</span></span><br><span class="line"><span class="comment">#开启账号密码认证，在java端连接nacos时则需要配置连接账号/密码。</span></span><br><span class="line"><span class="attr">nacos.core.auth.enabled</span>=<span class="string">true</span></span><br></pre></td></tr></table></figure></div>
</li>
</ol>
<h3 id="配置信息"><a class="markdownIt-Anchor" href="#配置信息"></a> 配置信息：</h3>
<table>
<thead>
<tr>
<th>参数名</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>MODE</td>
<td>cluster模式/standalone模式</td>
</tr>
<tr>
<td>NACOS_SERVERS</td>
<td>nacos cluster地址</td>
</tr>
<tr>
<td>PREFER_HOST_MODE</td>
<td>是否支持hostname</td>
</tr>
<tr>
<td>NACOS_SERVER_PORT</td>
<td>nacos服务器端口</td>
</tr>
<tr>
<td>NACOS_SERVER_IP</td>
<td>多网卡下的自定义nacos服务器IP</td>
</tr>
<tr>
<td>SPRING_DATASOURCE_PLATFORM</td>
<td>standalone 支持 mysql</td>
</tr>
<tr>
<td>MYSQL_MASTER_SERVICE_HOST</td>
<td>mysql 主节点host</td>
</tr>
<tr>
<td>MYSQL_MASTER_SERVICE_PORT</td>
<td>mysql 主节点端口</td>
</tr>
<tr>
<td>MYSQL_MASTER_SERVICE_DB_NAME</td>
<td>mysql 主节点数据库</td>
</tr>
<tr>
<td>MYSQL_MASTER_SERVICE_USER</td>
<td>数据库用户名</td>
</tr>
<tr>
<td>MYSQL_MASTER_SERVICE_PASSWORD</td>
<td>数据库密码</td>
</tr>
<tr>
<td>MYSQL_SLAVE_SERVICE_HOST</td>
<td>mysql从节点host</td>
</tr>
<tr>
<td>MYSQL_SLAVE_SERVICE_PORT</td>
<td>mysql从节点端口</td>
</tr>
<tr>
<td>MYSQL_DATABASE_NUM</td>
<td>数据库数量</td>
</tr>
<tr>
<td>JVM_XMS</td>
<td>-Xms</td>
</tr>
<tr>
<td>JVM_XMX</td>
<td>-Xmx</td>
</tr>
<tr>
<td>JVM_XMN</td>
<td>–Xmn</td>
</tr>
<tr>
<td>JVM_MS</td>
<td>–XX:MetaspaceSize</td>
</tr>
<tr>
<td>JVM_MMS</td>
<td>–XX:MaxMetaspaceSize</td>
</tr>
<tr>
<td>NACOS_DEBUG</td>
<td>开启远程调试</td>
</tr>
<tr>
<td>TOMCAT_ACCESSLOG_ENABLED</td>
<td>server.tomcat.accesslog.enabled</td>
</tr>
<tr>
<td>NACOS_AUTH_ENABLE=true</td>
<td>开启权限校验，就是要指定nacos账号密码</td>
</tr>
</tbody>
</table>
<h2 id="mysql新建nacos的数据库并执行脚本"><a class="markdownIt-Anchor" href="#mysql新建nacos的数据库并执行脚本"></a> mysql新建nacos的数据库，并执行脚本</h2>
<p><a class="link"   href="https://github.com/alibaba/nacos/blob/master/config/src/main/resources/META-INF/nacos-db.sql" >sql 脚本下载地址 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Copyright 1999-2018 Alibaba Group Holding Ltd.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);</span></span><br><span class="line"><span class="comment"> * you may not use this file except in compliance with the License.</span></span><br><span class="line"><span class="comment"> * You may obtain a copy of the License at</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *      http://www.apache.org/licenses/LICENSE-2.0</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Unless required by applicable law or agreed to in writing, software</span></span><br><span class="line"><span class="comment"> * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,</span></span><br><span class="line"><span class="comment"> * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.</span></span><br><span class="line"><span class="comment"> * See the License for the specific language governing permissions and</span></span><br><span class="line"><span class="comment"> * limitations under the License.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/******************************************/</span></span><br><span class="line"><span class="comment">/*   数据库全名 = nacos_config   */</span></span><br><span class="line"><span class="comment">/*   表名称 = config_info   */</span></span><br><span class="line"><span class="comment">/******************************************/</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `config_info` (</span><br><span class="line">  `id` <span class="type">bigint</span>(<span class="number">20</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> AUTO_INCREMENT COMMENT <span class="string">&#x27;id&#x27;</span>,</span><br><span class="line">  `data_id` <span class="type">varchar</span>(<span class="number">255</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;data_id&#x27;</span>,</span><br><span class="line">  `group_id` <span class="type">varchar</span>(<span class="number">128</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `content` longtext <span class="keyword">NOT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;content&#x27;</span>,</span><br><span class="line">  `md5` <span class="type">varchar</span>(<span class="number">32</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;md5&#x27;</span>,</span><br><span class="line">  `gmt_create` datetime <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="string">&#x27;2010-05-05 00:00:00&#x27;</span> COMMENT <span class="string">&#x27;创建时间&#x27;</span>,</span><br><span class="line">  `gmt_modified` datetime <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="string">&#x27;2010-05-05 00:00:00&#x27;</span> COMMENT <span class="string">&#x27;修改时间&#x27;</span>,</span><br><span class="line">  `src_user` text COMMENT <span class="string">&#x27;source user&#x27;</span>,</span><br><span class="line">  `src_ip` <span class="type">varchar</span>(<span class="number">20</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;source ip&#x27;</span>,</span><br><span class="line">  `app_name` <span class="type">varchar</span>(<span class="number">128</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `tenant_id` <span class="type">varchar</span>(<span class="number">128</span>) <span class="keyword">DEFAULT</span> <span class="string">&#x27;&#x27;</span> COMMENT <span class="string">&#x27;租户字段&#x27;</span>,</span><br><span class="line">  `c_desc` <span class="type">varchar</span>(<span class="number">256</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `c_use` <span class="type">varchar</span>(<span class="number">64</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `effect` <span class="type">varchar</span>(<span class="number">64</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `type` <span class="type">varchar</span>(<span class="number">64</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `c_schema` text,</span><br><span class="line">  `encrypted_data_key` text <span class="keyword">NOT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;秘钥&#x27;</span>,</span><br><span class="line">  <span class="keyword">PRIMARY</span> KEY (`id`),</span><br><span class="line">  <span class="keyword">UNIQUE</span> KEY `uk_configinfo_datagrouptenant` (`data_id`,`group_id`,`tenant_id`)</span><br><span class="line">) ENGINE<span class="operator">=</span>InnoDB <span class="keyword">DEFAULT</span> CHARSET<span class="operator">=</span>utf8 <span class="keyword">COLLATE</span><span class="operator">=</span>utf8_bin COMMENT<span class="operator">=</span><span class="string">&#x27;config_info&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/******************************************/</span></span><br><span class="line"><span class="comment">/*   数据库全名 = nacos_config   */</span></span><br><span class="line"><span class="comment">/*   表名称 = config_info_aggr   */</span></span><br><span class="line"><span class="comment">/******************************************/</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `config_info_aggr` (</span><br><span class="line">  `id` <span class="type">bigint</span>(<span class="number">20</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> AUTO_INCREMENT COMMENT <span class="string">&#x27;id&#x27;</span>,</span><br><span class="line">  `data_id` <span class="type">varchar</span>(<span class="number">255</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;data_id&#x27;</span>,</span><br><span class="line">  `group_id` <span class="type">varchar</span>(<span class="number">128</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;group_id&#x27;</span>,</span><br><span class="line">  `datum_id` <span class="type">varchar</span>(<span class="number">255</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;datum_id&#x27;</span>,</span><br><span class="line">  `content` longtext <span class="keyword">NOT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;内容&#x27;</span>,</span><br><span class="line">  `gmt_modified` datetime <span class="keyword">NOT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;修改时间&#x27;</span>,</span><br><span class="line">  `app_name` <span class="type">varchar</span>(<span class="number">128</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `tenant_id` <span class="type">varchar</span>(<span class="number">128</span>) <span class="keyword">DEFAULT</span> <span class="string">&#x27;&#x27;</span> COMMENT <span class="string">&#x27;租户字段&#x27;</span>,</span><br><span class="line">  <span class="keyword">PRIMARY</span> KEY (`id`),</span><br><span class="line">  <span class="keyword">UNIQUE</span> KEY `uk_configinfoaggr_datagrouptenantdatum` (`data_id`,`group_id`,`tenant_id`,`datum_id`)</span><br><span class="line">) ENGINE<span class="operator">=</span>InnoDB <span class="keyword">DEFAULT</span> CHARSET<span class="operator">=</span>utf8 <span class="keyword">COLLATE</span><span class="operator">=</span>utf8_bin COMMENT<span class="operator">=</span><span class="string">&#x27;增加租户字段&#x27;</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/******************************************/</span></span><br><span class="line"><span class="comment">/*   数据库全名 = nacos_config   */</span></span><br><span class="line"><span class="comment">/*   表名称 = config_info_beta   */</span></span><br><span class="line"><span class="comment">/******************************************/</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `config_info_beta` (</span><br><span class="line">  `id` <span class="type">bigint</span>(<span class="number">20</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> AUTO_INCREMENT COMMENT <span class="string">&#x27;id&#x27;</span>,</span><br><span class="line">  `data_id` <span class="type">varchar</span>(<span class="number">255</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;data_id&#x27;</span>,</span><br><span class="line">  `group_id` <span class="type">varchar</span>(<span class="number">128</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;group_id&#x27;</span>,</span><br><span class="line">  `app_name` <span class="type">varchar</span>(<span class="number">128</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;app_name&#x27;</span>,</span><br><span class="line">  `content` longtext <span class="keyword">NOT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;content&#x27;</span>,</span><br><span class="line">  `beta_ips` <span class="type">varchar</span>(<span class="number">1024</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;betaIps&#x27;</span>,</span><br><span class="line">  `md5` <span class="type">varchar</span>(<span class="number">32</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;md5&#x27;</span>,</span><br><span class="line">  `gmt_create` datetime <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="string">&#x27;2010-05-05 00:00:00&#x27;</span> COMMENT <span class="string">&#x27;创建时间&#x27;</span>,</span><br><span class="line">  `gmt_modified` datetime <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="string">&#x27;2010-05-05 00:00:00&#x27;</span> COMMENT <span class="string">&#x27;修改时间&#x27;</span>,</span><br><span class="line">  `src_user` text COMMENT <span class="string">&#x27;source user&#x27;</span>,</span><br><span class="line">  `src_ip` <span class="type">varchar</span>(<span class="number">20</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;source ip&#x27;</span>,</span><br><span class="line">  `tenant_id` <span class="type">varchar</span>(<span class="number">128</span>) <span class="keyword">DEFAULT</span> <span class="string">&#x27;&#x27;</span> COMMENT <span class="string">&#x27;租户字段&#x27;</span>,</span><br><span class="line">  `encrypted_data_key` text <span class="keyword">NOT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;秘钥&#x27;</span>,</span><br><span class="line">  <span class="keyword">PRIMARY</span> KEY (`id`),</span><br><span class="line">  <span class="keyword">UNIQUE</span> KEY `uk_configinfobeta_datagrouptenant` (`data_id`,`group_id`,`tenant_id`)</span><br><span class="line">) ENGINE<span class="operator">=</span>InnoDB <span class="keyword">DEFAULT</span> CHARSET<span class="operator">=</span>utf8 <span class="keyword">COLLATE</span><span class="operator">=</span>utf8_bin COMMENT<span class="operator">=</span><span class="string">&#x27;config_info_beta&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/******************************************/</span></span><br><span class="line"><span class="comment">/*   数据库全名 = nacos_config   */</span></span><br><span class="line"><span class="comment">/*   表名称 = config_info_tag   */</span></span><br><span class="line"><span class="comment">/******************************************/</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `config_info_tag` (</span><br><span class="line">  `id` <span class="type">bigint</span>(<span class="number">20</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> AUTO_INCREMENT COMMENT <span class="string">&#x27;id&#x27;</span>,</span><br><span class="line">  `data_id` <span class="type">varchar</span>(<span class="number">255</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;data_id&#x27;</span>,</span><br><span class="line">  `group_id` <span class="type">varchar</span>(<span class="number">128</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;group_id&#x27;</span>,</span><br><span class="line">  `tenant_id` <span class="type">varchar</span>(<span class="number">128</span>) <span class="keyword">DEFAULT</span> <span class="string">&#x27;&#x27;</span> COMMENT <span class="string">&#x27;tenant_id&#x27;</span>,</span><br><span class="line">  `tag_id` <span class="type">varchar</span>(<span class="number">128</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;tag_id&#x27;</span>,</span><br><span class="line">  `app_name` <span class="type">varchar</span>(<span class="number">128</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;app_name&#x27;</span>,</span><br><span class="line">  `content` longtext <span class="keyword">NOT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;content&#x27;</span>,</span><br><span class="line">  `md5` <span class="type">varchar</span>(<span class="number">32</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;md5&#x27;</span>,</span><br><span class="line">  `gmt_create` datetime <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="string">&#x27;2010-05-05 00:00:00&#x27;</span> COMMENT <span class="string">&#x27;创建时间&#x27;</span>,</span><br><span class="line">  `gmt_modified` datetime <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="string">&#x27;2010-05-05 00:00:00&#x27;</span> COMMENT <span class="string">&#x27;修改时间&#x27;</span>,</span><br><span class="line">  `src_user` text COMMENT <span class="string">&#x27;source user&#x27;</span>,</span><br><span class="line">  `src_ip` <span class="type">varchar</span>(<span class="number">20</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;source ip&#x27;</span>,</span><br><span class="line">  <span class="keyword">PRIMARY</span> KEY (`id`),</span><br><span class="line">  <span class="keyword">UNIQUE</span> KEY `uk_configinfotag_datagrouptenanttag` (`data_id`,`group_id`,`tenant_id`,`tag_id`)</span><br><span class="line">) ENGINE<span class="operator">=</span>InnoDB <span class="keyword">DEFAULT</span> CHARSET<span class="operator">=</span>utf8 <span class="keyword">COLLATE</span><span class="operator">=</span>utf8_bin COMMENT<span class="operator">=</span><span class="string">&#x27;config_info_tag&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/******************************************/</span></span><br><span class="line"><span class="comment">/*   数据库全名 = nacos_config   */</span></span><br><span class="line"><span class="comment">/*   表名称 = config_tags_relation   */</span></span><br><span class="line"><span class="comment">/******************************************/</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `config_tags_relation` (</span><br><span class="line">  `id` <span class="type">bigint</span>(<span class="number">20</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;id&#x27;</span>,</span><br><span class="line">  `tag_name` <span class="type">varchar</span>(<span class="number">128</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;tag_name&#x27;</span>,</span><br><span class="line">  `tag_type` <span class="type">varchar</span>(<span class="number">64</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;tag_type&#x27;</span>,</span><br><span class="line">  `data_id` <span class="type">varchar</span>(<span class="number">255</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;data_id&#x27;</span>,</span><br><span class="line">  `group_id` <span class="type">varchar</span>(<span class="number">128</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;group_id&#x27;</span>,</span><br><span class="line">  `tenant_id` <span class="type">varchar</span>(<span class="number">128</span>) <span class="keyword">DEFAULT</span> <span class="string">&#x27;&#x27;</span> COMMENT <span class="string">&#x27;tenant_id&#x27;</span>,</span><br><span class="line">  `nid` <span class="type">bigint</span>(<span class="number">20</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> AUTO_INCREMENT,</span><br><span class="line">  <span class="keyword">PRIMARY</span> KEY (`nid`),</span><br><span class="line">  <span class="keyword">UNIQUE</span> KEY `uk_configtagrelation_configidtag` (`id`,`tag_name`,`tag_type`),</span><br><span class="line">  KEY `idx_tenant_id` (`tenant_id`)</span><br><span class="line">) ENGINE<span class="operator">=</span>InnoDB <span class="keyword">DEFAULT</span> CHARSET<span class="operator">=</span>utf8 <span class="keyword">COLLATE</span><span class="operator">=</span>utf8_bin COMMENT<span class="operator">=</span><span class="string">&#x27;config_tag_relation&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/******************************************/</span></span><br><span class="line"><span class="comment">/*   数据库全名 = nacos_config   */</span></span><br><span class="line"><span class="comment">/*   表名称 = group_capacity   */</span></span><br><span class="line"><span class="comment">/******************************************/</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `group_capacity` (</span><br><span class="line">  `id` <span class="type">bigint</span>(<span class="number">20</span>) unsigned <span class="keyword">NOT</span> <span class="keyword">NULL</span> AUTO_INCREMENT COMMENT <span class="string">&#x27;主键ID&#x27;</span>,</span><br><span class="line">  `group_id` <span class="type">varchar</span>(<span class="number">128</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="string">&#x27;&#x27;</span> COMMENT <span class="string">&#x27;Group ID，空字符表示整个集群&#x27;</span>,</span><br><span class="line">  `quota` <span class="type">int</span>(<span class="number">10</span>) unsigned <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="string">&#x27;0&#x27;</span> COMMENT <span class="string">&#x27;配额，0表示使用默认值&#x27;</span>,</span><br><span class="line">  `usage` <span class="type">int</span>(<span class="number">10</span>) unsigned <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="string">&#x27;0&#x27;</span> COMMENT <span class="string">&#x27;使用量&#x27;</span>,</span><br><span class="line">  `max_size` <span class="type">int</span>(<span class="number">10</span>) unsigned <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="string">&#x27;0&#x27;</span> COMMENT <span class="string">&#x27;单个配置大小上限，单位为字节，0表示使用默认值&#x27;</span>,</span><br><span class="line">  `max_aggr_count` <span class="type">int</span>(<span class="number">10</span>) unsigned <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="string">&#x27;0&#x27;</span> COMMENT <span class="string">&#x27;聚合子配置最大个数，，0表示使用默认值&#x27;</span>,</span><br><span class="line">  `max_aggr_size` <span class="type">int</span>(<span class="number">10</span>) unsigned <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="string">&#x27;0&#x27;</span> COMMENT <span class="string">&#x27;单个聚合数据的子配置大小上限，单位为字节，0表示使用默认值&#x27;</span>,</span><br><span class="line">  `max_history_count` <span class="type">int</span>(<span class="number">10</span>) unsigned <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="string">&#x27;0&#x27;</span> COMMENT <span class="string">&#x27;最大变更历史数量&#x27;</span>,</span><br><span class="line">  `gmt_create` datetime <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="string">&#x27;2010-05-05 00:00:00&#x27;</span> COMMENT <span class="string">&#x27;创建时间&#x27;</span>,</span><br><span class="line">  `gmt_modified` datetime <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="string">&#x27;2010-05-05 00:00:00&#x27;</span> COMMENT <span class="string">&#x27;修改时间&#x27;</span>,</span><br><span class="line">  <span class="keyword">PRIMARY</span> KEY (`id`),</span><br><span class="line">  <span class="keyword">UNIQUE</span> KEY `uk_group_id` (`group_id`)</span><br><span class="line">) ENGINE<span class="operator">=</span>InnoDB <span class="keyword">DEFAULT</span> CHARSET<span class="operator">=</span>utf8 <span class="keyword">COLLATE</span><span class="operator">=</span>utf8_bin COMMENT<span class="operator">=</span><span class="string">&#x27;集群、各Group容量信息表&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/******************************************/</span></span><br><span class="line"><span class="comment">/*   数据库全名 = nacos_config   */</span></span><br><span class="line"><span class="comment">/*   表名称 = his_config_info   */</span></span><br><span class="line"><span class="comment">/******************************************/</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `his_config_info` (</span><br><span class="line">  `id` <span class="type">bigint</span>(<span class="number">64</span>) unsigned <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `nid` <span class="type">bigint</span>(<span class="number">20</span>) unsigned <span class="keyword">NOT</span> <span class="keyword">NULL</span> AUTO_INCREMENT,</span><br><span class="line">  `data_id` <span class="type">varchar</span>(<span class="number">255</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `group_id` <span class="type">varchar</span>(<span class="number">128</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `app_name` <span class="type">varchar</span>(<span class="number">128</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;app_name&#x27;</span>,</span><br><span class="line">  `content` longtext <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `md5` <span class="type">varchar</span>(<span class="number">32</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `gmt_create` datetime <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="string">&#x27;2010-05-05 00:00:00&#x27;</span>,</span><br><span class="line">  `gmt_modified` datetime <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="string">&#x27;2010-05-05 00:00:00&#x27;</span>,</span><br><span class="line">  `src_user` text,</span><br><span class="line">  `src_ip` <span class="type">varchar</span>(<span class="number">20</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `op_type` <span class="type">char</span>(<span class="number">10</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `tenant_id` <span class="type">varchar</span>(<span class="number">128</span>) <span class="keyword">DEFAULT</span> <span class="string">&#x27;&#x27;</span> COMMENT <span class="string">&#x27;租户字段&#x27;</span>,</span><br><span class="line">  `encrypted_data_key` text <span class="keyword">NOT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;秘钥&#x27;</span>,</span><br><span class="line">  <span class="keyword">PRIMARY</span> KEY (`nid`),</span><br><span class="line">  KEY `idx_gmt_create` (`gmt_create`),</span><br><span class="line">  KEY `idx_gmt_modified` (`gmt_modified`),</span><br><span class="line">  KEY `idx_did` (`data_id`)</span><br><span class="line">) ENGINE<span class="operator">=</span>InnoDB <span class="keyword">DEFAULT</span> CHARSET<span class="operator">=</span>utf8 <span class="keyword">COLLATE</span><span class="operator">=</span>utf8_bin COMMENT<span class="operator">=</span><span class="string">&#x27;多租户改造&#x27;</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/******************************************/</span></span><br><span class="line"><span class="comment">/*   数据库全名 = nacos_config   */</span></span><br><span class="line"><span class="comment">/*   表名称 = tenant_capacity   */</span></span><br><span class="line"><span class="comment">/******************************************/</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `tenant_capacity` (</span><br><span class="line">  `id` <span class="type">bigint</span>(<span class="number">20</span>) unsigned <span class="keyword">NOT</span> <span class="keyword">NULL</span> AUTO_INCREMENT COMMENT <span class="string">&#x27;主键ID&#x27;</span>,</span><br><span class="line">  `tenant_id` <span class="type">varchar</span>(<span class="number">128</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="string">&#x27;&#x27;</span> COMMENT <span class="string">&#x27;Tenant ID&#x27;</span>,</span><br><span class="line">  `quota` <span class="type">int</span>(<span class="number">10</span>) unsigned <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="string">&#x27;0&#x27;</span> COMMENT <span class="string">&#x27;配额，0表示使用默认值&#x27;</span>,</span><br><span class="line">  `usage` <span class="type">int</span>(<span class="number">10</span>) unsigned <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="string">&#x27;0&#x27;</span> COMMENT <span class="string">&#x27;使用量&#x27;</span>,</span><br><span class="line">  `max_size` <span class="type">int</span>(<span class="number">10</span>) unsigned <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="string">&#x27;0&#x27;</span> COMMENT <span class="string">&#x27;单个配置大小上限，单位为字节，0表示使用默认值&#x27;</span>,</span><br><span class="line">  `max_aggr_count` <span class="type">int</span>(<span class="number">10</span>) unsigned <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="string">&#x27;0&#x27;</span> COMMENT <span class="string">&#x27;聚合子配置最大个数&#x27;</span>,</span><br><span class="line">  `max_aggr_size` <span class="type">int</span>(<span class="number">10</span>) unsigned <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="string">&#x27;0&#x27;</span> COMMENT <span class="string">&#x27;单个聚合数据的子配置大小上限，单位为字节，0表示使用默认值&#x27;</span>,</span><br><span class="line">  `max_history_count` <span class="type">int</span>(<span class="number">10</span>) unsigned <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="string">&#x27;0&#x27;</span> COMMENT <span class="string">&#x27;最大变更历史数量&#x27;</span>,</span><br><span class="line">  `gmt_create` datetime <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="string">&#x27;2010-05-05 00:00:00&#x27;</span> COMMENT <span class="string">&#x27;创建时间&#x27;</span>,</span><br><span class="line">  `gmt_modified` datetime <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="string">&#x27;2010-05-05 00:00:00&#x27;</span> COMMENT <span class="string">&#x27;修改时间&#x27;</span>,</span><br><span class="line">  <span class="keyword">PRIMARY</span> KEY (`id`),</span><br><span class="line">  <span class="keyword">UNIQUE</span> KEY `uk_tenant_id` (`tenant_id`)</span><br><span class="line">) ENGINE<span class="operator">=</span>InnoDB <span class="keyword">DEFAULT</span> CHARSET<span class="operator">=</span>utf8 <span class="keyword">COLLATE</span><span class="operator">=</span>utf8_bin COMMENT<span class="operator">=</span><span class="string">&#x27;租户容量信息表&#x27;</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `tenant_info` (</span><br><span class="line">  `id` <span class="type">bigint</span>(<span class="number">20</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> AUTO_INCREMENT COMMENT <span class="string">&#x27;id&#x27;</span>,</span><br><span class="line">  `kp` <span class="type">varchar</span>(<span class="number">128</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;kp&#x27;</span>,</span><br><span class="line">  `tenant_id` <span class="type">varchar</span>(<span class="number">128</span>) <span class="keyword">default</span> <span class="string">&#x27;&#x27;</span> COMMENT <span class="string">&#x27;tenant_id&#x27;</span>,</span><br><span class="line">  `tenant_name` <span class="type">varchar</span>(<span class="number">128</span>) <span class="keyword">default</span> <span class="string">&#x27;&#x27;</span> COMMENT <span class="string">&#x27;tenant_name&#x27;</span>,</span><br><span class="line">  `tenant_desc` <span class="type">varchar</span>(<span class="number">256</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;tenant_desc&#x27;</span>,</span><br><span class="line">  `create_source` <span class="type">varchar</span>(<span class="number">32</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;create_source&#x27;</span>,</span><br><span class="line">  `gmt_create` <span class="type">bigint</span>(<span class="number">20</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;创建时间&#x27;</span>,</span><br><span class="line">  `gmt_modified` <span class="type">bigint</span>(<span class="number">20</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;修改时间&#x27;</span>,</span><br><span class="line">  <span class="keyword">PRIMARY</span> KEY (`id`),</span><br><span class="line">  <span class="keyword">UNIQUE</span> KEY `uk_tenant_info_kptenantid` (`kp`,`tenant_id`),</span><br><span class="line">  KEY `idx_tenant_id` (`tenant_id`)</span><br><span class="line">) ENGINE<span class="operator">=</span>InnoDB <span class="keyword">DEFAULT</span> CHARSET<span class="operator">=</span>utf8 <span class="keyword">COLLATE</span><span class="operator">=</span>utf8_bin COMMENT<span class="operator">=</span><span class="string">&#x27;tenant_info&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> users (</span><br><span class="line">	username <span class="type">varchar</span>(<span class="number">50</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">PRIMARY</span> KEY,</span><br><span class="line">	password <span class="type">varchar</span>(<span class="number">500</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">	enabled <span class="type">boolean</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> roles (</span><br><span class="line">	username <span class="type">varchar</span>(<span class="number">50</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">	role <span class="type">varchar</span>(<span class="number">50</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">	<span class="keyword">constraint</span> uk_username_role <span class="keyword">UNIQUE</span> (username,role)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> permissions (</span><br><span class="line">    role <span class="type">varchar</span>(<span class="number">50</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">    resource <span class="type">varchar</span>(<span class="number">512</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">    action <span class="type">varchar</span>(<span class="number">8</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">    <span class="keyword">constraint</span> uk_role_permission <span class="keyword">UNIQUE</span> (role,resource,action)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> users (username, password, enabled) <span class="keyword">VALUES</span> (<span class="string">&#x27;nacos&#x27;</span>, <span class="string">&#x27;$2a$10$EuWPZHzz32dJN7jexM34MOeYirDdFAZm2kuWj7VEOJhhZkDrxfvUu&#x27;</span>, <span class="literal">TRUE</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> roles (username, role) <span class="keyword">VALUES</span> (<span class="string">&#x27;nacos&#x27;</span>, <span class="string">&#x27;ROLE_ADMIN&#x27;</span>);</span><br></pre></td></tr></table></figure></div>
<h2 id="启动容器"><a class="markdownIt-Anchor" href="#启动容器"></a> 启动容器</h2>
<p>挂载配置文件：</p>
<div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="code"><pre><span class="line">docker run -d \</span><br><span class="line">--restart=always \</span><br><span class="line">--privileged=true \</span><br><span class="line">--name nacos \</span><br><span class="line">-e JVM_XMS=256m \</span><br><span class="line">-e JVM_XMX=256m \</span><br><span class="line">-e MODE=standalone \</span><br><span class="line">-e PREFER_HOST_MODE=hostname \</span><br><span class="line">-p 8848:8848 -p 9848:9848 -p 9849:9849 \</span><br><span class="line">-v /usr/local/nacos/logs:/home/nacos/logs \</span><br><span class="line">-v /usr/local/nacos/init.d:/home/nacos/init.d \</span><br><span class="line">nacos/nacos-server</span><br></pre></td></tr></table></figure></div>
<p>另一种写法可以不用配置文件：</p>
<div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="code"><pre><span class="line">docker run -d -p 8848:8848  -p 9848:9848 -p 9849:9849 \</span><br><span class="line">-e MODE=standalone \</span><br><span class="line">-e PREFER_HOST_MODE=本机IP \</span><br><span class="line">-e SPRING_DATASOURCE_PLATFORM=mysql \</span><br><span class="line">-e MYSQL_SERVICE_HOST=127.0.0.1 \</span><br><span class="line">-e MYSQL_SERVICE_PORT=3306 \</span><br><span class="line">-e MYSQL_SERVICE_USER=root \</span><br><span class="line">-e MYSQL_SERVICE_PASSWORD=password \</span><br><span class="line">-e MYSQL_SERVICE_DB_NAME=nacos \</span><br><span class="line">--name nacos \</span><br><span class="line">--restart=always nacos/nacos-server</span><br></pre></td></tr></table></figure></div>
<h2 id="验证"><a class="markdownIt-Anchor" href="#验证"></a> 验证</h2>
<p>浏览器输入服务器地址：<a class="link"   href="http://xxx.xxx.xx.xx:8848/nacos/index.html%EF%BC%8C%E8%B4%A6%E5%8F%B7nacos" >http://xxx.xxx.xx.xx:8848/nacos/index.html，账号nacos <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a> 密码nacos，登陆成功！</p>
]]></content>
      <categories>
        <category>docker</category>
        <category>镜像安装</category>
      </categories>
      <tags>
        <tag>docker</tag>
        <tag>nacos</tag>
      </tags>
  </entry>
  <entry>
    <title>分布式理论基础-CAP</title>
    <url>/posts/e64162da/</url>
    <content><![CDATA[<blockquote>
<p>CAP理论是分布式系统、特别是分布式存储领域中被讨论的最多的理论。其中C代表一致性 (Consistency)，A代表可用性 (Availability)，P代表分区容错性 (Partition tolerance)。CAP理论告诉我们C、A、P三者不能同时满足，最多只能满足其中两个。</p>
</blockquote>
<h2 id="简介"><a class="markdownIt-Anchor" href="#简介"></a> 简介</h2>
<p>CAP理论是分布式系统、特别是分布式存储领域中被讨论的最多的理论。其中C代表一致性 (Consistency)，A代表可用性 (Availability)，P代表分区容错性 (Partition tolerance)。CAP理论告诉我们C、A、P三者不能同时满足，最多只能满足其中两个。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://pdai.tech/images/arch/arch-cap-1.png"
                      alt="" 
                ></p>
<h3 id="cap-三选二"><a class="markdownIt-Anchor" href="#cap-三选二"></a> CAP 三选二</h3>
<p><code>一致性 (Consistency)</code>: 一个写操作返回成功，那么之后的读请求都必须读到这个新数据；如果返回失败，那么所有读操作都不能读到这个数据。所有节点访问同一份最新的数据。</p>
<p><code>可用性 (Availability)</code>: 对数据更新具备高可用性，请求能够及时处理，不会一直等待，即使出现节点失效。</p>
<p><code>分区容错性 (Partition tolerance)</code>: 能容忍网络分区，在网络断开的情况下，被分隔的节点仍能正常对外提供服务。</p>
<h2 id="理解"><a class="markdownIt-Anchor" href="#理解"></a> 理解</h2>
<p>理解CAP理论最简单的方式是想象两个副本处于分区两侧，即两个副本之间的网络断开，不能通信。</p>
<ul>
<li>如果允许其中一个副本更新，则会导致数据不一致，即丧失了C性质。</li>
<li>如果为了保证一致性，将分区某一侧的副本设置为不可用，那么又丧失了A性质。</li>
<li>除非两个副本可以互相通信，才能既保证C又保证A，这又会导致丧失P性质。</li>
</ul>
<p>一般来说使用网络通信的分布式系统，无法舍弃P性质，那么就只能在一致性和可用性上做一个艰难的选择。</p>
<div class="note-large notel-green"><div class="notel-title"><p>提示</p>
</div><div class="notel-content"><p>在CAP理论提出十二年之后，其作者又出来辟谣。“三选二”的公式一直存在着误导性，它会过分简单化各性质之间的相互关系:</p>
<ul>
<li>首先，由于分区很少发生，那么在系统不存在分区的情况下没什么理由牺牲C或A。</li>
<li>其次，C与A之间的取舍可以在同一系统内以非常细小的粒度反复发生，而每一次的决策可能因为具体的操作，乃至因为牵涉到特定的数据或用户而有所不同。</li>
<li>最后，这三种性质都可以在程度上衡量，并不是非黑即白的有或无。可用性显然是在0%到100%之间连续变化的，一致性分很多级别，连分区也可以细分为不同含义，如系统内的不同部分对于是否存在分区可以有不一样的认知。</li>
</ul>
<p>所以一致性和可用性并不是水火不容，非此即彼的。Paxos、Raft等分布式一致性算法就是在一致性和可用性之间做到了很好的平衡的见证。</p>
 </div></div>
]]></content>
      <categories>
        <category>分布式</category>
        <category>基础理论</category>
      </categories>
      <tags>
        <tag>分布式基础理论</tag>
        <tag>CAP</tag>
      </tags>
  </entry>
  <entry>
    <title>DDD 分层架构</title>
    <url>/posts/29d01c/</url>
    <content><![CDATA[<p>DDD 分层架构是一种以领域驱动设计（DDD）为基础的软件架构设计方法，通过将系统按照职责进行分层，将业务逻辑从技术细节中解耦出来，实现了代码的易维护、易测试和易扩展。</p>
<h2 id="ddd-分层架构"><a class="markdownIt-Anchor" href="#ddd-分层架构"></a> DDD 分层架构</h2>
<p><code>DDD 分层架构</code>是一种组织代码的方式，通过将代码分为不同的层次来实现解耦合。一般而言，分层架构包括以下几个层次：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="ddd-ach.png"
                      alt="DDD 分层架构" 
                ></p>
<div class="note-large notel-green"><div class="notel-title"><p>DDD分层架构</p>
</div><div class="notel-content"><ul>
<li>表示层：负责与用户进行交互，并将请求转发给下一层</li>
<li>应用层：负责协调各个领域对象完成具体的业务功能</li>
<li>领域层：负责定义业务领域中的概念和规则，是整个应用程序的核心</li>
<li>基础设施层：提供访问外部资源（数据库、网络等）的能力，同时也负责存储领域对象</li>
</ul>
 </div></div>
<h2 id="ddd-分层架构的优势"><a class="markdownIt-Anchor" href="#ddd-分层架构的优势"></a> DDD 分层架构的优势</h2>
<h3 id="易于维护"><a class="markdownIt-Anchor" href="#易于维护"></a> 易于维护</h3>
<p>DDD 分层架构将系统按照职责进行分层，每一层都有自己的职责，这样就使得系统易于维护。因为每一层都是独立的，所以修改其中一个层次不会对其他层次造成影响。</p>
<h3 id="易于测试"><a class="markdownIt-Anchor" href="#易于测试"></a> 易于测试</h3>
<p>由于每一层职责的清晰划分，测试也相对容易实现。例如，在领域层中实现业务逻辑，并编写单元测试来验证其正确性。</p>
<h3 id="易于扩展"><a class="markdownIt-Anchor" href="#易于扩展"></a> 易于扩展</h3>
<p>由于 DDD 分层架构的松耦合特性，增加新功能或者更改已有功能时，只需要修改相关的层次即可，而不会对整个系统造成影响。这也为系统未来的扩展提供了便利。</p>
<h2 id="ddd-分层架构的实现"><a class="markdownIt-Anchor" href="#ddd-分层架构的实现"></a> DDD 分层架构的实现</h2>
<h3 id="一级代码目录"><a class="markdownIt-Anchor" href="#一级代码目录"></a> 一级代码目录</h3>
<p>微服务一级目录是按照<span style="border-bottom: 2px solid green">DDD分层架构的分层职责</span>来定义的。 整体的目录结构如下：</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line">├── src</span><br><span class="line">│   ├── main</span><br><span class="line">│   │   ├── java</span><br><span class="line">│   │   │   ├── love</span><br><span class="line">│   │   │   │   ├── heer</span><br><span class="line">│   │   │   │   │   ├── application <span class="comment">// 应用层</span></span><br><span class="line">│   │   │   │   │   ├── domain <span class="comment">// 领域层</span></span><br><span class="line">│   │   │   │   │   ├── infrastructure <span class="comment">// 基础层</span></span><br><span class="line">│   │   │   │   │   └── interfaces <span class="comment">// 表现层</span></span><br><span class="line">│   │   │   └── resources</span><br><span class="line">│   │   ├── resources</span><br><span class="line">│   │   └── webapp</span><br><span class="line">│   └── test</span><br><span class="line">│       ├── java</span><br><span class="line">│       │   └── com</span><br><span class="line">│       │       └── example</span><br><span class="line">│       └── resources</span><br><span class="line"></span><br></pre></td></tr></table></figure></div>
<p>在微服务代码模型里，我们分别定义了用户接口层、应用层、领域层和基础层四层，并分别为它们建立了interfaces、application、domain和infrastructure四个一级代码目录，如图所示。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="ddd-java-ach01.webp"
                      alt="DDD 分层01" 
                ></p>
<div class="note-large notel-green"><div class="notel-title"><p>这些代码目录的职能</p>
</div><div class="notel-content"><ul>
<li><code>interfaces（用户接口层）</code>：它主要存放用户接口层与前端应用交互、数据转换和交互相关的代码。前端应用通过这一层的接口，从应用服务获取前端展现所需的数据。处理前端用户发送的REStful请求，解析用户输入的配置文件，并将数据传递给application层。数据的组装、数据传输格式转换以及facade接口封装等代码都会放在这一层目录里。</li>
<li><code>application（应用层）</code>：它主要存放与应用层服务组合和编排相关的代码。应用服务向下基于微服务内的领域服务或外部微服务的应用服务，完成服务的组合和编排，向上为用户接口层提供各种应用数据支持服务。应用服务和事件等代码会放在这一层目录里。</li>
<li><code>domain（领域层）</code>：它主要存放与领域层核心业务逻辑相关的代码。领域层可以包含多个聚合代码包，它们共同实现领域模型的核心业务逻辑。聚合内的聚合根以及实体、方法、值对象、领域服务和事件等相关代码会放在这一层目录里。</li>
<li><code>infrastructure（基础层）</code>：它主要存放与基础资源服务相关的代码。为其他各层提供的通用技术能力、三方软件包、数据库服务、配置和基础资源服务的代码都会放在这一层目录里。</li>
</ul>
 </div></div>
<h3 id="各层代码目录"><a class="markdownIt-Anchor" href="#各层代码目录"></a> 各层代码目录</h3>
<p>下面我们一起来看一下用户接口层、应用层、领域层以及基础层各自的二级代码目录结构。</p>
<h4 id="用户接口层"><a class="markdownIt-Anchor" href="#用户接口层"></a> 用户接口层</h4>
<p><code>interfaces</code> 目录下的代码目录结构有assembler、dto和facade三类，如图所示。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="ddd-java-ach02.webp"
                      alt="interface" 
                ></p>
<ul>
<li><code>assembler</code>：实现DTO与DO领域对象之间的相互转换和数据交换。一般来说，assembler与dto总是同时出现。</li>
<li><code>dto</code>：它是前端应用数据传输的载体，不实现任何业务逻辑。我们可以面向前端应用将应用层或领域层的DO对象转换为前端需要的DTO对象，从而隐藏领域模型内部领域对象DO；也可以将前端传入的DTO对象转换为应用服务或领域服务所需要的DO对象。</li>
<li><code>facade</code>：封装应用服务，提供较粗粒度的调用接口，或者将用户请求委派给一个或多个应用服务进行处理。</li>
</ul>
<h4 id="应用层"><a class="markdownIt-Anchor" href="#应用层"></a> 应用层</h4>
<p><code>application</code> 的代码目录结构有 event 和 service 以及 dto，如图所示。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="ddd-java-ach03.webp"
                      alt="application" 
                ></p>
<ul>
<li><code>event（事件）</code>：这层目录主要存放事件相关的代码。它包括两个子目录：publish和subscribe。前者主要存放事件发布相关代码，后者主要存放事件订阅相关代码。事件处理相关的核心业务逻辑在领域层实现。<br />
应用层和领域层都可以进行事件发布。为了实现事件订阅的统一管理，建议你将微服务内所有事件订阅的相关代码都统一放到应用层。事件处理相关的核心业务逻辑实现可以放在领域层。通过应用层调用领域层服务，来实现完整的事件订阅处理流程。</li>
<li><code>service（应用服务）</code>：这层的服务是应用服务。应用服务会对多个领域服务或其他微服务的应用服务进行封装、编排和组合，对外提供粗粒度的服务。你可以为每个聚合的应用服务设计一个应用服务类。</li>
<li>另外，在进行跨微服务调用时，部分 DO 对象需要转换成 DTO，所以应用层可能也会有用户接口层的 assembler 和 dto 对象。这时，你可以根据需要增加 assembler 和 dto 代码目录结构。</li>
</ul>
<div class="note-large notel-yellow"><div class="notel-title"><p>注意</p>
</div><div class="notel-content"><p><i class="fa-duotone fa-triangle-exclamation"></i> 对于多表关联的复杂查询，由于这种复杂查询不需要有领域逻辑和业务规则约束，因此不建议将这类复杂查询放在领域层的领域模型中。你可以通过应用层的应用服务采用传统多表关联的SQL查询方式，也可以采用CQRS读写分离的方式完成数据查询操作。</p>
 </div></div>
<h4 id="领域层"><a class="markdownIt-Anchor" href="#领域层"></a> 领域层</h4>
<p><code>domain</code> 下的目录结构是由一个或多个独立的聚合目录构成，每一个聚合是一个独立的业务功能单元，多个聚合共同实现领域模型的核心业务逻辑。</p>
<p>聚合内的代码模型是标准且统一的，它一般包括entity、event、repository和service四个子目录，如图所示。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="ddd-java-ach04.webp"
                      alt="domain" 
                ></p>
<ul>
<li>
<p><code>aggr（聚合）</code>：它是聚合目录的根目录，你可以根据实际项目的聚合名称来命名，比如将聚合命名为“Person”。</p>
<p>聚合内实现高内聚的核心领域逻辑，聚合可以独立拆分为微服务，也可以根据领域模型的演变，在不同的微服务之间进行聚合代码重组。</p>
<p>将聚合所有的代码放在一个目录里的主要目的，不仅是为了业务的高内聚，也是为了未来微服务之间聚合代码重组的便利性。有了清晰的聚合代码边界，你就可以轻松地实现以聚合为单位的微服务拆分和重组。</p>
<p>聚合之间的松耦合设计和清晰的代码边界，在微服务架构演进中具有非常重要的价值。</p>
<p>聚合内可以定义聚合根、实体和值对象以及领域服务等领域对象，一般包括以下目录结构。</p>
</li>
<li>
<p><code>entity（实体）</code>：它存放聚合根、实体和值对象等相关代码。实体类中除了业务属性，还有业务行为，也就是实体类中的方法。如果聚合内部实体或值对象比较多，你还可以再增加一级子目录加以区分。</p>
</li>
<li>
<p><code>event（事件）</code>：它存放事件实体以及与事件活动相关的业务逻辑代码。</p>
</li>
<li>
<p><code>service（领域服务）</code>：它存放领域服务、工厂服务等相关代码。一个领域服务是由多个实体组合出来的一段业务逻辑。你可以将聚合内所有领域服务都放在一个领域服务类中。如果有些领域服务的业务逻辑相对复杂，你也可以将一个领域服务设计为一个领域服务类，避免将所有领域服务代码都放在一个领域服务类中而出现代码臃肿的问题。领域服务可以封装多个实体或方法供上层应用服务调用。</p>
</li>
<li>
<p><code>repository（仓储）</code>：它存放仓储服务相关的代码。仓储模式通常包括仓储接口和仓储实现服务。它们一起完成聚合内DO领域对象的持久化，或基于聚合根ID查询，完成聚合内实体和值对象等DO领域对象的数据初始化。另外，仓储目录还会有持久化对象PO，以及持久化实现逻辑相关代码，如DAO等。在仓储设计时有一个重要原则，就是一个聚合只能有一个仓储。</p>
</li>
</ul>
<h4 id="基础层"><a class="markdownIt-Anchor" href="#基础层"></a> 基础层</h4>
<p><code>infrastructure</code> 的代码目录结构有config和util两个子目录，如图所示。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="ddd-java-ach05.webp"
                      alt="infrastructure" 
                ></p>
<ul>
<li><code>config</code>：主要存放配置相关代码。</li>
<li><code>util</code>：主要存放平台、开发框架、消息、数据库、缓存、文件、总线、网关、第三方类库和通用算法等基础代码。</li>
</ul>
<div class="note-large notel-green"><div class="notel-title"><p>说明</p>
</div><div class="notel-content"><p>可以为不同的资源类别建立不同的子目录。如 Redis、MySQL、MQ 等。</p>
 </div></div>
<h2 id="总结"><a class="markdownIt-Anchor" href="#总结"></a> 总结</h2>
<p>DDD 分层架构是一种以 DDD 为基础的软件架构设计，将系统按照职责进行分层，以实现易于维护、易于测试和易于扩展的特性。其实现需要对领域模型进行设计、编写应用服务、实现基础设施，并采用松散耦合的方式进行分层架构之间的通信。DDD 分层架构是一种优秀的软件架构设计方法，可以帮助开发者更好地处理业务逻辑，提高代码的可维护性和可扩展性。</p>
]]></content>
      <categories>
        <category>DDD</category>
        <category>基础原理</category>
      </categories>
      <tags>
        <tag>DDD</tag>
      </tags>
  </entry>
  <entry>
    <title>架构-概述</title>
    <url>/posts/58fd8c8/</url>
    <content><![CDATA[<blockquote>
<p>本节总结下架构相关的基础知识：概述，特点，目标，本质…</p>
</blockquote>
<h2 id="软件架构简介"><a class="markdownIt-Anchor" href="#软件架构简介"></a> 软件架构简介</h2>
<p>所谓架构，见仁见智，很难有一个明确或标准的定义；但架构并非镜花水月或阳春白雪，有系统的地方就需要架构，大到航空飞机，小到一个电商系统里面的一个功能组件，都需要设计和架构。抽象而言，架构就是对系统中的实体以及实体之间的关系所进行的抽象描述，是对物/信息的功能与形式元素之间的对应情况所做的分配，是对元素之间的关系以及元素同周边环境之间的关系所做的定义。架构能将目标系统按某个原则进行切分，切分的原则，是要便于不同的角色进行并行工作，结构良好的创造活动要优于毫无结构的创造活动。</p>
<p>软件架构的核心价值，即是控制系统的复杂性，将核心业务逻辑和技术细节的分离与解耦。软件架构是系统的草图，它描述的对象是直接构成系统的抽象组件；各个组件之间的连接则明确和相对细致地描述组件之间的通信。在实现阶段，这些抽象组件被细化为实际的组件，比如具体某个类或者对象。在面向对象领域中，组件之间的连接通常用接口来实现。架构师的职责是努力训练自己的思维，用它去理解复杂的系统，通过合理的分解和抽象，理解并解析需求，创建有用的模型，确认、细化并扩展模型，管理架构；能够进行系统分解形成整体架构，能够正确的技术选型，能够制定技术规格说明并有效推动实施落地。</p>
<h2 id="系统复杂性的来源与应对"><a class="markdownIt-Anchor" href="#系统复杂性的来源与应对"></a> 系统复杂性的来源与应对</h2>
<p>在软件开发中，程序员往往能够脱离现实规律的束缚，创造出天马行空的世界，其也是最具有创造力的活动之一。编程唯一需要的是创造力思维和思维组织能力，这意味着在软件开发过程中最大限制是理解我们正在创建的对象。随着软件的演进，加入更多的功能点，系统变得越来越复杂：各个模块（Module）间存在着各种微妙的依赖关系。系统的复杂性随着时间积累，对于程序员来说，修改系统时考虑周全所有的的相关因素变得越来越困难。这就会使软件开放进度变缓慢，并且引入 Bug，而导致会进一步延缓开发进度，增加开发成本。在任何一个系统的生命周期中，复杂性不可避免会增加；系统越大，需要更多的人开发，管理系统复杂性的工作就越困难。</p>
<p>Eric Evans 在 Domain‐Driven Design 一书中吐槽了所谓的意大利面式架构，即代码确实做了有用的事，但很难解释它是如何去执行的；他认为造成这种窘境的主要原因是，将领域问题的复杂度与技术细节的复杂度混合在了一起，最终导致整体复杂度的指数级增长。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://pdai.tech/images/arch/arch-x-overview-1.jpg"
                      alt="img" 
                ></p>
<p>复杂性不是凭空而来，很多时候也不是刻意为之，这也就意味着复杂性的增加往往不会以我们的主观意志为转移。就像房间里的大象，我们无法逃避，也不能视而不见。复杂性的来源可能是：</p>
<ul>
<li>吸积与持续迭代：增量式设计意味着软件设计永不结束，设计在系统的生命周期中持续发生，程序员要时刻考虑设计问题。增量开发也意味着持续重构。一个系统的初始设计几乎从来都不是最好的方案。随着经验的增加，必然会发现更好的设计方案。</li>
<li>交互且无扩展性设计：当吸积效应导致的大规模系统，结合了交互这个特性，会使技术系统更加复杂。一个技术系统除了作用于自身，还会与其它大量系统产生交互。比如下单购买一件商品，那么订单系统，商品系统，支付系统，物流系统，卡券系统就会交互协作。这样吸积的复杂性，由于交互特性的出现，会呈现几何级数上升。</li>
<li>不合理的业务封装：不合理的业务封装是一个相对宽泛的概念，其具体的表现譬如面向过程而不是对象、分层不合理等。</li>
<li>缺乏统一语言：典型的敏捷开发的结构，流水线上的各个角色往往会专注于自己负责的环节，精细化的分工也限制了每个角色的全局视角；虽然我们经常提倡所谓的主人翁意识，但是在落地时又很难去推进。</li>
<li>缺乏约束与规范：在团队协作开发的背景下，缺少规范和约束会严重损害架构的一致性（Consistency），代码的可维护性将急剧下降。可能规范在实现层面就是命名、分包等不影响代码运行的小问题，但是千里之堤，溃于蚁穴，正是这些微末的不注意导致了整体复杂性的雪崩。</li>
</ul>
<p>复杂性的应对永远不会是一劳永逸，我们需要不断地推陈出新，是动态、渐进的重塑自己对软件系统的认识，不断认识问题和寻找更优解的持续迭代。第一个控制复杂性的途径是代码简单，意图清晰（Obvious）。例如: 减少特殊场景的处理，或变量命名一致性都能降低系统复杂性。另一种方式就是对复杂问题的抽象然后分而治之。</p>
<h2 id="大型网站的特点"><a class="markdownIt-Anchor" href="#大型网站的特点"></a> 大型网站的特点</h2>
<ul>
<li>用户多，分布广泛</li>
<li>大流量，高并发</li>
<li>海量数据，服务高可用</li>
<li>安全环境恶劣，易受网络攻击</li>
<li>功能多，变更快，频繁发布</li>
<li>从小到大，渐进发展</li>
<li>以用户为中心</li>
<li>免费服务，付费体验</li>
</ul>
<h2 id="大型网站架构目标"><a class="markdownIt-Anchor" href="#大型网站架构目标"></a> 大型网站架构目标</h2>
<ul>
<li>高性能：提供快速的访问体验。</li>
<li>高可用：网站服务一直可以正常访问。</li>
<li>可伸缩：通过硬件增加/减少，提高/降低处理能力。</li>
<li>安全性：提供网站安全访问和数据加密，安全存储等策略。</li>
<li>扩展性：方便的通过新增/移除方式，增加/减少新的功能/模块。</li>
<li>敏捷性：随需应变，快速响应；</li>
</ul>
]]></content>
      <categories>
        <category>架构</category>
        <category>基础知识</category>
      </categories>
      <tags>
        <tag>架构</tag>
      </tags>
  </entry>
  <entry>
    <title>DDD 重要概念</title>
    <url>/posts/e22804d6/</url>
    <content><![CDATA[<p>DDD（Domain Driven Design）是一种软件开发方法论，旨在将业务领域和实现方式相互融合。其核心思想是将复杂的业务领域划分成多个子域，并围绕这些子域进行系统设计和开发。采用DDD能够让开发者更好地理解业务需求，提高软件系统的可靠性和扩展性。</p>
<h2 id="ddd中的重要概念"><a class="markdownIt-Anchor" href="#ddd中的重要概念"></a> DDD中的重要概念</h2>
<h3 id="领域domain"><a class="markdownIt-Anchor" href="#领域domain"></a> 领域（Domain）</h3>
<p>领域是具有明确边界和稳定概念的业务领域，例如电商、金融、医疗等。领域定义了业务场景、业务流程和业务实体，是整个软件系统的核心。</p>
<h3 id="子域subdomain"><a class="markdownIt-Anchor" href="#子域subdomain"></a> 子域（Subdomain）</h3>
<p>子域是在领域内部更加细分的业务领域，每个子域都负责处理该领域内的特定问题或实体。子域应该遵循单一职责、明确边界和模块化的原则。</p>
<div class="note-large notel-green"><div class="notel-title"><p>举个栗子</p>
</div><div class="notel-content"><p>假设我们正在开发一个电商网站，该网站包括商品管理、订单管理、用户管理等多个功能模块。为了更好地应用DDD，我们可以将系统划分成以下子域：</p>
<ul>
<li>商品管理：负责处理商品的增、删、改、查等业务逻辑。该子域包括商品分类、商品属性、商品SKU等实体。</li>
<li>订单管理：负责处理订单的创建、支付、发货等业务逻辑。该子域包括订单、购物车、支付、配送等实体。</li>
<li>用户管理：负责处理用户的注册、登录、信息修改等业务逻辑。该子域包括用户、会员等实体。</li>
</ul>
<p>每个子域都有自己的职责和边界，相互之间不产生影响。例如，商品管理子域只需要关注商品本身的业务逻辑，不需要了解订单或用户的相关信息。而订单管理子域也只需要关注订单本身的业务逻辑，不需要涉及商品或用户的处理。</p>
<p>通过这种方式，我们可以更好地理解电商网站中各个领域的关系和边界，从而更加有效地进行软件设计和开发。</p>
 </div></div>
<h3 id="通用语言ubiquitous-language"><a class="markdownIt-Anchor" href="#通用语言ubiquitous-language"></a> 通用语言（Ubiquitous Language）</h3>
<p>通用语言是指在整个领域和子域中使用的共同业务语言，它可以避免开发者和业务人员之间产生误解和沟通障碍，使得开发过程更加高效和准确。</p>
<div class="note-large notel-green"><div class="notel-title"><p>举个栗子</p>
</div><div class="notel-content"><p>假设我们正在为一家电商网站设计一个订单系统。 在该系统中，有客户(Customer)、订单(Order)、商品(Product)等实体和相关业务过程。</p>
<p>在这个情景下，我们需要与技术团队以及业务专家讨论各种业务场景并制定正确的设计方案。 在这个过程中，我们需要确保大家都理解这些业务概念的含义，并且使用相同的术语来描述它们。</p>
<p>因此，我们可能会创建一个名为“订单领域”的共享文档，其中包含所有与订单相关的业务概念和术语的列表。 以下是一些例子：</p>
<ul>
<li>客户（Customer）：指购买商品的人或公司。</li>
<li>订单（Order）：表示客户的购买请求。</li>
<li>商品（Product）：指在网站上出售的物品。</li>
<li>收货地址（Shipping Address）：指客户希望将商品送到哪里的地址。</li>
<li>运输方式（Shipping Method）：指用于交付商品的运输方式。</li>
<li>支付方式（Payment Method）：指客户用于支付订单的方式。</li>
</ul>
<p>通过这种方式，我们可以确保所有团队成员对这些业务概念和术语有清晰的理解，并避免任何混淆或误解。这样，我们就可以更有效地协作，并更好地实现电商网站的业务目标。</p>
 </div></div>
<h3 id="界限上下文bounded-context"><a class="markdownIt-Anchor" href="#界限上下文bounded-context"></a> 界限上下文（Bounded Context）</h3>
<p>界限上下文是指一个子域内的一组相关概念和业务逻辑，这些概念和逻辑在该子域内具有特定含义和作用。不同的子域可以有不同的界限上下文，它们之间不会产生冲突。</p>
<div class="note-large notel-green"><div class="notel-title"><p>和子域的联系</p>
</div><div class="notel-content"><p>可以认为，一个子域是属于一个界限上下文的一部分。在界限上下文内，我们需要考虑如何设计实体、聚合、值对象等元素，以便最好地支持该领域的业务需求。而在子域内，则需要更加专注于该子域内部的具体业务问题，例如该子域所涉及的实体和关系，以及如何将这些实体组织成一个完整的、符合业务需求的模型。</p>
<p>简单来说，子域是对一个业务领域进行更精细化划分的方式，而界限上下文则是将整个系统划分为不同的业务领域，并明确各个领域之间的关系的方式。两者之间密切相关，但是重点不同，因此在DDD设计中需要同时考虑两者的作用和关系。</p>
 </div></div>
<h3 id="实体entity"><a class="markdownIt-Anchor" href="#实体entity"></a> 实体（Entity）</h3>
<p>在领域驱动设计（DDD）中，实体是<span style="border-bottom:2px solid green">指具有唯一身份和生命周期的对象</span>。这些对象在业务中扮演着重要的角色，因为它们通常代表着业务中最重要的部分，并且与其他实体之间存在复杂的关系。</p>
<p>在DDD中，实体应该被视为业务的核心，因为它们代表了业务过程中最重要的概念。实体的属性和行为应该反映出业务中的特殊性质，并且在应用程序中应该得到恰当地表示。</p>
<p>与其他的设计模式类似，实体的定义可能会因为应用程序的需要而有所变化。但在大多数情况下，实体都应该具备以下特征：</p>
<ul>
<li><span style="border-bottom:2px solid green">有一个唯一的标识符（ID）或者一个键（Key）。</span></li>
<li><span style="border-bottom:2px solid green">有状态，并且这个状态可以随着时间发生改变。</span></li>
<li><span style="border-bottom:2px solid green">具有相关联的属性和行为，这些属性和行为本身就是业务上的概念，而不是简单的getter/setter方法。</span></li>
</ul>
<p>总之，实体是DDD中非常重要的一个概念，对于理解业务过程和设计合适的应用程序都有着至关重要的作用。</p>
<div class="note-large notel-green"><div class="notel-title"><p>举个栗子</p>
</div><div class="notel-content"><p>假设我们有一个电商平台的应用程序，其中有商品和订单两个概念。在这个应用程序中，商品和订单都可以被视为实体。</p>
<ul>
<li>商品实体：每个商品在电商平台上都应该具备唯一的标识符（ID），例如商品编号、SKU等。商品的状态也可能随着时间而发生变化，例如库存量会因为购买而减少。除此之外，商品还具备相关联的属性和行为，例如名称、价格、描述、图片等属性以及添加到购物车、下单、发货等行为。</li>
<li>订单实体：每个订单在电商平台上也应该具备唯一的标识符（ID），例如订单编号。订单的状态也可能随着时间而发生变化，例如订单状态从待付款变成已付款、待发货、已发货等状态。除此之外，订单还具备相关联的属性和行为，例如购买的商品、总价、收货地址、支付方式等属性以及取消订单、查看物流等行为。</li>
</ul>
<p>通过将商品和订单视为实体，我们可以更好地理解它们在业务过程中的重要性，并且能够更加清晰地设计我们的应用程序。例如，我们可以利用商品和订单的属性和行为来设计合适的数据库模型和API接口，以便于我们对它们进行增删改查和其他操作。同时，通过使用实体，我们也能够更好地理解它们之间的关系，例如订单中包含哪些商品、商品出现在了哪些订单中等等。</p>
<div class="note note-green"><p>Java 伪代码</p>
</div>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 定义商品实体类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Product</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Long id; <span class="comment">// 商品ID</span></span><br><span class="line">    <span class="keyword">private</span> String name; <span class="comment">// 商品名称</span></span><br><span class="line">    <span class="keyword">private</span> BigDecimal price; <span class="comment">// 商品价格</span></span><br><span class="line">    <span class="keyword">private</span> Integer stock; <span class="comment">// 库存数量</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Product</span><span class="params">(Long id, String name, BigDecimal price, Integer stock)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.id = id;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.price = price;</span><br><span class="line">        <span class="built_in">this</span>.stock = stock;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// getter和setter方法</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义订单实体类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Order</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Long id; <span class="comment">// 订单ID</span></span><br><span class="line">    <span class="keyword">private</span> BigDecimal totalAmount; <span class="comment">// 总金额</span></span><br><span class="line">    <span class="keyword">private</span> String address; <span class="comment">// 收货地址</span></span><br><span class="line">    <span class="keyword">private</span> String paymentMethod; <span class="comment">// 支付方式</span></span><br><span class="line">    <span class="keyword">private</span> List&lt;Product&gt; products; <span class="comment">// 购买的商品列表</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Order</span><span class="params">(Long id, BigDecimal totalAmount, String address, String paymentMethod, List&lt;Product&gt; products)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.id = id;</span><br><span class="line">        <span class="built_in">this</span>.totalAmount = totalAmount;</span><br><span class="line">        <span class="built_in">this</span>.address = address;</span><br><span class="line">        <span class="built_in">this</span>.paymentMethod = paymentMethod;</span><br><span class="line">        <span class="built_in">this</span>.products = products;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// getter和setter方法</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用实体进行操作的示例代码</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 创建商品实体对象并初始化</span></span><br><span class="line">        <span class="type">Product</span> <span class="variable">product</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Product</span>(<span class="number">1L</span>, <span class="string">&quot;手机&quot;</span>, <span class="keyword">new</span> <span class="title class_">BigDecimal</span>(<span class="string">&quot;1999.99&quot;</span>), <span class="number">100</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建订单实体对象并初始化</span></span><br><span class="line">        <span class="type">Order</span> <span class="variable">order</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Order</span>(<span class="number">1L</span>, <span class="keyword">new</span> <span class="title class_">BigDecimal</span>(<span class="string">&quot;1999.99&quot;</span>), <span class="string">&quot;杭州市西湖区XXX街道XXX号楼XXX室&quot;</span>, <span class="string">&quot;微信支付&quot;</span>, Arrays.asList(product));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 输出订单中包含哪些商品</span></span><br><span class="line">        System.out.println(<span class="string">&quot;订单中包含的商品：&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (Product p : order.getProducts()) &#123;</span><br><span class="line">            System.out.println(p.getName());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 减少商品库存数量</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">quantity</span> <span class="operator">=</span> <span class="number">1</span>; <span class="comment">// 购买数量为1</span></span><br><span class="line">        product.setStock(product.getStock() - quantity);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 更新订单总金额</span></span><br><span class="line">        order.setTotalAmount(order.getTotalAmount().subtract(product.getPrice())); <span class="comment">// 商品价格为减数</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 输出更新后的订单信息</span></span><br><span class="line">        System.out.println(<span class="string">&quot;更新后的订单信息：&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;订单ID：&quot;</span> + order.getId());</span><br><span class="line">        System.out.println(<span class="string">&quot;总金额：&quot;</span> + order.getTotalAmount());</span><br><span class="line">        System.out.println(<span class="string">&quot;收货地址：&quot;</span> + order.getAddress());</span><br><span class="line">        System.out.println(<span class="string">&quot;支付方式：&quot;</span> + order.getPaymentMethod());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
 </div></div>
<h3 id="值对象value-object"><a class="markdownIt-Anchor" href="#值对象value-object"></a> 值对象（Value Object）</h3>
<p>在DDD中，值对象是<span style="border-bottom: 2px solid green">指没有身份标识的对象，其主要特征是它们的属性（值）定义了它们的身份。每个值对象都具有唯一的特性，并且可以通过它们的属性进行比较和相等性检查。</span></p>
<p>值对象通常用于表示概念上的事物，例如日期、时间、货币金额、颜色、邮政编码等。与实体对象不同，值对象没有单独的生命周期，它们始终依附于另一个实体或聚合根对象。</p>
<p>在DDD中，值对象有以下特点：</p>
<ol>
<li><span style="border-bottom: 2px solid green">无法修改</span>：值对象的属性值是不可变的，因为它们的状态定义了它们的身份。如果更改了任何属性，则将创建一个新的值对象。</li>
<li><span style="border-bottom: 2px solid green">可以共享</span>：由于值对象是不可变的，所以它们可以在多个实体或聚合根对象之间共享。这可以提高系统的性能和可扩展性。</li>
<li><span style="border-bottom: 2px solid green">不具有全局唯一标识符</span>：与实体对象不同，值对象没有单独的标识符，因为它们的身份由它们的属性定义。</li>
<li><span style="border-bottom: 2px solid green">可以嵌入到实体对象或其他聚合根对象中</span>：值对象通常被嵌入到实体对象或其他聚合根对象中作为属性，从而形成复杂的对象关系。</li>
</ol>
<p>总的来说，值对象是一个非常有用的DDD概念，它在建模复杂领域模型时可以帮助实现更好的可维护性、可测试性和可扩展性。</p>
<div class="note-large notel-green"><div class="notel-title"><p>举个栗子</p>
</div><div class="notel-content"><ol>
<li>日期/时间对象：日期和时间通常被建模成值对象，因为它们的身份由它们的属性（年、月、日、小时、分钟等）定义。例如，Java中的LocalDate和LocalTime类都是值对象。</li>
</ol>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">LocalDate</span> <span class="variable">date</span> <span class="operator">=</span> LocalDate.of(<span class="number">2022</span>, <span class="number">8</span>, <span class="number">1</span>);</span><br><span class="line"><span class="type">LocalTime</span> <span class="variable">time</span> <span class="operator">=</span> LocalTime.of(<span class="number">12</span>, <span class="number">30</span>);</span><br></pre></td></tr></table></figure></div>
<ol start="2">
<li>颜色对象：颜色也可以被建模成值对象，因为它们的身份由它们的属性（红、绿、蓝分量等）定义。例如，在CSS中，颜色可以用RGB值表示：</li>
</ol>
<div class="highlight-container" data-rel="Css"><figure class="iseeu highlight css"><table><tr><td class="code"><pre><span class="line"><span class="attribute">color</span>: <span class="built_in">rgb</span>(<span class="number">255</span>, <span class="number">0</span>, <span class="number">0</span>); <span class="comment">/* 红色 */</span></span><br></pre></td></tr></table></figure></div>
<ol start="3">
<li>地址对象：地址通常被建模成值对象，因为它们的身份由它们的属性（街道、城市、州、邮政编码等）定义。例如，在Java中，可以创建一个Address值对象：</li>
</ol>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Address</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String street;</span><br><span class="line">    <span class="keyword">private</span> String city;</span><br><span class="line">    <span class="keyword">private</span> String state;</span><br><span class="line">    <span class="keyword">private</span> String zipCode;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 构造函数、访问器等省略</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<ol>
<li>货币金额对象：货币金额也可以被建模成值对象，因为它们的身份由它们的数值和货币类型定义。例如，在Java中，可以创建一个Money值对象：</li>
</ol>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Money</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> BigDecimal amount;</span><br><span class="line">    <span class="keyword">private</span> Currency currency;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 构造函数、访问器等省略</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>这些值对象都有一个共同的特点，即它们没有单独的身份标识符，而是通过它们的属性来定义它们的身份。可以在实体对象或聚合根对象中使用这些值对象作为属性，从而形成复杂的对象关系。</p>
 </div></div>
<h3 id="聚合aggregate"><a class="markdownIt-Anchor" href="#聚合aggregate"></a> 聚合（Aggregate）</h3>
<p>聚合是一组相关实体和值对象的集合，它们共同构成一个有意义的整体。聚合定义了实体之间的关系和交互，同时也限制了对实体的访问方式。它旨在使设计更加灵活和可扩展，同时确保数据完整性。</p>
<p>聚合通常由一个根实体和其他实体组成。根实体是聚合的核心，它承担了维护聚合内一致性的责任。其他实体则依赖于根实体，不能独立存在。</p>
<p>聚合的重要特征是边界。聚合定义了一些规则和约束，用于限制实体之间的交互和访问。这有助于减少复杂性，并确保系统的行为符合预期。聚合还可以帮助明确业务规则和业务过程，促进团队理解和协作。</p>
<div class="note-large notel-green"><div class="notel-title"><p>举个栗子</p>
</div><div class="notel-content"><div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Order</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> orderId;</span><br><span class="line">    <span class="keyword">private</span> Customer customer;</span><br><span class="line">    <span class="keyword">private</span> List&lt;Product&gt; products;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 构造函数等定义</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 聚合规则方法，确保订单只能对应一个客户</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setCustomer</span><span class="params">(Customer customer)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.customer != <span class="literal">null</span> &amp;&amp; !<span class="built_in">this</span>.customer.equals(customer)) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;Order cannot belong to multiple customers.&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">this</span>.customer = customer;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 聚合规则方法，确保订单只包含特定类型的产品</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addProduct</span><span class="params">(Product product)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (!product.getType().equals(ProductType.BOOK)) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;Only books can be added to an order.&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">this</span>.products.add(product);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 聚合规则方法，确保每个产品都有有效的库存</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">checkInventory</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (Product product : <span class="built_in">this</span>.products) &#123;</span><br><span class="line">            <span class="keyword">if</span> (product.getStock() &lt; <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>在上述的示例中，我们定义了一个名为 <code>Order</code> 的聚合类。它由订单和产品实体组成，其中订单实体是根实体，而产品实体是子实体。</p>
<p>在 <code>Order</code> 类中，我们还定义了多个聚合规则方法。例如，<code>setCustomer</code> 方法确保每个订单只能对应一个客户；<code>addProduct</code> 方法确保每个订单只能包含特定类型的产品，比如书；<code>checkInventory</code> 方法确保每个产品都有有效的库存。</p>
<p>通过使用聚合模式，我们可以将逻辑上相关的实体组织到一个单独的单元中，并定义了一些规则和约束，以确保数据完整性和业务一致性。这有助于提高代码的可维护性和可扩展性，同时还可以避免复杂性和混乱。</p>
 </div></div>
<h3 id="聚合根aggregate-root"><a class="markdownIt-Anchor" href="#聚合根aggregate-root"></a> 聚合根（Aggregate Root）</h3>
<p>在领域驱动设计（DDD）中，聚合根（Aggregate Root）是<span style="border-bottom: 2px solid green">指一个聚合内的根实体，它是整个聚合的入口和出口。</span>聚合指一组具有内在联系、共同变化的关联对象的集合。在设计中，聚合根是不可分割的整体，其负责保证聚合内的一致性和完整性。</p>
<p>在 DDD 中，每个聚合都必须拥有一个唯一标识符，而聚合根是该聚合的唯一公开接口。这意味着所有对聚合内对象的访问必须通过聚合根来进行，聚合内的其他对象不应该暴露给外部。聚合根还应该封装聚合内的业务规则，确保聚合内的对象不会被直接修改或删除，只能通过聚合根提供的方法来进行操作。</p>
<p>一个好的聚合根设计可以带来多方面的好处。首先，它能够简化系统架构和设计，降低复杂度，使得代码更易于维护和扩展。其次，通过聚合根的封装，我们可以很好地控制聚合内对象的生命周期和状态，在保证数据一致性的前提下提高了并发处理的效率。最后，聚合根还可以帮助我们更好地理解和定义业务概念，提高系统的可理解性和可维护性。</p>
<div class="note-large notel-green"><div class="notel-title"><p>举个栗子</p>
</div><div class="notel-content"><div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Order</span> <span class="keyword">implements</span> <span class="title class_">Serializable</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Long id;</span><br><span class="line">    <span class="keyword">private</span> List&lt;OrderItem&gt; items;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 构造函数，必须传入 ID，并且初始化 items 列表</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Order</span><span class="params">(Long id)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.id = id;</span><br><span class="line">        <span class="built_in">this</span>.items = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 添加订单项</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addItem</span><span class="params">(OrderItem item)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.items.add(item);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取订单总价</span></span><br><span class="line">    <span class="keyword">public</span> BigDecimal <span class="title function_">getTotalPrice</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">BigDecimal</span> <span class="variable">totalPrice</span> <span class="operator">=</span> BigDecimal.ZERO;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (OrderItem item : <span class="built_in">this</span>.items) &#123;</span><br><span class="line">            totalPrice = totalPrice.add(item.getPrice());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> totalPrice;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取订单中指定商品的数量</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getItemQuantity</span><span class="params">(String productId)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">quantity</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (OrderItem item : <span class="built_in">this</span>.items) &#123;</span><br><span class="line">            <span class="keyword">if</span> (item.getProductId().equals(productId)) &#123;</span><br><span class="line">                quantity += item.getQuantity();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> quantity;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 修改订单中指定商品的数量</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setItemQuantity</span><span class="params">(String productId, <span class="type">int</span> quantity)</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (OrderItem item : <span class="built_in">this</span>.items) &#123;</span><br><span class="line">            <span class="keyword">if</span> (item.getProductId().equals(productId)) &#123;</span><br><span class="line">                item.setQuantity(quantity);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></div>
<p>在这个例子中，<code>Order</code> 是一个聚合根，表示一个订单。它包含了多个 <code>OrderItem</code> 对象，表示订单中的每一项商品。<code>Order</code> 类提供了添加、获取、修改订单项的方法，以及获取订单总价的方法。注意到这里的 <code>Order</code> 类<span style="border-bottom: 2px solid green">不仅封装了聚合内的实体对象，还包含了这些对象之间的业务规则，确保了聚合的一致性和完整性。</span></p>
 </div></div>
<h3 id="领域事件domain-event"><a class="markdownIt-Anchor" href="#领域事件domain-event"></a> 领域事件（Domain Event）</h3>
<p>领域事件（Domain Events）是<span style="border-bottom: 2px solid green">对领域中发生的某些状态变化进行的记录，它们通常会被发送到其他子域或模块中。领域事件可以帮助我们更好地处理系统中复杂的业务逻辑和数据流转。</span></p>
<p>领域事件通常表示一个关键的业务场景，它能够跨越多个领域实体和聚合根（Aggregate Root），并且可以被其他领域对象所使用。通过捕获领域事件，可以帮助我们更好地理解业务流程和规则，并为系统的开发提供指导方向。</p>
<p>在DDD中，领域事件需要满足以下几个特点：</p>
<ul>
<li>事件必须是业务领域内的概念，而不仅仅是技术上的东西；</li>
<li>事件必须是离散化的、可观察的、可重现的；</li>
<li>事件必须是幂等的，即同样的事件只会被处理一次；</li>
<li>事件应该被保存下来以备日后使用或回溯。</li>
</ul>
<div class="note-large notel-green"><div class="notel-title"><p>举个栗子</p>
</div><div class="notel-content"><div class="note-large notel-green"><div class="notel-title"><p>领域事件的实现方式</p>
</div><div class="notel-content"><p>单体应用内可以使用 Spring 事件机制、或者使用第三方的事件驱动类、或者自己实现一个事件总线…</p>
<p>在分布的系统中可以使用 MQ、Redis等作为事件的实现方式，完成领域事件的发布和监听</p>
 </div></div>
<div class="note note-green"><p>我这里写个简单的栗子，就使用 Spring 事件机制实现领域事件：</p>
</div>
<ol>
<li>
<p>定义领域事件</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OrderCreatedEvent</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String orderId;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">OrderCreatedEvent</span><span class="params">(String orderId)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.orderId = orderId;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getOrderId</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> orderId;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
</li>
<li>
<p>发布领域事件</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OrderService</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> ApplicationEventPublisher eventPublisher; <span class="comment">// Spring事件发布器</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">createOrder</span><span class="params">(Order order)</span> &#123;</span><br><span class="line">        <span class="comment">// <span class="doctag">TODO:</span> 创建订单逻辑</span></span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 发布领域事件</span></span><br><span class="line">        eventPublisher.publishEvent(<span class="keyword">new</span> <span class="title class_">OrderCreatedEvent</span>(order.getId()));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
</li>
<li>
<p>监听领域事件</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OrderEventListener</span> &#123;</span><br><span class="line">    <span class="meta">@EventListener</span> <span class="comment">// 声明为事件监听器</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">handleOrderCreatedEvent</span><span class="params">(OrderCreatedEvent event)</span> &#123;</span><br><span class="line">        <span class="comment">// <span class="doctag">TODO:</span> 处理订单创建事件</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">orderId</span> <span class="operator">=</span> event.getOrderId();</span><br><span class="line">        System.out.println(<span class="string">&quot;Order &quot;</span> + orderId + <span class="string">&quot; created successfully.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
</li>
</ol>
<p>这里的<code>@EventListener</code>注解表示这是一个Spring事件监听器，它会自动订阅事件并在事件触发时执行<code>handleOrderCreatedEvent</code>方法。</p>
<p>通过以上步骤，我们就成功地使用Spring事件机制实现了领域事件的发布和监听。</p> </div></div>
<h2 id="ddd的优势"><a class="markdownIt-Anchor" href="#ddd的优势"></a> DDD的优势</h2>
<div class="note note-green"><p>采用DDD的软件开发方法可以带来以下优势：</p>
</div>
<h3 id="更好地理解业务需求"><a class="markdownIt-Anchor" href="#更好地理解业务需求"></a> 更好地理解业务需求</h3>
<p>使用DDD能够让开发者更深入地了解业务需求，从而更好地进行系统设计和开发。通过对领域和子域的划分，我们可以更清晰地描述业务场景、业务流程和业务实体，从而减少开发中的误解和风险。</p>
<h3 id="更高的可靠性和扩展性"><a class="markdownIt-Anchor" href="#更高的可靠性和扩展性"></a> 更高的可靠性和扩展性</h3>
<p>在DDD中，每个子域都有自己的边界和职责，相互独立且松散耦合。这种设计方式使得系统更容易维护和扩展，不会因为一个子域的变化而影响其他子域的稳定性。同时，通过领域事件的引入，我们可以更好地处理系统中复杂的业务逻辑，提高系统的可靠性和健壮性。</p>
<h3 id="更高的代码质量和可读性"><a class="markdownIt-Anchor" href="#更高的代码质量和可读性"></a> 更高的代码质量和可读性</h3>
<p>在DDD中，我们通常采用面向对象的编程思想，将领域模型映射到代码中。这种方式可以更好地表达业务语言和业务逻辑，使得代码更加贴近业务需求。同时，通过采用DDD中的聚合根、值对象等概念，我们可以更好地组织代码结构，使得代码更加清晰和易于理解。</p>
<h2 id="总结"><a class="markdownIt-Anchor" href="#总结"></a> 总结</h2>
<p>DDD是一种非常实用的软件开发方法，可以帮助我们更好地理解业务需求、提高系统的可靠性和扩展性，同时也能够提高代码质量和可读性。在应用DDD时，我们需要深入了解业务领域、精确划分子域、采用合适的设计模式和编程思想，并不断优化和迭代。相信通过使用DDD，我们可以更好地完成软件开发项目，提供更优秀的用户体验和商业价值。</p>
]]></content>
      <categories>
        <category>DDD</category>
        <category>基础原理</category>
      </categories>
      <tags>
        <tag>DDD</tag>
      </tags>
  </entry>
  <entry>
    <title>架构-架构演进</title>
    <url>/posts/90f7cfbe/</url>
    <content><![CDATA[<blockquote>
<p>在学习架构时，<strong>第一步不要去学习框架，而是要学习架构的演进</strong>。强烈推荐李智慧老师的《大型网站技术架构》，这本书翻起来很快，对构筑你自己的体系很有帮助，本文的内容来源于它，在此基础上拓展了下。</p>
</blockquote>
<h2 id="架构演进"><a class="markdownIt-Anchor" href="#架构演进"></a> 架构演进</h2>
<p>大型网站的技术挑战主要来自于庞大的用户，高并发的访问和海量的数据，任何简单的业务一旦需要处理数以P计的数据和面对数以亿计的用户，问题就会变得很棘手。大型网站架构主要就是解决这类问题。</p>
<p>架构选型是根据当前业务需要来的，在满足业务需求的前提下，既要有足够的扩展性也不能过度设计，每次的架构升级都是为了解决系统瓶颈而做的。</p>
<h3 id="初始阶段的网站架构"><a class="markdownIt-Anchor" href="#初始阶段的网站架构"></a> 初始阶段的网站架构</h3>
<p>初始阶段都比较简单，通常一台服务器就可以搞定一个网站了，看图。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://pdai.tech/images/arch/arch-x-ev-g-1.png"
                      alt="img" 
                ></p>
<h3 id="应用服务和数据服务分离"><a class="markdownIt-Anchor" href="#应用服务和数据服务分离"></a> 应用服务和数据服务分离</h3>
<p>随着网站业务的发展，一台服务器逐渐不能满足需求；这时候就需要将应用和数据分离，如图。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://pdai.tech/images/arch/arch-x-ev-g-2.png"
                      alt="img" 
                ></p>
<h3 id="使用缓存改善网站性能"><a class="markdownIt-Anchor" href="#使用缓存改善网站性能"></a> 使用缓存改善网站性能</h3>
<p>毫无疑问，现在的网站基本上都会使用缓存，即：80%的业务访问都会集中在20%的数据上。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://pdai.tech/images/arch/arch-x-ev-g-3.png"
                      alt="img" 
                ></p>
<h3 id="使用应用服务器集群改善网站的并发处理能力"><a class="markdownIt-Anchor" href="#使用应用服务器集群改善网站的并发处理能力"></a> 使用应用服务器集群改善网站的并发处理能力</h3>
<p>因为单一应用服务器能够处理的请求连接有限，在网站访问高峰时期，应用服务器会成为整个网站的瓶颈。因此使用负载均衡处理器势在必然。通过负载均衡调度服务器，可将来自浏览器的访问请求分发到应用的集群中的任何一台服务器上。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://pdai.tech/images/arch/arch-x-ev-g-4.png"
                      alt="img" 
                ></p>
<h3 id="数据库读写分离"><a class="markdownIt-Anchor" href="#数据库读写分离"></a> 数据库读写分离</h3>
<p>当用户达到一定规模后，数据库因为负载压力过高而成为网站的瓶颈。而目前主流的数据库都提供主从热备功能，通过配置两台数据库主从关系，可以将一台数据库的数据更新同步到另一台服务器上。网站利用数据库这一功能实现数据库读写分离，从而改善数据库负载压力。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://pdai.tech/images/arch/arch-x-ev-g-5.png"
                      alt="img" 
                ></p>
<h3 id="使用反向代理和cdn加上网站相应"><a class="markdownIt-Anchor" href="#使用反向代理和cdn加上网站相应"></a> 使用反向代理和CDN加上网站相应</h3>
<p>提高网站的访问速度，主要手段有使用CDN和反向代理。</p>
<p>CDN和反向代理的基本原理都是缓存，区别在于CDN部署在网络提供商的机房，而反向代理是部署在网站的中心机房，当用户请求到达中心机房后，首先访问的反向代理，如果反向代理缓存着用户请求的资源，则直接返回给用户。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://pdai.tech/images/arch/arch-x-ev-g-6.png"
                      alt="img" 
                ></p>
<h3 id="使用分布式文件系统和分布式数据库系统"><a class="markdownIt-Anchor" href="#使用分布式文件系统和分布式数据库系统"></a> 使用分布式文件系统和分布式数据库系统</h3>
<p>任何强大的单一服务器都满足不了大型网站持续增长的业务需求。</p>
<p>分布式数据库时网站数据库拆分的最后手段，只用在单表数据规模非常大的时候才使用。不到不得已时，网站更常用的数据库拆分手段是业务拆分，将不同业务的数据部署在不同的物理服务器上。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://pdai.tech/images/arch/arch-x-ev-g-7.png"
                      alt="img" 
                ></p>
<h3 id="使用nosql和搜索引擎"><a class="markdownIt-Anchor" href="#使用nosql和搜索引擎"></a> 使用NoSQL和搜索引擎</h3>
<p>搜索引擎也基本已经形成现在大型网站必须提供的功能了，网站需要采用一些非关系数据库技术如NoSQL和非数据库查询技术如搜索引擎。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://pdai.tech/images/arch/arch-x-ev-g-8.png"
                      alt="img" 
                ></p>
<h3 id="业务拆分"><a class="markdownIt-Anchor" href="#业务拆分"></a> 业务拆分</h3>
<p>大型网站为了应对日益复杂的业务场景，通过使用分而治之的手段将真个网站业务拆分成不同的产品线。</p>
<p>具体到技术上，也会根据产品线话费，将一个网站拆分成许多不同的应用，每个应用独立部署维护。应用之间可以通过超链接建立管理，也可以通过消息队列进行数据分发，当然最多的还是通过访问同一个数据存储系统来构成一个关联的完整系统。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://pdai.tech/images/arch/arch-x-ev-g-9.png"
                      alt="img" 
                ></p>
<h3 id="分布式服务"><a class="markdownIt-Anchor" href="#分布式服务"></a> 分布式服务</h3>
<p>由于每一个应用系统都需要执行许多相同的业务操作，比如用户管理，session管理，那么可以将这些公用的业务提取出来，独立部署。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://pdai.tech/images/arch/arch-x-ev-g-10.png"
                      alt="img" 
                ></p>
<h2 id="示例电商系统架构演进"><a class="markdownIt-Anchor" href="#示例电商系统架构演进"></a> 示例:电商系统架构演进</h2>
<p>具体以电子商务网站为例， 展示web应用的架构演变过程。</p>
<h3 id="10时代"><a class="markdownIt-Anchor" href="#10时代"></a> 1.0时代</h3>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://pdai.tech/images/arch/arch-x-ev-d-1.png"
                      alt="img" 
                ></p>
<p>这个时候是一个web项目里包含了所有的模块，一个数据库里包含了所需要的所有表，这时候网站访问量增加时，首先遇到瓶颈的是应用服务器连接数，比如tomcat连接数不能无限增加，线程数上限受进程内存大小、CPU内核数等因素影响，当线程数到达一定数时候，线程上下文的切换对性能的损耗会越来越严重，响应会变慢，通过增加web应用服务器方式的横向扩展对架构影响最小，这时候架构会变成下面这样：</p>
<h3 id="20时代"><a class="markdownIt-Anchor" href="#20时代"></a> 2.0时代</h3>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://pdai.tech/images/arch/arch-x-ev-d-2.png"
                      alt="img" 
                ></p>
<p>这时候随着网站访问量继续增加，继续增加应用服务器数量后发现数据库成了瓶颈，而数据库的最主要的瓶颈体现在两方面：</p>
<ul>
<li>数据库的最大连接数是有限的，比如当前数据库的连接数设置8000，如果每个应用服务器与数据库的初始连接数设置40，那么200台web服务器是极限， 并且连接数太多后，数据库的读写压力增大，耗时增加</li>
<li>当单表数量过大时，对该表的操作耗时会增加，索引优化也是缓兵之计</li>
</ul>
<p>这时，根据业务特点，如果读写比差距不大，并且对数据一致性要求不是很高的情况下，数据库可以采用主从方式进行读写分离的方案，并且引入缓存机制来抗读流量。如果读写比差距很大或者对数据一致性要求高时，就不适合用读写分离方案，需要考虑业务的垂直拆分，这时期的系统架构图如下：</p>
<h3 id="30时代"><a class="markdownIt-Anchor" href="#30时代"></a> 3.0时代</h3>
<h4 id="31-读写分离"><a class="markdownIt-Anchor" href="#31-读写分离"></a> 3.1 读写分离</h4>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://pdai.tech/images/arch/arch-x-ev-d-3.png"
                      alt="img" 
                ></p>
<p>这时候仍然是垂直架构，所有业务集中在一个项目里。项目维护、快速迭代问题会越来越严重，单个模块的开发都需要发布整个项目，项目稳定性也受到很大挑战，这是需要考虑业务的垂直拆分，需要将一些大的模块单独拆出来，这时候的架构图如下：</p>
<h3 id="40-业务垂直拆分"><a class="markdownIt-Anchor" href="#40-业务垂直拆分"></a> 4.0 业务垂直拆分</h3>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://pdai.tech/images/arch/arch-x-ev-d-4.png"
                      alt="img" 
                ></p>
<p>这时候为了进一步提升用户体验，加速用户的网站访问速度，会使用CDN来缓存信息，用户会访问最近的CDN节点来提升访问速度。此时的架构图如下：</p>
<h4 id="41-使用cdn来缓存信息"><a class="markdownIt-Anchor" href="#41-使用cdn来缓存信息"></a> 4.1 使用CDN来缓存信息</h4>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://pdai.tech/images/arch/arch-x-ev-d-5.png"
                      alt="img" 
                ></p>
<p>随着业务量增大，一些核心系统数据库单表数量达到几千万甚至亿级，这时候对该表的数据操作效率会大大降低，并且虽然有缓存来抗读的压力，但是对于大量的写操作和一些缓存miss的流量到达一定量时，单库的负荷也会到达极限，这时候需要将表拆分，一般直接采用分库分表，因为只做分表的话，单个库的连接瓶颈仍然无法解决。分库分表后的架构如下：</p>
<h4 id="42分库分表架构"><a class="markdownIt-Anchor" href="#42分库分表架构"></a> 4.2分库分表架构</h4>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://pdai.tech/images/arch/arch-x-ev-d-6.png"
                      alt="img" 
                ></p>
<p>随着流量的进一步增大，这时候系统仍然会有瓶颈出现，以订单系统为例： 单个机房的机器是有限的，不能一直新增下去，并且基于容灾的考虑，一般采用同城双机房的方式，机房之间用专线链接，同城跨机房质检的延时在几毫秒，此时的架构图如下：</p>
<h4 id="43-同城双机房"><a class="markdownIt-Anchor" href="#43-同城双机房"></a> 4.3 同城双机房</h4>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://pdai.tech/images/arch/arch-x-ev-d-7.png"
                      alt="img" 
                ></p>
<p>由于数据库主库只能是在一个机房，所以仍然会有一半的数据库访问是跨机房的，虽然延时只有几毫秒，但是一个调用链里的数据库访问太多后，这个延时也会积少成多。其次这个架构还是没能解决数据库连接数瓶颈问题</p>
<ul>
<li>随着应用服务器的增加，虽然是分库分表，但每增加一台应用服务器，都会与每个分库建立连接，比如数据库连接池默认连接数是40，而如果mysql数据库的最大连接数是8000的话，那么200台应用服务器就是极限。</li>
<li>当应用的量级太大后，单个城市的机器、电、带宽等资源无法满足业务的持续增长。这时就需要考虑SET化架构，也就是单元化架构，大体思路就是将一些核心系统拆成多个中心，每个中心成为一个单元，流量会按照一定的规则分配给每个单元，这样每个单元只负责处理自己的流量就可以了。每个单元要尽量自包含、高内聚。这是从整体层面将流量分而治之的思路。这是单元化后的机构简图如下：</li>
</ul>
<h3 id="50-单元化"><a class="markdownIt-Anchor" href="#50-单元化"></a> 5.0 单元化</h3>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://pdai.tech/images/arch/arch-x-ev-d-8.png"
                      alt="img" 
                ></p>
<p>从上面的架构图里能看到，流量从接入层按照路由规则（比如以用户ID来路由）路由到不同单元，每个单元内都是高内聚，包含了核心系统，数据层面的分片逻辑是与接入层路有逻辑一致，也解决了数据库连接的瓶颈问题，但是一些跨单元的调用是无法避免的，同时也有些无法拆分的业务需要放在中心单元，供所有其他单元调用。</p>
]]></content>
      <categories>
        <category>架构</category>
        <category>基础知识</category>
      </categories>
      <tags>
        <tag>架构</tag>
      </tags>
  </entry>
  <entry>
    <title>分布式系统</title>
    <url>/posts/b2db68a7/</url>
    <content><![CDATA[<blockquote>
<p>一个分布式系统是一些独立的计算机集合，但是对这个系统的用户来说，系统就像一台计算机一样。本文主要介绍分布式的基础知识.</p>
</blockquote>
<h2 id="什么是分布式系统"><a class="markdownIt-Anchor" href="#什么是分布式系统"></a> 什么是分布式系统</h2>
<blockquote>
<p>一个分布式系统是一些独立的计算机集合，但是对这个系统的用户来说，系统就像一台计算机一样。</p>
</blockquote>
<p>分布式系统是一个硬件或软件组件分布在不同的网络计算机上，彼此之间仅仅通过消息传递进行通信和协调的系统。简单来说就是<span style="border-bottom: 2px solid green"><strong>一群独立计算机集合共同对外提供服务，但是对于系统的用户来说，就像是一台计算机在提供服务一样</strong>。</span>分布式意味着可以采用更多的普通计算机（相对于昂贵的大型机）组成分布式集群对外提供服务。计算机越多，CPU、内存、存储资源等也就越多，能够处理的并发访问量也就越大。</p>
<p>从分布式系统的概念中我们知道，各个主机之间通信和协调主要通过网络进行，所以分布式系统中的计算机在空间上几乎没有任何限制，这些计算机可能被放在不同的机柜上，也可能被部署在不同的机房中，还可能在不同的城市中，对于大型的网站甚至可能分布在不同的国家和地区。</p>
<h3 id="分布式系统的主要特征"><a class="markdownIt-Anchor" href="#分布式系统的主要特征"></a> 分布式系统的主要特征</h3>
<blockquote>
<p>无论空间上如何分布，一个标准的分布式系统应该具有以下几个主要特征</p>
</blockquote>
<ul>
<li><strong>分布性</strong></li>
</ul>
<p>分布式系统中的多台计算机之间在空间位置上可以随意分布，同时，机器的分布情况也会随时变动。</p>
<ul>
<li><strong>对等性</strong></li>
</ul>
<p>分布式系统中的计算机没有主／从之分，即没有控制整个系统的主机，也没有被控制的从机，组成分布式系统的所有计算机节点都是对等的。副本（Replica）是分布式系统最常见的概念之一，指的是分布式系统对数据和服务提供的一种冗余方式。在常见的分布式系统中，为了对外提供高可用的服务，我们往往会对数据和服务进行副本处理。数据副本是指在不同节点上持久化同一份数据，当某一个节点上存储的数据丢失时，可以从副本上读取该数据，这是解决分布式系统数据丢失问题最为有效的手段。另一类副本是服务副本，指多个节点提供同样的服务，每个节点都有能力接收来自外部的请求并进行相应的处理。</p>
<ul>
<li><strong>自治性</strong></li>
</ul>
<p>分布式系统中的各个节点都包含自己的处理机和内存，各自具有独立的处理数据的功能。通常，彼此在地位上是平等的，无主次之分，既能自治地进行工作，又能利用共享的通信线路来传送信息，协调任务处理。</p>
<ul>
<li><strong>并发性</strong></li>
</ul>
<p>在一个计算机网络中，程序运行过程的并发性操作是非常常见的行为。例如同一个分布式系统中的多个节点，可能会并发地操作一些共享的资源，如何准确并高效地协调分布式并发操作也成为了分布式系统架构与设计中最大的挑战之一。</p>
<h3 id="分布式系统面临的问题"><a class="markdownIt-Anchor" href="#分布式系统面临的问题"></a> 分布式系统面临的问题</h3>
<blockquote>
<p>分布式系统面临的问题有哪些？</p>
</blockquote>
<ul>
<li><strong>缺乏全局时钟</strong></li>
</ul>
<p>在分布式系统中，很难定义两个事件究竟谁先谁后，原因就是因为分布式系统缺乏一个全局的时钟序列控制。</p>
<ul>
<li><strong>机器宕机</strong></li>
</ul>
<p>机器宕机是最常见的异常之一。在大型集群中每日宕机发生的概率为千分之一左右，在实践中，一台宕机的机器恢复的时间通常认为是24 小时，一般需要人工介入重启机器。</p>
<ul>
<li><strong>网络异常</strong></li>
</ul>
<p>消息丢失，两片节点之间彼此完全无法通信，即出现了“网络分化”；消息乱序，有一定的概率不是按照发送时的顺序依次到达目的节点，考虑使用序列号等机制处理网络消息的乱序问题，使得无效的、过期的网络消息不影响系统的正确性；数据错误；不可靠的TCP，TCP 协议为应用层提供了可靠的、面向连接的传输服务，但在分布式系统的协议设计中不能认为所有网络通信都基于TCP 协议则通信就是可靠的。TCP协议只能保证同一个TCP 链接内的网络消息不乱序，TCP 链接之间的网络消息顺序则无法保证。</p>
<ul>
<li><strong>分布式三态</strong></li>
</ul>
<p>如果某个节点向另一个节点发起RPC(Remote procedure call)调用，即某个节点A 向另一个节点B 发送一个消息，节点B 根据收到的消息内容完成某些操作，并将操作的结果通过另一个消息返回给节点A，那么这个RPC 执行的结果有三种状态：“成功”、“失败”、“超时（未知）”，称之为分布式系统的三态。</p>
<ul>
<li><strong>存储数据丢失</strong></li>
</ul>
<p>对于有状态节点来说，数据丢失意味着状态丢失，通常只能从其他节点读取、恢复存储的状态。 <em>异常处理原则</em>：被大量工程实践所检验过的异常处理黄金原则是：任何在设计阶段考虑到的异常情况一定会在系统实际运行中发生，但在系统实际运行遇到的异常却很有可能在设计时未能考虑，所以，除非需求指标允许，在系统设计时不能放过任何异常情况。</p>
<h3 id="衡量分布式系统的指标"><a class="markdownIt-Anchor" href="#衡量分布式系统的指标"></a> 衡量分布式系统的指标</h3>
<blockquote>
<p>衡量分布式系统的指标有哪些？</p>
</blockquote>
<ul>
<li><strong>性能</strong></li>
</ul>
<p>系统的吞吐能力，指系统在某一时间可以处理的数据总量，通常可以用系统每秒处理的总的数据量来衡量；系统的响应延迟，指系统完成某一功能需要使用的时间；系统的并发能力，指系统可以同时完成某一功能的能力，通常也用QPS(query per second)来衡量。上述三个性能指标往往会相互制约，追求高吞吐的系统，往往很难做到低延迟；系统平均响应时间较长时，也很难提高QPS。</p>
<ul>
<li><strong>可用性</strong></li>
</ul>
<p>系统的可用性(availability)指系统在面对各种异常时可以正确提供服务的能力。系统的可用性可以用系统停服务的时间与正常服务的时间的比例来衡量，也可以用某功能的失败次数与成功次数的比例来衡量。可用性是分布式的重要指标，衡量了系统的鲁棒性，是系统容错能力的体现。</p>
<ul>
<li><strong>可扩展性</strong></li>
</ul>
<p>系统的可扩展性(scalability)指分布式系统通过扩展集群机器规模提高系统性能（吞吐、延迟、并发）、存储容量、计算能力的特性。好的分布式系统总在追求“线性扩展性”，也就是使得系统的某一指标可以随着集群中的机器数量线性增长。</p>
<ul>
<li><strong>一致性</strong></li>
</ul>
<p>分布式系统为了提高可用性，总是不可避免的使用副本的机制，从而引发副本一致性的问题。越是强的一致的性模型，对于用户使用来说使用起来越简单。</p>
]]></content>
      <categories>
        <category>分布式</category>
        <category>基础理论</category>
      </categories>
      <tags>
        <tag>分布式基础理论</tag>
      </tags>
  </entry>
  <entry>
    <title>架构-核心要素</title>
    <url>/posts/13eac1b8/</url>
    <content><![CDATA[<blockquote>
<p>所谓架构，一种通俗的说法就是“最高层次的规划，难以改变的决定”，这些规划和决定奠定了事物未来发展的方向和最终的蓝图。而软件架构即“有关软件整体结构与组件的抽象描述，用于指导大型软件系统各方面的设计”。一般来说软件架构需要关注性能、可用性、伸缩性、扩展性和安全性这5个架构要素。</p>
</blockquote>
<h3 id="性能"><a class="markdownIt-Anchor" href="#性能"></a> 性能</h3>
<p>性能是网站架构设计的一个重要方面，任何软件架构设计方案都必须考虑可能带来的性能问题。也正因为性能问题几乎无处不在，所以优化网站性能的手段也非常多：</p>
<ul>
<li><code>浏览器端</code>：可以通过浏览器缓存、页面压缩传输、合理布局页面、减少Cookie传输等手段，甚至可以使用CDN加速功能。</li>
<li><code>应用服务器端</code>：可以使用服务器本地缓存和分布式缓存，也可以通过异步操作方式来加快响应，在高并发请求的情况下，可以将多台应用服务器组成一个集群共同对外服务，提高整体处理能力，改善性能。</li>
<li><code>数据库服务器端</code>：可用使用索引、缓存、SQL性能优化等手段，还可以使用NoSQL数据库来优化数据模型、存储结构等。</li>
</ul>
<p>衡量网站性能有一系列指标，重要的有响应时间、TPS、系统性能计数器等，通过这些指标以确定系统设计是否达到目标。</p>
<h3 id="可用性"><a class="markdownIt-Anchor" href="#可用性"></a> 可用性</h3>
<p>可用性即能够不间断提供服务的时间。几乎所有网站都承诺7×24小时可用，但事实上任何网站都不可能达到完全的7×24，总会有一些故障时间，扣除这些故障时间，就是网站的可用时间。一些大型网站可以做到4个9以上的可用性，也就是99.99%。</p>
<p>网站高可用的主要手段就是冗余，应用部署在多台服务器上同时提供服务，数据存储在多台服务器上相互备份，任何一台服务器都不会影响应用的整体可以，通常的实现手段即把多台服务器通过负载均衡设备组成一个集群。</p>
<p>衡量一个系统架构设计是否满足高可用的目标，就是假设系统中任何一台或者多台服务器宕机时，以及出现各种不可预期的问题时，系统整体是否依然可用。</p>
<h3 id="伸缩性"><a class="markdownIt-Anchor" href="#伸缩性"></a> 伸缩性</h3>
<p>大型网站需要面对大量用户的高并发访问和存储海量数据，网站通过集群的方式将多台服务器组成一个整体共同提供服务。所谓伸缩性是指通过不断向集群中加入服务器的手段来缓解不断整体上市用户并发访问压力和不断增长的数据存储需求。</p>
<p>衡量架构伸缩性的主要标准就是是否可用多台服务器构建集群，是否容易向集群中添加新的服务器。加入新的服务器后是否可以提供和原来的服务器无差别的服务。集群中可容纳的总服务器数量是否有限制。</p>
<h3 id="扩展性"><a class="markdownIt-Anchor" href="#扩展性"></a> 扩展性</h3>
<p>不同于其他架构要素主要关注非功能性需求，网站的扩展性架构直接关注网站的功能需求。网站快速发展，功能不断扩展，如何设计网站的架构使其能够快速响应需求变化，是网站可扩展架构的主要目标。</p>
<p>衡量网站架构扩展性好坏的主要标准就是在网站增加新的业务产品时，是否可以实现对现有产品透明无影响，不同产品之间是否很少耦合等。</p>
<p>网站可扩展架构的主要手段是事件驱动架构和分布式服务。</p>
<p>事件驱动通常利用消息队列实现，通过这种方式将消息生产和处理逻辑分隔开。</p>
<p>服务器服务则是将业务和可复用服务分离开来，通过分布式服务框架调用。新增加产品可用通过调用可复用的服务来实现自身的业务逻辑，而对现有产品没有任何影响。</p>
<h3 id="安全性"><a class="markdownIt-Anchor" href="#安全性"></a> 安全性</h3>
<p>互联网是开发的，任何人在任何地方都可以访问网站。网站的安全架构就是保护网站不受恶意访问和攻击，保护网站的重要数据不被窃取。</p>
<p>衡量网站安全架构的标准就是针对现存和潜在的各种攻击和窃密手段，是否有可靠的应对策略。</p>
]]></content>
      <categories>
        <category>架构</category>
        <category>基础知识</category>
      </categories>
      <tags>
        <tag>架构</tag>
      </tags>
  </entry>
  <entry>
    <title>架构-架构视角</title>
    <url>/posts/bc1ab7b4/</url>
    <content><![CDATA[<blockquote>
<p>在学习架构时，我认为首先要理清楚架构的视角，<strong>因为你所认知的架构和别人所说的架构可能是两码事</strong>。对于不同职位的视角是不一样的，比如开发而言他更多的看到的是开发架构；对售前人员，他可能更多的看到的是业务架构；对于运维人员，他看到的可能是运维架构；而对于技术支持和部署人员，他更多的看到的网络和物理架构。</p>
</blockquote>
<h2 id="架构的视角"><a class="markdownIt-Anchor" href="#架构的视角"></a> 架构的视角</h2>
<p>在笔者的知识体系中，实际上将架构分为业务架构、应用架构、云基础架构这几大类，业务架构主要着眼于控制业务的复杂性，基础架构着眼于解决分布式系统中存在的一系列问题。无论何种架构，都希望能实现系统的可变的同时保障业务的高可用。</p>
<p>注意：</p>
<ul>
<li>很多时候架构的视角/分类没有明显的边界，通常是交叉的；</li>
<li>有意思的是，软件架构及其视角往往和它所在的部门组织架构有着直接关系。@pdai</li>
</ul>
<h3 id="业务架构"><a class="markdownIt-Anchor" href="#业务架构"></a> 业务架构</h3>
<p>核心是解决业务带来的系统复杂性，了解客户/业务方的痛点，项目定义，现有环境；梳理高阶需求和非功能性需求，进行问题域划分与领域建模等工作；沟通，方案建议，多次迭代，交付总体架构。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://pdai.tech/images/arch/arch-x-view-1.png"
                      alt="img" 
                ></p>
<p>看看京东业务架构（网上分享图）：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://pdai.tech/images/arch/arch-x-view-2.jpg"
                      alt="img" 
                ></p>
<h3 id="应用技术架构"><a class="markdownIt-Anchor" href="#应用技术架构"></a> 应用/技术架构</h3>
<p>根据业务场景的需要，设计应用的层次结构，制定应用规范、定义接口和数据交互协议等。并尽量将应用的复杂度控制在一个可以接受的水平，从而在快速的支撑业务发展的同时，在保证系统的可用性和可维护性的同时，确保应用满足非功能属性要求（性能、安全、稳定性等）。技术架构主要考虑系统的非功能性特征，对系统的高可用、高性能、扩展、安全、伸缩性、简洁等做系统级的把握。</p>
<blockquote>
<p>不限于如下视角，主要表示应用开发中的软件架构视角…</p>
</blockquote>
<h4 id="视角功能视角"><a class="markdownIt-Anchor" href="#视角功能视角"></a> 视角：功能视角</h4>
<blockquote>
<p>功能视角和业务视角有重合的地方，主要针对开发而言的服务功能；</p>
</blockquote>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://pdai.tech/images/arch/arch-x-view-3.png"
                      alt="img" 
                ></p>
<h4 id="视角技术视角-总体"><a class="markdownIt-Anchor" href="#视角技术视角-总体"></a> 视角：技术视角-总体</h4>
<p>技术框架（technological Framework）是整个或部分技术系统的可重用设计，表现为一组抽象构件及构件实例间交互的方法;另一种定义认为，技术框架是可被技术开发者定制的应用骨架。前者是从应用方面而后者是从目的方面给出的定义。</p>
<p>从技术层面描述，主要是分层模型，例如持久层、数据层、逻辑层、应用层、表现层等，然后每层使用什么技术框架，例如Spring、hibernate、ioc、MVC、成熟的类库、中间件、WebService等，分别说明，要求这些技术能够将整个系统的主要实现概括。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://pdai.tech/images/arch/arch-x-view-2.png"
                      alt="img" 
                ></p>
<h4 id="视角技术视角-数据架构"><a class="markdownIt-Anchor" href="#视角技术视角-数据架构"></a> 视角：技术视角-数据架构</h4>
<p>专注于构建数据中台，统一数据定义规范，标准化数据表达，形成有效易维护的数据资产。打造统一的大数据处理平台，包括数据可视化运营平台、数据共享平台、数据权限管理平台等。</p>
<h4 id="视角技术视角-基础架构"><a class="markdownIt-Anchor" href="#视角技术视角-基础架构"></a> 视角：技术视角-基础架构</h4>
<p>PAAS，IAAS…</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://pdai.tech/images/arch/arch-x-view-8.jpeg"
                      alt="img" 
                ></p>
<h4 id=""><a class="markdownIt-Anchor" href="#"></a> <a href="#%E8%A7%86%E8%A7%92-%E6%8A%80%E6%9C%AF%E8%A7%86%E8%A7%92-%E8%BF%90%E7%BB%B4%E6%9E%B6%E6%9E%84">#</a> 视角：技术视角-运维架构</h4>
<p>负责运维系统的规划、选型、部署上线，建立规范化的运维体系。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://pdai.tech/images/arch/arch-x-view-7.jpg"
                      alt="img" 
                ></p>
<h3 id="物理架构"><a class="markdownIt-Anchor" href="#物理架构"></a> 物理架构</h3>
<p>物理架构关注软件元件是如何放到硬件上的，专注于基础设施，某种软硬件体系，甚至云平台，包括机房搭建、网络拓扑结构，网络分流器、代理服务器、Web 服务器、应用服务器、报表服务器、整合服务器、存储服务器和主机等。</p>
<h4 id="以一个银行系统为例"><a class="markdownIt-Anchor" href="#以一个银行系统为例"></a> 以一个银行系统为例</h4>
<p>下面为业务性能及网络性能监控的物理部署架构图，分网络接入层和汇聚层两个层次对网络流量报文进行捕获和深入分析。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/images/arch/arch-x-view-4.png"
                      alt="img" 
                ></p>
<p>物理部署架构设计说明：</p>
<ul>
<li>（1）通过4台TAP设备获取青山湖和艾溪湖两个数据中心、五个机房相关应用服务器接入交换机的镜像流量，并进行规则过滤；</li>
<li>（2）通过1台高性能汇聚TAP来获取艾溪湖数据中心二层汇聚交换机和核心交换机的镜像流量，并进行规则过滤；</li>
<li>（3）艾溪湖主数据中心各机房接入层TAP设备的流量共享给汇聚TAP设备；</li>
<li>（4）BPC系统的5台BPC服务器在两个数据中心的每个机房进行分布式部署、解码和分析，并集中展示；</li>
<li>（5）NPM系统在艾溪湖数据中心部署一台管理端服务器，并在每个数据中心各部署一台NPM探针服务器，通过分布式部署、捕获数据，集中监控展示的方式，监控两个数据中心的各业务系统的网络性能；</li>
<li>（6）通过双数据中心、多机房分布式部署的方式，端到端的监控业务在各个环节的流转情况，实时监控，快速定位。</li>
</ul>
<p>下面为运维大数据平台的物理部署拓扑图，分为三个集群，Hadoop集群、ES日志集群和Kalfka消息集群。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://pdai.tech/images/arch/arch-x-view-5.png"
                      alt="img" 
                ></p>
<p>物理部署架构设计说明：</p>
<ul>
<li>配置多台服务器做Hadoop集群，满足不同应用和系统日志的单系统与跨系统交易日志统计与分析，满足数千个基础监控分区的基础性能分析与运行性能指标预测等，以及指性能标入库与历史日志数据入库的存储需要。</li>
<li>配置多台服务器做ES集群，承载实时统一日志查询与分析平台的任务，满足数天至一个月不同需求的日志查询和分析需求，历史日志查询需要从HDFS中将数据导入至ES中，进行二次查询。</li>
<li>配置多台服务器做Kafka集群用于实时的指标型与日志型数据流的采集，满足实时监控的需求。</li>
</ul>
<h2 id="ddd到各种架构"><a class="markdownIt-Anchor" href="#ddd到各种架构"></a> DDD到各种架构</h2>
<p>领域驱动设计的战略核心即是将问题域与应用架构相剥离，将业务语义显现化，把原先晦涩难懂的业务算法逻辑，通过领域对象（Domain Object），统一语言（Ubiquitous Language）转化为领域概念清晰的显性化表达出来。</p>
<ul>
<li><strong>统一语言</strong>，软件的开发人员/使用人员都使用同一套语言，即对某个概念，名词的认知是统一的，建立清晰的业务模型，形成统一的业务语义。将模型作为语言的支柱。确保团队在内部的所有交流中，代码中，画图，写东西，特别是讲话的时候都要使用这种语言。例如账号，转账，透支策略，这些都是非常重要的领域概念，如果这些命名都和我们日常讨论以及 PRD 中的描述保持一致，将会极大提升代码的可读性，减少认知成本。。比如不再会有人在会议中对“工单”、“审核单”、“表单”而反复确认含义了，DDD 的模型建立不会被 DB 所绑架。</li>
<li><strong>面向领域</strong>，业务语义显性化，以领域去思考问题，而不是模块。将隐式的业务逻辑从一推 if-else 里面抽取出来，用通用语言去命名、去写代码、去扩展，让其变成显示概念；很多重要的业务概念，按照事务脚本的写法，其含义完全淹没在代码逻辑中没有突显出来。</li>
<li><strong>职责划分</strong>，根据实际业务合理划分模型，模型之间依赖结构和边界更加清晰，避免了混乱的依赖关系，进而增加可读性、可维护性；单一职责，模型只关注自身的本职工作，避免“越权”而导致混乱的调用关系。通过建模，更好的表达现实世界中的复杂业务，随着时间的发展，不断增加系统对实际业务的沉淀，也将更好的通过清晰的代码描述业务逻辑，模型的内聚增加了系统的高度模块化，提升代码的可重用性，对比传统三层模式中，很有可能大量重复的功能散落在各个 Service 内部。</li>
</ul>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://pdai.tech/images/arch/arch-x-view-10.png"
                      alt="img" 
                ></p>
]]></content>
      <categories>
        <category>架构</category>
        <category>基础知识</category>
      </categories>
      <tags>
        <tag>架构</tag>
      </tags>
  </entry>
  <entry>
    <title>分布式事务-刚性事务</title>
    <url>/posts/9c9cf1a5/</url>
    <content><![CDATA[<blockquote>
<p>说到刚性事务，首先要讲的是XA协议。XA协议是一个基于<strong>数据库</strong>的分布式事务协议，其分为两部分：<strong>事务管理器（Transaction Manager）和 本地资源管理器（Resource Manager）</strong>。事务管理器作为一个全局的调度者，负责对各个本地资源管理器统一号令提交或者回滚。<code>二阶提交协议（2PC）</code>和<code>三阶提交协议（3PC）</code>就是根据此协议衍生出来而来。主流的诸如Oracle、MySQL等数据库均已实现了XA接口。</p>
</blockquote>
<p>XA接口是双向的系统接口，在事务管理器（Transaction Manager）以及一个或多个资源管理器（Resource Manager）之间形成通信桥梁。也就是说，在基于XA的一个事务中，我们可以针对多个资源进行事务管理，例如一个系统访问多个数据库，或即访问数据库、又访问像消息中间件这样的资源。这样我们就能够实现在多个数据库和消息中间件直接实现全部提交、或全部取消的事务。<strong>XA规范不是java的规范，而是一种通用的规范; Java 中的规范是JTA和JTS：Java事务API（Java Transaction API）是一个Java企业版的应用程序接口，在Java环境中，允许完成跨越多个XA资源的分布式事务；Java事务服务（Java Transaction Service）是J2EE平台提供了分布式事务服务的具体实现规范，j2ee服务器提供商根据JTS规范实现事务并提供JTA接口</strong>。</p>
<h3 id="两段提交2pc"><a class="markdownIt-Anchor" href="#两段提交2pc"></a> 两段提交（2PC）</h3>
<blockquote>
<p>引入一个作为协调者（coordinator）的组件来统一掌控所有参与者（participant）的操作结果，并最终指示这些节点是否要把操作结果进行真正的提交。</p>
</blockquote>
<p>简单而言：参与者（participant）用来管理资源，协调者（coordinator）用来协调事务状态</p>
<p>两段提交（2PC - Prepare &amp; Commit）是指两个阶段的提交：</p>
<ul>
<li>
<p>第一阶段</p>
<blockquote>
<p>准备阶段</p>
</blockquote>
<ul>
<li>协调者向所有参与者发送 REQUEST-TO-PREPARE</li>
<li>当参与者收到REQUEST-TO-PREPARE 消息后, 它向协调者发送消息PREPARED或者NO，表示事务是否准备好；如果发送的是NO，那么事务要回滚；</li>
</ul>
</li>
<li>
<p>第二阶段</p>
<blockquote>
<p>提交阶段</p>
</blockquote>
<ul>
<li>协调者收集所有参与者的返回消息, 如果所有的参与者都回复的是PREPARED， 那么协调者向所有参与者发送COMMIT 消息；否则，协调者向所有回复PREPARED的参与者发送ABORT消息；</li>
<li>参与者如果回复了PREPARED消息并且收到协调者发来的COMMIT消息，或者它收到ABORT消息，它将执行提交或回滚，并向协调者发送DONE消息以确认。</li>
</ul>
</li>
</ul>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://pdai.tech/images/arch/arch-z-transection-4.png"
                      alt="img" 
                ></p>
<p><strong>两段提交（2PC）的缺点</strong>：</p>
<p>二阶段提交看似能够提供原子性的操作，但它存在着严重的缺陷：</p>
<ul>
<li><strong>网络抖动导致的数据不一致</strong>：第二阶段中协调者向参与者发送commit命令之后，一旦此时发生网络抖动，导致一部分参与者接收到了commit请求并执行，可其他未接到commit请求的参与者无法执行事务提交。进而导致整个分布式系统出现了数据不一致。</li>
<li><strong>超时导致的同步阻塞问题</strong>：2PC中的所有的参与者节点都为事务阻塞型，当某一个参与者节点出现通信超时，其余参与者都会被动阻塞占用资源不能释放。</li>
<li><strong>单点故障的风险</strong>：由于严重的依赖协调者，一旦协调者发生故障，而此时参与者还都处于锁定资源的状态，无法完成事务commit操作。虽然协调者出现故障后，会重新选举一个协调者，可无法解决因前一个协调者宕机导致的参与者处于阻塞状态的问题。</li>
</ul>
<p><strong>2PC小结</strong></p>
<p>2PC除本身的算法局限外，还有一个使用上的限制，就是它主要用在两个数据库之间（数据库实现了XA协议）。两个系统之间是无法使用2PC的，因为不会直接在底层的两个业务数据库之间做一致性，而是在两个服务上面实现一致性。</p>
<div class="note note-warning icon-padding"><i class="note-icon fa-solid fa-exclamation-circle"></i><p><em>2PC只适用两个数据库（数据库实现了XA协议）之间；2PC有诸多问题和不便，在实践中一般很少使用</em>。</p>
</div>
<h3 id="三段提交3pc"><a class="markdownIt-Anchor" href="#三段提交3pc"></a> 三段提交（3PC）</h3>
<blockquote>
<p>三段提交（3PC）是对两段提交（2PC）的一种升级优化，<strong>3PC在2PC的第一阶段和第二阶段中插入一个准备阶段</strong>。保证了在最后提交阶段之前，各参与者节点的状态都一致。同时在协调者和参与者中都引入超时机制，当参与者各种原因未收到协调者的commit请求后，会对本地事务进行commit，不会一直阻塞等待，解决了2PC的单点故障问题，但3PC还是没能从根本上解决数据一致性的问题。</p>
</blockquote>
<p><strong>3PC的三个阶段分别是CanCommit、PreCommit、DoCommit</strong>：</p>
<ul>
<li><strong>CanCommit</strong>：协调者向所有参与者发送CanCommit命令，询问是否可以执行事务提交操作。如果全部响应YES则进入下一个阶段。</li>
<li><strong>PreCommit</strong>：协调者向所有参与者发送PreCommit命令，询问是否可以进行事务的预提交操作，参与者接收到PreCommit请求后，如参与者成功的执行了事务操作，则返回Yes响应，进入最终commit阶段。一旦参与者中有向协调者发送了No响应，或因网络造成超时，协调者没有接到参与者的响应，协调者向所有参与者发送abort请求，参与者接受abort命令执行事务的中断。</li>
<li><strong>DoCommit</strong>：在前两个阶段中所有参与者的响应反馈均是YES后，协调者向参与者发送DoCommit命令正式提交事务，如协调者没有接收到参与者发送的ACK响应，会向所有参与者发送abort请求命令，执行事务的中断。</li>
</ul>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://pdai.tech/images/arch/arch-z-transection-5.png"
                      alt="img" 
                ></p>
<p><strong>3PC存在的问题</strong></p>
<p>3PC工作在同步网络模型上，它假设消息传输时间是有上界的，只存在机器失败而不存在消息失败。这个假设太强，现实的情形是，机器失败是无法完美地检测出来的，消息传输可能因为网络拥堵花费很多时间。同时, 说阻塞是相对, 存在协调者和参与者同时失败的情形下, 3PC事务依然会阻塞。实际上，很少会有系统实现3PC，多数现实的系统会通过复制状态机解决2PC阻塞的问题。比如，如果失败模型不是失败-停止, 而是消息失败（消息延迟或网络分区），那样3PC会产生不一致的情形。</p>
<div class="note note-warning icon-padding"><i class="note-icon fa-solid fa-exclamation-circle"></i><p><em>3PC并没有完美解决2PC的阻塞，也引入了新的问题（不一致问题），所以3PC很少会被真正的使用</em>。</p>
</div>
]]></content>
      <categories>
        <category>分布式</category>
        <category>分布式事务</category>
      </categories>
      <tags>
        <tag>分布式事务</tag>
      </tags>
  </entry>
  <entry>
    <title>分布式事务-柔性事务</title>
    <url>/posts/7206c2ae/</url>
    <content><![CDATA[<blockquote>
<p>柔性事务：分布式理论的AP，遵循BASE，允许一定时间内不同节点的数据不一致，但要求最终一致。</p>
</blockquote>
<h3 id="补偿事务-tcc"><a class="markdownIt-Anchor" href="#补偿事务-tcc"></a> 补偿事务 (TCC)</h3>
<blockquote>
<p>TCC（Try-Confirm-Cancel）又被称补偿事务，TCC与2PC的思想很相似，事务处理流程也很相似，但<strong>2PC是应用于在DB层面，TCC则可以理解为在应用层面的2PC，是需要我们编写业务逻辑来实现</strong>。</p>
</blockquote>
<p>TCC它的核心思想是：“针对每个操作都要注册一个与其对应的确认（Try）和补偿（Cancel）”。</p>
<p>还拿下单扣库存解释下它的三个操作：</p>
<ul>
<li><strong>Try阶段</strong>：下单时通过Try操作去扣除库存预留资源。</li>
<li><strong>Confirm阶段</strong>：确认执行业务操作，在只预留的资源基础上，发起购买请求。</li>
<li><strong>Cancel阶段</strong>：只要涉及到的相关业务中，有一个业务方预留资源未成功，则取消所有业务资源的预留请求。</li>
</ul>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://pdai.tech/images/arch/arch-z-trans-6.png"
                      alt="img" 
                ></p>
<p><strong>TCC的缺点</strong>：</p>
<p>1.空回滚</p>
<p>当一个分支事务所在的服务发生宕机或者网络异常导致调用失败，并未执行try方法，当恢复后事务执行回滚操作就会调用此分支事务的cancel方法,如果cancel方法不能处理此种情况就会出现空回滚。</p>
<p>是否出现空回滚，我们需要需要判断是否执行了try方法，如果执行了就没有空回滚。解决方法就是当主业务发起事务时，生成一个全局事务记录，并生成一个全局唯一ID，贯穿整个事务，再创建一张分支事务记录表，用于记录分支事务，try执行时将全局事务ID和分支事务ID存入分支事务表中，表示执行了try阶段，当cancel执行时，先判断表中是否有该全局事务ID的数据，如果有则回滚，否则不做任何操作。比如seata的AT模式中就有分支事务表。</p>
<p>2.幂等问题</p>
<p>由于服务宕机或者网络问题，方法的调用可能出现超时，为了保证事务正常执行我们往往会加入重试的机制，因此就需要保证confirm和cancel阶段操作的幂等性。</p>
<p>我们可以在分支事务记录表中增加事务执行状态，每次执行confirm和cancel方法时都查询该事务的执行状态，以此判断事务的幂等性。</p>
<p>3.悬挂问题</p>
<p>TCC中，在调用try之前会先注册分支事务，注册分支事务之后，调用出现超时，此时try请求还未到达对应的服务，因为调用超时了，所以会执行cancel调用，此时cancel已经执行完了，然而这个时候try请求到达了，这个时候执行了try之后就没有后续的操作了，就会导致资源挂起，无法释放。</p>
<p>执行try方法时我们可以判断confirm或者cancel方法是否执行，如果执行了那么就不执行try阶段。同样借助分支事务表中事务的执行状态。如果已经执行了confirm或者cancel那么try就执行。</p>
<h3 id="saga事务"><a class="markdownIt-Anchor" href="#saga事务"></a> Saga事务</h3>
<blockquote>
<p>Saga是分布式事务领域最有名气的解决方案之一，最初出现在1987年Hector Garcaa-Molrna &amp; Kenneth Salem发表的论文SAGAS里。 如下内容主要来源于<a class="link"   href="https://blog.couchbase.com/saga-pattern-implement-business-transactions-using-microservices-part/" >这里在新窗口打开 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>，然后由flyingww翻译整理在<a class="link"   href="https://zhuanlan.zhihu.com/p/95852045" >知乎在新窗口打开 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>。</p>
</blockquote>
<p>Saga是由一系列的本地事务构成。每一个本地事务在更新完数据库之后，会发布一条消息或者一个事件来触发Saga中的下一个本地事务的执行。如果一个本地事务因为某些业务规则无法满足而失败，Saga会执行在这个失败的事务之前成功提交的所有事务的补偿操作。</p>
<p>Saga的实现有很多种方式，其中最流行的两种方式是：</p>
<ul>
<li><strong>基于事件的方式</strong>。这种方式没有协调中心，整个模式的工作方式就像舞蹈一样，各个舞蹈演员按照预先编排的动作和走位各自表演，最终形成一只舞蹈。处于当前Saga下的各个服务，会产生某类事件，或者监听其它服务产生的事件并决定是否需要针对监听到的事件做出响应。</li>
<li><strong>基于命令的方式</strong>。这种方式的工作形式就像一只乐队，由一个指挥家（协调中心）来协调大家的工作。协调中心来告诉Saga的参与方应该执行哪一个本地事务。</li>
</ul>
<p>我们继续以订单流程为例，说明一下该模式。</p>
<p>假设一个完整的订单流程包含了如下几个服务：</p>
<ol>
<li>Order Service：订单服务</li>
<li>Payment Service：支付服务</li>
<li>Stock Service：库存服务</li>
<li>Delivery Service：物流服务</li>
</ol>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://pdai.tech/images/arch/arch-transection-31.webp"
                      alt="img" 
                ></p>
<h4 id="基于事件的方式"><a class="markdownIt-Anchor" href="#基于事件的方式"></a> 基于事件的方式</h4>
<p>在基于事件的方式中，第一个服务执行完本地事务之后，会产生一个事件。其它服务会监听这个事件，触发该服务本地事务的执行，并产生新的事件。</p>
<p>采用基于事件的saga模式的订单处理流程如下：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://pdai.tech/images/arch/arch-transection-32.webp"
                      alt="img" 
                ></p>
<ol>
<li>订单服务创建一笔新订单，将订单状态设置为&quot;待处理&quot;，产生事件ORDER_CREATED_EVENT。</li>
<li>支付服务监听ORDER_CREATED_EVENT，完成扣款并产生事件BILLED_ORDER_EVENT。</li>
<li>库存服务监听BILLED_ORDER_EVENT，完成库存扣减和备货，产生事件ORDER_PREPARED_EVENT。</li>
<li>物流服务监听ORDER_PREPARED_EVENT，完成商品配送，产生事件ORDER_DELIVERED_EVENT。</li>
<li>订单服务监听ORDER_DELIVERED_EVENT，将订单状态更新为&quot;完成&quot;。</li>
</ol>
<p>在这个流程中，订单服务很可能还会监听BILLED_ORDER_EVENT，ORDER_PREPARED_EVENT来完成订单状态的实时更新。将订单状态分别更新为&quot;已经支付&quot;和&quot;已经出库&quot;等状态来及时反映订单的最新状态。</p>
<p><strong>该模式下分布式事务的回滚</strong></p>
<p>为了在异常情况下回滚整个分布式事务，我们需要为相关服务提供补偿操作接口。</p>
<p>假设库存服务由于库存不足没能正确完成备货，我们可以按照下面的流程来回滚整个Saga事务：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://pdai.tech/images/arch/arch-transection-33.webp"
                      alt="img" 
                ></p>
<ol>
<li>库存服务产生事件PRODUCT_OUT_OF_STOCK_EVENT。</li>
<li>订单服务和支付服务都会监听该事件并做出响应：
<ol>
<li>支付服务完成退款。</li>
<li>订单服务将订单状态设置为&quot;失败&quot;。</li>
</ol>
</li>
</ol>
<p><strong>基于事件方式的优缺点</strong></p>
<p><strong>优点</strong>：简单且容易理解。各参与方相互之间无直接沟通，完全解耦。这种方式比较适合整个分布式事务只有2-4个步骤的情形。</p>
<p><strong>缺点</strong>：这种方式如果涉及比较多的业务参与方，则比较容易失控。各业务参与方可随意监听对方的消息，以至于最后没人知道到底有哪些系统在监听哪些消息。更悲催的是，这个模式还可能产生环形监听，也就是两个业务方相互监听对方所产生的事件。</p>
<p>接下来，我们将介绍如何使用命令的方式来克服上面提到的缺点。</p>
<h4 id="基于命令的方式"><a class="markdownIt-Anchor" href="#基于命令的方式"></a> 基于命令的方式</h4>
<p>在基于命令的方式中，我们会定义一个新的服务，这个服务扮演的角色就和一支交响乐乐队的指挥一样，告诉各个业务参与方，在什么时候做什么事情。我们管这个新服务叫做协调中心。协调中心通过命令/回复的方式来和Saga中其它服务进行交互。</p>
<p>我们继续以之前的订单流程来举例。下图中的Order Saga Orchestrator就是新引入的协调中心。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://pdai.tech/images/arch/arch-transection-34.webp"
                      alt="img" 
                ></p>
<ol>
<li>订单服务创建一笔新订单，将订单状态设置为&quot;待处理&quot;，然后让Order Saga Orchestrator（OSO）开启创建订单事务。</li>
<li>OSO发送一个&quot;支付命令&quot;给支付服务，支付服务完成扣款并回复&quot;支付完成&quot;消息。</li>
<li>OSO发送一个&quot;备货命令&quot;给库存服务，库存服务完成库存扣减和备货，并回复&quot;出库&quot;消息。</li>
<li>OSO发送一个&quot;配送命令&quot;给物流服务，物流服务完成配送，并回复&quot;配送完成&quot;消息。</li>
<li>OSO向订单服务发送&quot;订单结束命令&quot;给订单服务，订单服务将订单状态设置为&quot;完成&quot;。</li>
<li>OSO清楚一个订单处理Saga的具体流程，并在出现异常时向相关服务发送补偿命令来回滚整个分布式事务。</li>
</ol>
<p>实现协调中心的一个比较好的方式是使用<strong>状态机(Sate Machine)</strong>。</p>
<p><strong>该模式下分布式事务的回滚</strong></p>
<p>该模式下的回滚流程如下：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://pdai.tech/images/arch/arch-transection-35.webp"
                      alt="img" 
                ></p>
<ol>
<li>库存服务回复OSO一个&quot;库存不足&quot;消息。</li>
<li>OSO意识到该分布式事务失败了，触发回滚流程：</li>
<li>OSO发送&quot;退款命令&quot;给支付服务，支付服务完成退款并回复&quot;退款成功&quot;消息。</li>
<li>OSO向订单服务发送&quot;将订单状态改为失败命令&quot;，订单服务将订单状态更新为&quot;失败&quot;。</li>
</ol>
<p><strong>基于命令方式的优缺点</strong></p>
<p>优点：</p>
<ol>
<li>避免了业务方之间的环形依赖。</li>
<li>将分布式事务的管理交由协调中心管理，协调中心对整个逻辑非常清楚。</li>
<li>减少了业务参与方的复杂度。这些业务参与方不再需要监听不同的消息，只是需要响应命令并回复消息。</li>
<li>测试更容易（分布式事务逻辑存在于协调中心，而不是分散在各业务方）。</li>
<li>回滚也更容易。</li>
</ol>
<p>缺点：</p>
<ol>
<li>一个可能的缺点就是需要维护协调中心，而这个协调中心并不属于任何业务方。</li>
</ol>
<h4 id="saga模式建议"><a class="markdownIt-Anchor" href="#saga模式建议"></a> Saga模式建议</h4>
<p>1，给每一个分布式事务创建一个唯一的Tx id。这个唯一的Tx id可以用来在各个业务参与方沟通时精确定位哪一笔分布式事务。</p>
<p>2，对于基于命令的方式，在命令中携带回复地址。这种方式可以让服务同时响应多个协调中心请求。</p>
<p>3，幂等性。幂等性能够增加系统的容错性，让各个业务参与方服务提供幂等性操作，能够在遇到异常情况下进行重试。</p>
<p>4，尽量在命令或者消息中携带下游处理需要的业务数据，避免下游处理时需要调用消息产生方接口获取更多数据。减少系统之间的相互依赖。</p>
<h3 id="本地消息表"><a class="markdownIt-Anchor" href="#本地消息表"></a> 本地消息表</h3>
<blockquote>
<p>本地消息表的方案最初是由 eBay 提出，核心思路是将分布式事务拆分成本地事务进行处理。此章节来源于CSDN博主不才陈某<a class="link"   href="https://blog.csdn.net/qq_34162294/article/details/120984951" >这里在新窗口打开 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
</blockquote>
<p>角色：</p>
<ul>
<li>事务主动方</li>
<li>事务被动方</li>
</ul>
<p>通过在事务主动发起方额外新建事务消息表，事务发起方处理业务和记录事务消息在本地事务中完成，轮询事务消息表的数据发送事务消息，事务被动方基于消息中间件消费事务消息表中的事务。</p>
<p>这样可以避免以下两种情况导致的数据不一致性：</p>
<ul>
<li>业务处理成功、事务消息发送失败</li>
<li>业务处理失败、事务消息发送成功</li>
</ul>
<p>整体的流程如下图：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://pdai.tech/images/arch/arch-transection-41.png"
                      alt="img" 
                ></p>
<p>上图中整体的处理步骤如下：</p>
<ol>
<li>事务主动方在同一个本地事务中处理业务和写消息表操作</li>
<li>事务主动方通过消息中间件，通知事务被动方处理事务通知事务待消息。消息中间件可以基于 Kafka、RocketMQ 消息队列，事务主动方主动写消息到消息队列，事务消费方消费并处理消息队列中的消息。</li>
<li>事务被动方通过消息中间件，通知事务主动方事务已处理的消息。</li>
<li>事务主动方接收中间件的消息，更新消息表的状态为已处理。</li>
</ol>
<p>一些必要的容错处理如下：</p>
<ul>
<li>当1处理出错，由于还在事务主动方的本地事务中，直接回滚即可</li>
<li>当2,3处理出错，由于事务主动方本地保存了消息，只需要轮询消息重新通过消息中间件发送，事务被动方重新读取消息处理业务即可。</li>
<li>如果是业务上处理失败，事务被动方可以发消息给事务主动方回滚事务</li>
<li>如果事务被动方已经消费了消息，事务主动方需要回滚事务的话，需要发消息通知事务主动方进行回滚事务。</li>
</ul>
<p><strong>优点</strong></p>
<ul>
<li>从应用设计开发的角度实现了消息数据的可靠性，消息数据的可靠性不依赖于消息中间件，弱化了对 MQ 中间件特性的依赖。</li>
<li>方案轻量，容易实现。</li>
</ul>
<p><strong>缺点</strong></p>
<ul>
<li>与具体的业务场景绑定，耦合性强，不可公用。</li>
<li>消息数据与业务数据同库，占用业务系统资源。</li>
<li>业务系统在使用关系型数据库的情况下，消息服务性能会受到关系型数据库并发性能的局限。</li>
</ul>
<h3 id="mq事务方案可靠消息事务"><a class="markdownIt-Anchor" href="#mq事务方案可靠消息事务"></a> MQ事务方案（可靠消息事务）</h3>
<blockquote>
<p>基于 MQ 的分布式事务方案其实是对本地消息表的封装，将本地消息表基于 MQ 内部，其他方面的协议基本与本地消息表一致。</p>
</blockquote>
<p>MQ事务方案整体流程和本地消息表的流程很相似，如下图：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://pdai.tech/images/arch/arch-transection-42.png"
                      alt="img" 
                ></p>
<p>从上图可以看出和本地消息表方案唯一不同就是将本地消息表存在了MQ内部，而不是业务数据库中。</p>
<p>那么MQ内部的处理尤为重要，下面主要基于 RocketMQ 4.3 之后的版本介绍 MQ 的分布式事务方案。</p>
<p>在本地消息表方案中，保证事务主动方发写业务表数据和写消息表数据的一致性是基于数据库事务，RocketMQ 的事务消息相对于普通 MQ提供了 2PC 的提交接口，方案如下：</p>
<p><strong>正常情况：事务主动方发消息</strong></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://pdai.tech/images/arch/arch-transection-44.png"
                      alt="img" 
                ></p>
<p>这种情况下，事务主动方服务正常，没有发生故障，发消息流程如下：</p>
<ul>
<li>发送方向 MQ 服务端(MQ Server)发送 half 消息。</li>
<li>MQ Server 将消息持久化成功之后，向发送方 ack 确认消息已经发送成功。</li>
<li>发送方开始执行本地事务逻辑。</li>
<li>发送方根据本地事务执行结果向 MQ Server 提交二次确认（commit 或是 rollback）。</li>
<li>MQ Server 收到 commit 状态则将半消息标记为可投递，订阅方最终将收到该消息；MQ Server 收到 rollback 状态则删除半消息，订阅方将不会接受该消息。</li>
</ul>
<p><strong>异常情况：事务主动方消息恢复</strong></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://pdai.tech/images/arch/arch-transection-45.png"
                      alt="img" 
                ></p>
<p>在断网或者应用重启等异常情况下，图中 4 提交的二次确认超时未到达 MQ Server，此时处理逻辑如下：</p>
<ul>
<li>MQ Server 对该消息发起消息回查。</li>
<li>发送方收到消息回查后，需要检查对应消息的本地事务执行的最终结果。</li>
<li>发送方根据检查得到的本地事务的最终状态再次提交二次确认。</li>
<li>MQ Server基于 commit/rollback 对消息进行投递或者删除。</li>
</ul>
<p><strong>优点</strong></p>
<p>相比本地消息表方案，MQ 事务方案优点是：</p>
<ul>
<li>消息数据独立存储 ，降低业务系统与消息系统之间的耦合。</li>
<li>吞吐量大于使用本地消息表方案。</li>
</ul>
<p><strong>缺点</strong></p>
<ul>
<li>一次消息发送需要两次网络请求(half 消息 + commit/rollback 消息) 。</li>
<li>业务处理服务需要实现消息状态回查接口。</li>
</ul>
<h3 id="最大努力通知"><a class="markdownIt-Anchor" href="#最大努力通知"></a> 最大努力通知</h3>
<blockquote>
<p>最大努力通知也称为定期校对，是对MQ事务方案的进一步优化。它在事务主动方增加了消息校对的接口，如果事务被动方没有接收到消息，此时可以调用事务主动方提供的消息校对的接口主动获取。</p>
</blockquote>
<p>最大努力通知的整体流程如下图：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://pdai.tech/images/arch/arch-transection-46.png"
                      alt="img" 
                ></p>
<p>在可靠消息事务中，事务主动方需要将消息发送出去，并且消息接收方成功接收，这种可靠性发送是由事务主动方保证的；</p>
<p>但是最大努力通知，事务主动方尽最大努力（重试，轮询…）将事务发送给事务接收方，但是仍然存在消息接收不到，此时需要事务被动方主动调用事务主动方的消息校对接口查询业务消息并消费，这种通知的可靠性是由事务被动方保证的。</p>
<p>最大努力通知适用于业务通知类型，例如微信交易的结果，就是通过最大努力通知方式通知各个商户，既有回调通知，也有交易查询接口。</p>
<h2 id="分布式事务的中间件seata"><a class="markdownIt-Anchor" href="#分布式事务的中间件seata"></a> 分布式事务的中间件Seata</h2>
<blockquote>
<p>Seata 是一款开源的分布式事务解决方案，致力于提供高性能和简单易用的分布式事务服务。Seata 将为用户提供了 AT、TCC、SAGA 和 XA 事务模式，为用户打造一站式的分布式解决方案。如下内容来源于<a class="link"   href="https://seata.io/zh-cn/docs/overview/what-is-seata.html" >Seata官网在新窗口打开 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
</blockquote>
<ul>
<li><strong>TC (Transaction Coordinator) - 事务协调者</strong>: 维护全局和分支事务的状态，驱动全局事务提交或回滚。</li>
<li><strong>TM (Transaction Manager) - 事务管理器</strong>: 定义全局事务的范围：开始全局事务、提交或回滚全局事务。</li>
<li><strong>RM (Resource Manager) - 资源管理器</strong>: 管理分支事务处理的资源，与TC交谈以注册分支事务和报告分支事务的状态，并驱动分支事务提交或回滚。</li>
</ul>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://pdai.tech/images/arch/arch-transection-6.png"
                      alt="img" 
                ></p>
]]></content>
      <categories>
        <category>分布式</category>
        <category>分布式事务</category>
      </categories>
      <tags>
        <tag>分布式事务</tag>
      </tags>
  </entry>
  <entry>
    <title>分布式事务-理解概述</title>
    <url>/posts/750a2ea3/</url>
    <content><![CDATA[<blockquote>
<p><strong>事务</strong>是一个程序执行单元，里面的所有操作要么全部执行成功，要么全部执行失败。而<strong>分布式事务</strong>是指事务的参与者、支持事务的服务器、资源服务器以及事务管理器分别位于不同的分布式系统的不同节点之上。</p>
</blockquote>
<h2 id="什么是分布式事务"><a class="markdownIt-Anchor" href="#什么是分布式事务"></a> 什么是分布式事务</h2>
<blockquote>
<p><strong>事务</strong>是一个程序执行单元，里面的所有操作要么全部执行成功，要么全部执行失败。在分布式系统中，这些操作可能是位于不同的服务中，那么如果也能保证这些操作要么全部执行成功要么全部执行失败呢？这便是分布式事务要解决的问题。</p>
</blockquote>
<p><strong>以一个网上的经典下单减库存例子为例</strong>：</p>
<p>单体应用所有的业务都使用一个数据库，整个下单流程或许只用在一个方法里同一个事务下操作数据库即可。此时所有操作都在一个事务里，要么全部提交，要么全部回滚。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://pdai.tech/images/arch/arch-z-transection-2.png"
                      alt="img" 
                ></p>
<p>但随着业务量不断增长，业务服务化拆分，就会分离出订单中心、库存中心等。而这样就造成业务间相互隔离，每个业务都维护着自己的数据库，数据的交换只能进行服务调用。</p>
<p>用户再下单时，创建订单和扣减库存，需要同时对订单DB和库存DB进行操作。两步操作必须同时成功，否则就会造成业务混乱，可此时我们只能保证自己服务的数据一致性，无法保证调用其他服务的操作是否成功，所以为了保证整个下单流程的数据一致性，就需要分布式事务介入。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://pdai.tech/images/arch/arch-z-transection-3.png"
                      alt="img" 
                ></p>
<h2 id="如何理解分布式事务"><a class="markdownIt-Anchor" href="#如何理解分布式事务"></a> 如何理解分布式事务</h2>
<blockquote>
<p>分布式的理论角度和分布式事务的知识体系角度理解分布式事务。</p>
</blockquote>
<h3 id="从分布式的理论的角度看"><a class="markdownIt-Anchor" href="#从分布式的理论的角度看"></a> 从分布式的理论的角度看</h3>
<blockquote>
<p>分布式的理论基础是CAP，由于P(分区容错）是必选项，所以只能在AP或者CP中选择。</p>
</blockquote>
<ul>
<li><strong>分布式理论的CP</strong> -&gt; 刚性事务</li>
</ul>
<p>遵循ACID，对数据要求强一致性</p>
<ul>
<li><strong>分布式理论的AP+BASE</strong> -&gt; 柔性事务</li>
</ul>
<p>遵循BASE，允许一定时间内不同节点的数据不一致，但要求最终一致。</p>
<h3 id="从分布式事务的体系看"><a class="markdownIt-Anchor" href="#从分布式事务的体系看"></a> 从分布式事务的体系看</h3>
<blockquote>
<p>我在梳理这个体系时，发现网上几乎都直接写2PC,3PC,TCC,Seata方案，而实际上这是不成体系的。从分布式事务的体系看，我认为至少应该理清楚，什么是技术方案，什么是中间件，以及形成这些方案的依据；以此，我画了如下的图。@pdai</p>
</blockquote>
<p>如下图，可以帮助你构筑分布式事务的知识体系，一目了然。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://pdai.tech/images/arch/arch-z-transection-1.png"
                      alt="img" 
                ></p>
<ul>
<li>
<p><strong>刚性事务</strong>：分布式理论的CP，遵循ACID，对数据要求强一致性。</p>
<ul>
<li>
<p>XA协议是一个基于数据库层面的分布式事务协议，其分为两部分：</p>
<p><span style="border-bottom: 2px solid green">事务管理器（Transaction Manager）<strong>和</strong>本地资源管理器（Resource Manager）</span>。事务管理器作为一个全局的调度者，负责对各个本地资源管理器统一号令提交或者回滚。主流的诸如Oracle、MySQL等数据库均已实现了XA接口。</p>
<ul>
<li><strong>二阶提交协议（2PC）</strong>: 根据XA协议衍生出来而来; 引入一个作为协调者的组件来统一掌控所有参与者的操作结果并最终指示这些节点是否要把操作结果进行真正的提交; 参与者将操作成败通知协调者，再由协调者根据所有参与者的反馈情报决定各参与者是否要提交操作还是中止操作。所谓的两个阶段是指：第一阶段：准备阶段 (投票阶段) 和第二阶段：提交阶段（执行阶段）</li>
</ul>
</li>
<li>
<p><strong>三阶提交协议（3PC）</strong>: 是对两段提交（2PC）的一种升级优化，<strong>3PC在2PC的第一阶段和第二阶段中插入一个准备阶段</strong>。保证了在最后提交阶段之前，各参与者节点的状态都一致。同时在协调者和参与者中都引入超时机制，当参与者各种原因未收到协调者的commit请求后，会对本地事务进行commit，不会一直阻塞等待，解决了2PC的单点故障问题，但3PC还是没能从根本上解决数据一致性的问题。</p>
</li>
</ul>
</li>
<li>
<p>Java事务规范</p>
<ul>
<li><strong>JTA</strong>：Java事务API（Java Transaction API）是一个Java企业版的应用程序接口，在Java环境中，允许完成跨越多个XA资源的分布式事务。
<ul>
<li><strong>JTS</strong>：Java事务服务（Java Transaction Service）是J2EE平台提供了分布式事务服务的具体实现规范，j2ee服务器提供商根据JTS规范实现事务并提供JTA接口。</li>
</ul>
</li>
</ul>
</li>
<li>
<p><strong>柔性事务</strong>：<span style="border-bottom: 2px solid green">分布式理论的AP，遵循BASE，允许一定时间内不同节点的数据不一致，但要求最终一致。</span></p>
<ul>
<li>基于业务层
<ul>
<li><strong>TCC</strong>: TCC（Try-Confirm-Cancel）又被称补偿事务，TCC与2PC的思想很相似，事务处理流程也很相似，但2PC是应用于在DB层面，TCC则可以理解为在应用层面的2PC，是需要我们编写业务逻辑来实现。</li>
<li><strong>SAGA</strong>：Saga是由一系列的本地事务构成。每一个本地事务在更新完数据库之后，会发布一条消息或者一个事件来触发Saga中的下一个本地事务的执行。如果一个本地事务因为某些业务规则无法满足而失败，Saga会执行在这个失败的事务之前成功提交的所有事务的补偿操作。Saga的实现有很多种方式，其中最流行的两种方式是：基于事件的方式和基于命令的方式。</li>
</ul>
</li>
<li>最终一致性
<ul>
<li><strong>消息表</strong>：本地消息表的方案最初是由 eBay 提出，核心思路是将分布式事务拆分成本地事务进行处理。</li>
<li><strong>消息队列</strong>：基于 MQ 的分布式事务方案其实是对本地消息表的封装，将本地消息表基于 MQ 内部，其他方面的协议基本与本地消息表一致。</li>
<li><strong>最大努力通知</strong>：最大努力通知也称为定期校对，是对MQ事务方案的进一步优化。它在事务主动方增加了消息校对的接口，如果事务被动方没有接收到消息，此时可以调用事务主动方提供的消息校对的接口主动获取。</li>
</ul>
</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>分布式</category>
        <category>分布式事务</category>
      </categories>
      <tags>
        <tag>分布式事务</tag>
      </tags>
  </entry>
  <entry>
    <title>分布式唯一ID-数据库生成</title>
    <url>/posts/63cd793d/</url>
    <content><![CDATA[<p>是不是一定要基于外界的条件才能满足分布式唯一ID的需求呢，我们能不能在我们分布式数据库的基础上获取我们需要的ID？</p>
<p>由于分布式数据库的起始自增值一样所以才会有冲突的情况发生，那么我们将分布式系统中数据库的同一个业务表的自增ID设计成不一样的起始值，然后设置固定的步长，步长的值即为分库的数量或分表的数量。</p>
<p>以MySQL举例，利用给字段设置<code>auto_increment_increment</code>和<code>auto_increment_offset</code>来保证ID自增。</p>
<ul>
<li><code>auto_increment_offset</code>：表示自增长字段从那个数开始，他的取值范围是1 … 65535。</li>
<li><code>auto_increment_increment</code>：表示自增长字段每次递增的量，其默认值是1，取值范围是1 … 65535。</li>
</ul>
<p>假设有三台机器，则DB1中order表的起始ID值为1，DB2中order表的起始值为2，DB3中order表的起始值为3，它们自增的步长都为3，则它们的ID生成范围如下图所示：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://pdai.tech/images/arch/arch-z-id-2.png"
                      alt="img" 
                ></p>
<p>通过这种方式明显的优势就是依赖于数据库自身不需要其他资源，并且ID号单调自增，可以实现一些对ID有特殊要求的业务。</p>
<p>但是缺点也很明显，首先它<strong>强依赖DB</strong>，当DB异常时整个系统不可用。虽然配置主从复制可以尽可能的增加可用性，但是<strong>数据一致性在特殊情况下难以保证</strong>。主从切换时的不一致可能会导致重复发号。还有就是<strong>ID发号性能瓶颈限制在单台MySQL的读写性能</strong>。</p>
]]></content>
      <categories>
        <category>分布式</category>
        <category>全局唯一ID</category>
      </categories>
      <tags>
        <tag>全局唯一ID</tag>
      </tags>
  </entry>
  <entry>
    <title>分布式唯一ID-百度UidGenerator</title>
    <url>/posts/b934b32c/</url>
    <content><![CDATA[<blockquote>
<p>百度的 <code>UidGenerator</code> 是百度开源基于Java语言实现的唯一ID生成器，是在雪花算法 snowflake 的基础上做了一些改进。<code>UidGenerator</code>以组件形式工作在应用项目中, 支持自定义workerId位数和初始化策略，适用于docker等虚拟化环境下实例自动重启、漂移等场景。</p>
</blockquote>
<p>在实现上，UidGenerator 提供了两种生成唯一ID方式，分别是 <code>DefaultUidGenerator</code> 和 <code>CachedUidGenerator</code>，官方建议如果有<strong>性能考虑</strong>的话使用 <code>CachedUidGenerator</code> 方式实现。</p>
<p><code>UidGenerator</code> 依然是以划分命名空间的方式将 64-bit位分割成多个部分，只不过它的默认划分方式有别于雪花算法 snowflake。它默认是由 <code>1-28-22-13</code> 的格式进行划分。可根据你的业务的情况和特点，自己调整各个字段占用的位数。</p>
<ul>
<li><strong>第1位</strong>仍然占用1bit，其值始终是0。</li>
<li><strong>第2位</strong>开始的28位是时间戳，28-bit位可表示2^28个数，这里不再是以毫秒而是以秒为单位，每个数代表秒则可用<code>（1L&lt;&lt;28）/ (360024365) ≈ 8.51</code> 年的时间。</li>
<li>中间的 workId （数据中心+工作机器，可以其他组成方式）则由 <strong>22-bit位</strong>组成，可表示 2^22 = 4194304个工作ID。</li>
<li>最后由<strong>13-bit位</strong>构成自增序列，可表示2^13 = 8192个数。</li>
</ul>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://pdai.tech/images/arch/arch-z-id-4.png"
                      alt="img" 
                ></p>
<p>其中 workId （机器 id），最多可支持约420w次机器启动。<strong>内置实现为在启动时由数据库分配（表名为 WORKER_NODE），默认分配策略为用后即弃，后续可提供复用策略</strong>。</p>
<div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">DROP</span> <span class="keyword">TABLE</span> IF <span class="keyword">EXISTS</span> WORKER_NODE;</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> WORKER_NODE</span><br><span class="line">(</span><br><span class="line">ID <span class="type">BIGINT</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span> AUTO_INCREMENT COMMENT <span class="string">&#x27;auto increment id&#x27;</span>,</span><br><span class="line">HOST_NAME <span class="type">VARCHAR</span>(<span class="number">64</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;host name&#x27;</span>,</span><br><span class="line">PORT <span class="type">VARCHAR</span>(<span class="number">64</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;port&#x27;</span>,</span><br><span class="line">TYPE <span class="type">INT</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;node type: ACTUAL or CONTAINER&#x27;</span>,</span><br><span class="line">LAUNCH_DATE <span class="type">DATE</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;launch date&#x27;</span>,</span><br><span class="line">MODIFIED <span class="type">TIMESTAMP</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;modified time&#x27;</span>,</span><br><span class="line">CREATED <span class="type">TIMESTAMP</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;created time&#x27;</span>,</span><br><span class="line"><span class="keyword">PRIMARY</span> KEY(ID)</span><br><span class="line">)</span><br><span class="line"> COMMENT<span class="operator">=</span><span class="string">&#x27;DB WorkerID Assigner for UID Generator&#x27;</span>,ENGINE <span class="operator">=</span> INNODB;</span><br></pre></td></tr></table></figure></div>
<h3 id="defaultuidgenerator-实现"><a class="markdownIt-Anchor" href="#defaultuidgenerator-实现"></a> DefaultUidGenerator 实现</h3>
<p><code>DefaultUidGenerator</code> 就是正常的根据时间戳和机器位还有序列号的生成方式，和雪花算法很相似，对于时钟回拨也只是抛异常处理。仅有一些不同，如<strong>以秒为为单位</strong>而不再是毫秒和支持Docker等虚拟化环境。</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">synchronized</span> <span class="type">long</span> <span class="title function_">nextId</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">long</span> <span class="variable">currentSecond</span> <span class="operator">=</span> getCurrentSecond();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Clock moved backwards, refuse to generate uid</span></span><br><span class="line">    <span class="keyword">if</span> (currentSecond &lt; lastSecond) &#123;</span><br><span class="line">        <span class="type">long</span> <span class="variable">refusedSeconds</span> <span class="operator">=</span> lastSecond - currentSecond;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">UidGenerateException</span>(<span class="string">&quot;Clock moved backwards. Refusing for %d seconds&quot;</span>, refusedSeconds);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// At the same second, increase sequence</span></span><br><span class="line">    <span class="keyword">if</span> (currentSecond == lastSecond) &#123;</span><br><span class="line">        sequence = (sequence + <span class="number">1</span>) &amp; bitsAllocator.getMaxSequence();</span><br><span class="line">        <span class="comment">// Exceed the max sequence, we wait the next second to generate uid</span></span><br><span class="line">        <span class="keyword">if</span> (sequence == <span class="number">0</span>) &#123;</span><br><span class="line">            currentSecond = getNextSecond(lastSecond);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// At the different second, sequence restart from zero</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        sequence = <span class="number">0L</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    lastSecond = currentSecond;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Allocate bits for UID</span></span><br><span class="line">    <span class="keyword">return</span> bitsAllocator.allocate(currentSecond - epochSeconds, workerId, sequence);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>如果你要使用 DefaultUidGenerator 的实现方式的话，以上划分的占用位数可通过 spring 进行参数配置。</p>
<div class="highlight-container" data-rel="Xml"><figure class="iseeu highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;defaultUidGenerator&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.baidu.fsg.uid.impl.DefaultUidGenerator&quot;</span> <span class="attr">lazy-init</span>=<span class="string">&quot;false&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;workerIdAssigner&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;disposableWorkerIdAssigner&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- Specified bits &amp; epoch as your demand. No specified the default value will be used --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;timeBits&quot;</span> <span class="attr">value</span>=<span class="string">&quot;29&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;workerBits&quot;</span> <span class="attr">value</span>=<span class="string">&quot;21&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;seqBits&quot;</span> <span class="attr">value</span>=<span class="string">&quot;13&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;epochStr&quot;</span> <span class="attr">value</span>=<span class="string">&quot;2016-09-20&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure></div>
<h3 id="cacheduidgenerator-实现"><a class="markdownIt-Anchor" href="#cacheduidgenerator-实现"></a> CachedUidGenerator 实现</h3>
<p>而官方建议的性能较高的 <code>CachedUidGenerator</code> 生成方式，是使用 RingBuffer 缓存生成的id。数组每个元素成为一个slot。RingBuffer容量，默认为Snowflake算法中sequence最大值（2^13 = 8192）。可通过 boostPower 配置进行扩容，以提高 RingBuffer 读写吞吐量。</p>
<p>Tail指针、Cursor指针用于环形数组上读写slot：</p>
<ul>
<li><strong>Tail指针</strong> 表示Producer生产的最大序号(此序号从0开始，持续递增)。Tail不能超过Cursor，即生产者不能覆盖未消费的slot。当Tail已赶上curosr，此时可通过rejectedPutBufferHandler指定PutRejectPolicy</li>
<li><strong>Cursor指针</strong> 表示Consumer消费到的最小序号(序号序列与Producer序列相同)。Cursor不能超过Tail，即不能消费未生产的slot。当Cursor已赶上tail，此时可通过rejectedTakeBufferHandler指定TakeRejectPolicy</li>
</ul>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://pdai.tech/images/arch/arch-z-id-5.png"
                      alt="img" 
                ></p>
<p>CachedUidGenerator采用了双RingBuffer，Uid-RingBuffer用于存储Uid、Flag-RingBuffer用于存储Uid状态(是否可填充、是否可消费)。</p>
<p>由于数组元素在内存中是连续分配的，可最大程度利用CPU cache以提升性能。但同时会带来「伪共享」FalseSharing问题，为此在Tail、Cursor指针、Flag-RingBuffer中采用了CacheLine 补齐方式。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://pdai.tech/images/arch/arch-z-id-6.png"
                      alt="img" 
                ></p>
<p><strong>RingBuffer填充时机</strong></p>
<ul>
<li><strong>初始化预填充</strong> RingBuffer初始化时，预先填充满整个RingBuffer。</li>
<li><strong>即时填充</strong> Take消费时，即时检查剩余可用slot量(tail - cursor)，如小于设定阈值，则补全空闲slots。阈值可通过paddingFactor来进行配置，请参考Quick Start中CachedUidGenerator配置。</li>
<li><strong>周期填充</strong> 通过Schedule线程，定时补全空闲slots。可通过scheduleInterval配置，以应用定时填充功能，并指定Schedule时间间隔。</li>
</ul>
]]></content>
      <categories>
        <category>分布式</category>
        <category>全局唯一ID</category>
      </categories>
      <tags>
        <tag>全局唯一ID</tag>
      </tags>
  </entry>
  <entry>
    <title>分布式唯一ID-雪花算法</title>
    <url>/posts/95e5d6b3/</url>
    <content><![CDATA[<p>Snowflake，<span style="border-bottom: 2px solid green">雪花算法是由Twitter开源的分布式ID生成算法，以划分命名空间的方式将 64-bit位分割成多个部分，每个部分代表不同的含义。而 Java中64bit的整数是Long类型，所以在 Java 中 SnowFlake 算法生成的 ID 就是 long 来存储的。</span></p>
<ul>
<li><strong>第1位</strong>占用1bit，其值始终是0，可看做是符号位不使用。</li>
<li><strong>第2位</strong>开始的41位是时间戳，41-bit位可表示2^41个数，每个数代表毫秒，那么雪花算法可用的时间年限是<code>(1L&lt;&lt;41)/(1000L360024*365)</code>=69 年的时间。</li>
<li><strong>中间的10-bit位</strong>可表示机器数，即2^10 = 1024台机器，但是一般情况下我们不会部署这么台机器。如果我们对IDC（互联网数据中心）有需求，还可以将 10-bit 分 5-bit 给 IDC，分5-bit给工作机器。这样就可以表示32个IDC，每个IDC下可以有32台机器，具体的划分可以根据自身需求定义。</li>
<li><strong>最后12-bit位</strong>是自增序列，可表示2^12 = 4096个数。</li>
</ul>
<p>这样的划分之后相当于<strong>在一毫秒一个数据中心的一台机器上可产生4096个有序的不重复的ID</strong>。但是我们 IDC 和机器数肯定不止一个，所以毫秒内能生成的有序ID数是翻倍的。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://pdai.tech/images/arch/arch-z-id-3.png"
                      alt="img" 
                ></p>
<p>Snowflake 的Twitter官方原版是用Scala写的，对Scala语言有研究的同学可以去阅读下，以下是 Java 版本的写法。</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Twitter_Snowflake&lt;br&gt;</span></span><br><span class="line"><span class="comment"> * SnowFlake的结构如下(每部分用-分开):&lt;br&gt;</span></span><br><span class="line"><span class="comment"> * 0 - 0000000000 0000000000 0000000000 0000000000 0 - 00000 - 00000 - 000000000000 &lt;br&gt;</span></span><br><span class="line"><span class="comment"> * 1位标识，由于long基本类型在Java中是带符号的，最高位是符号位，正数是0，负数是1，所以id一般是正数，最高位是0&lt;br&gt;</span></span><br><span class="line"><span class="comment"> * 41位时间截(毫秒级)，注意，41位时间截不是存储当前时间的时间截，而是存储时间截的差值（当前时间截 - 开始时间截)</span></span><br><span class="line"><span class="comment"> * 得到的值），这里的的开始时间截，一般是我们的id生成器开始使用的时间，由我们程序来指定的（如下下面程序IdWorker类的startTime属性）。41位的时间截，可以使用69年，年T = (1L &lt;&lt; 41) / (1000L * 60 * 60 * 24 * 365) = 69&lt;br&gt;</span></span><br><span class="line"><span class="comment"> * 10位的数据机器位，可以部署在1024个节点，包括5位datacenterId和5位workerId&lt;br&gt;</span></span><br><span class="line"><span class="comment"> * 12位序列，毫秒内的计数，12位的计数顺序号支持每个节点每毫秒(同一机器，同一时间截)产生4096个ID序号&lt;br&gt;</span></span><br><span class="line"><span class="comment"> * 加起来刚好64位，为一个Long型。&lt;br&gt;</span></span><br><span class="line"><span class="comment"> * SnowFlake的优点是，整体上按照时间自增排序，并且整个分布式系统内不会产生ID碰撞(由数据中心ID和机器ID作区分)，并且效率较高，经测试，SnowFlake每秒能够产生26万ID左右。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SnowflakeDistributeId</span> &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// ==============================Fields===========================================</span></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 开始时间截 (2015-01-01)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">twepoch</span> <span class="operator">=</span> <span class="number">1420041600000L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 机器id所占的位数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">workerIdBits</span> <span class="operator">=</span> <span class="number">5L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 数据标识id所占的位数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">datacenterIdBits</span> <span class="operator">=</span> <span class="number">5L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 支持的最大机器id，结果是31 (这个移位算法可以很快的计算出几位二进制数所能表示的最大十进制数)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">maxWorkerId</span> <span class="operator">=</span> -<span class="number">1L</span> ^ (-<span class="number">1L</span> &lt;&lt; workerIdBits);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 支持的最大数据标识id，结果是31</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">maxDatacenterId</span> <span class="operator">=</span> -<span class="number">1L</span> ^ (-<span class="number">1L</span> &lt;&lt; datacenterIdBits);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 序列在id中占的位数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">sequenceBits</span> <span class="operator">=</span> <span class="number">12L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 机器ID向左移12位</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">workerIdShift</span> <span class="operator">=</span> sequenceBits;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 数据标识id向左移17位(12+5)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">datacenterIdShift</span> <span class="operator">=</span> sequenceBits + workerIdBits;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 时间截向左移22位(5+5+12)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">timestampLeftShift</span> <span class="operator">=</span> sequenceBits + workerIdBits + datacenterIdBits;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 生成序列的掩码，这里为4095 (0b111111111111=0xfff=4095)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">sequenceMask</span> <span class="operator">=</span> -<span class="number">1L</span> ^ (-<span class="number">1L</span> &lt;&lt; sequenceBits);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 工作机器ID(0~31)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">long</span> workerId;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 数据中心ID(0~31)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">long</span> datacenterId;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 毫秒内序列(0~4095)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">long</span> <span class="variable">sequence</span> <span class="operator">=</span> <span class="number">0L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 上次生成ID的时间截</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">long</span> <span class="variable">lastTimestamp</span> <span class="operator">=</span> -<span class="number">1L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//==============================Constructors=====================================</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 构造函数</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> workerId     工作ID (0~31)</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> datacenterId 数据中心ID (0~31)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">SnowflakeDistributeId</span><span class="params">(<span class="type">long</span> workerId, <span class="type">long</span> datacenterId)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (workerId &gt; maxWorkerId || workerId &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(String.format(<span class="string">&quot;worker Id can&#x27;t be greater than %d or less than 0&quot;</span>, maxWorkerId));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (datacenterId &gt; maxDatacenterId || datacenterId &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(String.format(<span class="string">&quot;datacenter Id can&#x27;t be greater than %d or less than 0&quot;</span>, maxDatacenterId));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">this</span>.workerId = workerId;</span><br><span class="line">        <span class="built_in">this</span>.datacenterId = datacenterId;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ==============================Methods==========================================</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获得下一个ID (该方法是线程安全的)</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> SnowflakeId</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="type">long</span> <span class="title function_">nextId</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">long</span> <span class="variable">timestamp</span> <span class="operator">=</span> timeGen();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//如果当前时间小于上一次ID生成的时间戳，说明系统时钟回退过这个时候应当抛出异常</span></span><br><span class="line">        <span class="keyword">if</span> (timestamp &lt; lastTimestamp) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(</span><br><span class="line">                    String.format(<span class="string">&quot;Clock moved backwards.  Refusing to generate id for %d milliseconds&quot;</span>, lastTimestamp - timestamp));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//如果是同一时间生成的，则进行毫秒内序列</span></span><br><span class="line">        <span class="keyword">if</span> (lastTimestamp == timestamp) &#123;</span><br><span class="line">            sequence = (sequence + <span class="number">1</span>) &amp; sequenceMask;</span><br><span class="line">            <span class="comment">//毫秒内序列溢出</span></span><br><span class="line">            <span class="keyword">if</span> (sequence == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">//阻塞到下一个毫秒,获得新的时间戳</span></span><br><span class="line">                timestamp = tilNextMillis(lastTimestamp);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//时间戳改变，毫秒内序列重置</span></span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            sequence = <span class="number">0L</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//上次生成ID的时间截</span></span><br><span class="line">        lastTimestamp = timestamp;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//移位并通过或运算拼到一起组成64位的ID</span></span><br><span class="line">        <span class="keyword">return</span> ((timestamp - twepoch) &lt;&lt; timestampLeftShift) <span class="comment">//</span></span><br><span class="line">                | (datacenterId &lt;&lt; datacenterIdShift) <span class="comment">//</span></span><br><span class="line">                | (workerId &lt;&lt; workerIdShift) <span class="comment">//</span></span><br><span class="line">                | sequence;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 阻塞到下一个毫秒，直到获得新的时间戳</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> lastTimestamp 上次生成ID的时间截</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 当前时间戳</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="type">long</span> <span class="title function_">tilNextMillis</span><span class="params">(<span class="type">long</span> lastTimestamp)</span> &#123;</span><br><span class="line">        <span class="type">long</span> <span class="variable">timestamp</span> <span class="operator">=</span> timeGen();</span><br><span class="line">        <span class="keyword">while</span> (timestamp &lt;= lastTimestamp) &#123;</span><br><span class="line">            timestamp = timeGen();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> timestamp;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 返回以毫秒为单位的当前时间</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 当前时间(毫秒)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="type">long</span> <span class="title function_">timeGen</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> System.currentTimeMillis();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>测试的代码如下</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">SnowflakeDistributeId</span> <span class="variable">idWorker</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SnowflakeDistributeId</span>(<span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++) &#123;</span><br><span class="line">        <span class="type">long</span> <span class="variable">id</span> <span class="operator">=</span> idWorker.nextId();</span><br><span class="line"><span class="comment">//      System.out.println(Long.toBinaryString(id));</span></span><br><span class="line">        System.out.println(id);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p><strong>雪花算法提供了一个很好的设计思想，雪花算法生成的ID是趋势递增，不依赖数据库等第三方系统，以服务的方式部署，稳定性更高，生成ID的性能也是非常高的，而且可以根据自身业务特性分配bit位，非常灵活</strong>。</p>
<p>但是雪花算法强<strong>依赖机器时钟</strong>，如果机器上时钟回拨，会导致发号重复或者服务会处于不可用状态。如果恰巧回退前生成过一些ID，而时间回退后，生成的ID就有可能重复。官方对于此并没有给出解决方案，而是简单的抛错处理，这样会造成在时间被追回之前的这段时间服务不可用。</p>
<p>很多其他类雪花算法也是在此思想上的设计然后改进规避它的缺陷，后面介绍的<code>百度 UidGenerator</code> 和 <code>美团分布式ID生成系统 Leaf</code> 中snowflake模式都是在 snowflake 的基础上演进出来的。</p>
]]></content>
      <categories>
        <category>分布式</category>
        <category>全局唯一ID</category>
      </categories>
      <tags>
        <tag>全局唯一ID</tag>
      </tags>
  </entry>
  <entry>
    <title>分布式唯一ID-美团Leaf</title>
    <url>/posts/714dc0c3/</url>
    <content><![CDATA[<blockquote>
<p>Leaf是美团基础研发平台推出的一个分布式ID生成服务，名字取自德国哲学家、数学家莱布尼茨的著名的一句话：“There are no two identical leaves in the world”，世间不可能存在两片相同的叶子。</p>
</blockquote>
<p>Leaf 也提供了两种ID生成的方式，分别是 <code>Leaf-segment 数据库方案</code>和 <code>Leaf-snowflake 方案</code>。</p>
<h3 id="leaf-segment-数据库方案"><a class="markdownIt-Anchor" href="#leaf-segment-数据库方案"></a> Leaf-segment 数据库方案</h3>
<p>Leaf-segment 数据库方案，是在上文描述的在使用数据库的方案上，做了如下改变：</p>
<ul>
<li>原方案每次获取ID都得读写一次数据库，造成数据库压力大。改为利用proxy server批量获取，每次获取一个segment(step决定大小)号段的值。用完之后再去数据库获取新的号段，可以大大的减轻数据库的压力。</li>
<li>各个业务不同的发号需求用 <code>biz_tag</code>字段来区分，每个biz-tag的ID获取相互隔离，互不影响。如果以后有性能需求需要对数据库扩容，不需要上述描述的复杂的扩容操作，只需要对biz_tag分库分表就行。</li>
</ul>
<p>数据库表设计如下：</p>
<div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `leaf_alloc` (</span><br><span class="line">  `biz_tag` <span class="type">varchar</span>(<span class="number">128</span>)  <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="string">&#x27;&#x27;</span> COMMENT <span class="string">&#x27;业务key&#x27;</span>,</span><br><span class="line">  `max_id` <span class="type">bigint</span>(<span class="number">20</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="string">&#x27;1&#x27;</span> COMMENT <span class="string">&#x27;当前已经分配了的最大id&#x27;</span>,</span><br><span class="line">  `step` <span class="type">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;初始步长，也是动态调整的最小步长&#x27;</span>,</span><br><span class="line">  `description` <span class="type">varchar</span>(<span class="number">256</span>)  <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;业务key的描述&#x27;</span>,</span><br><span class="line">  `update_time` <span class="type">timestamp</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="built_in">CURRENT_TIMESTAMP</span> <span class="keyword">ON</span> <span class="keyword">UPDATE</span> <span class="built_in">CURRENT_TIMESTAMP</span> COMMENT <span class="string">&#x27;更新时间&#x27;</span>,</span><br><span class="line">  <span class="keyword">PRIMARY</span> KEY (`biz_tag`)</span><br><span class="line">) ENGINE<span class="operator">=</span>InnoDB;</span><br></pre></td></tr></table></figure></div>
<p>原来获取ID每次都需要写数据库，现在只需要把step设置得足够大，比如1000。那么只有当1000个号被消耗完了之后才会去重新读写一次数据库。读写数据库的频率从1减小到了1/step，大致架构如下图所示：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://pdai.tech/images/arch/arch-z-id-7.png"
                      alt="img" 
                ></p>
<p>同时Leaf-segment 为了解决 TP999（满足千分之九百九十九的网络请求所需要的最低耗时）数据波动大，当号段使用完之后还是会hang在更新数据库的I/O上，TP999 数据会出现偶尔的尖刺的问题，提供了双buffer优化。</p>
<p>简单的说就是，Leaf 取号段的时机是在号段消耗完的时候进行的，也就意味着号段临界点的ID下发时间取决于下一次从DB取回号段的时间，并且在这期间进来的请求也会因为DB号段没有取回来，导致线程阻塞。如果请求DB的网络和DB的性能稳定，这种情况对系统的影响是不大的，但是假如取DB的时候网络发生抖动，或者DB发生慢查询就会导致整个系统的响应时间变慢。</p>
<p>为了DB取号段的过程能够做到无阻塞，不需要在DB取号段的时候阻塞请求线程，即当号段消费到某个点时就异步的把下一个号段加载到内存中，而不需要等到号段用尽的时候才去更新号段。这样做就可以很大程度上的降低系统的 TP999 指标。详细实现如下图所示：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://pdai.tech/images/arch/arch-z-id-8.png"
                      alt="img" 
                ></p>
<p>采用双buffer的方式，Leaf服务内部有两个号段缓存区segment。当前号段已下发10%时，如果下一个号段未更新，则另启一个更新线程去更新下一个号段。当前号段全部下发完后，如果下个号段准备好了则切换到下个号段为当前segment接着下发，循环往复。</p>
<ul>
<li>每个biz-tag都有消费速度监控，通常推荐segment长度设置为服务高峰期发号QPS的600倍（10分钟），这样即使DB宕机，Leaf仍能持续发号10-20分钟不受影响。</li>
<li>每次请求来临时都会判断下个号段的状态，从而更新此号段，所以偶尔的网络抖动不会影响下个号段的更新。</li>
</ul>
<p>对于这种方案依然存在一些问题，它<strong>仍然依赖 DB的稳定性，需要采用主从备份的方式提高 DB的可用性</strong>，还有 Leaf-segment方案生成的ID是趋势递增的，这样ID号是可被计算的，例如订单ID生成场景，<strong>通过订单id号相减就能大致计算出公司一天的订单量，这个是不能忍受的</strong>。</p>
<h3 id="leaf-snowflake方案"><a class="markdownIt-Anchor" href="#leaf-snowflake方案"></a> Leaf-snowflake方案</h3>
<p>Leaf-snowflake方案完全沿用 snowflake 方案的bit位设计，对于workerID的分配引入了Zookeeper持久顺序节点的特性自动对snowflake节点配置 wokerID。避免了服务规模较大时，动手配置成本太高的问题。</p>
<p>Leaf-snowflake是按照下面几个步骤启动的：</p>
<ul>
<li>启动Leaf-snowflake服务，连接Zookeeper，在leaf_forever父节点下检查自己是否已经注册过（是否有该顺序子节点）。</li>
<li>如果有注册过直接取回自己的workerID（zk顺序节点生成的int类型ID号），启动服务。</li>
<li>如果没有注册过，就在该父节点下面创建一个持久顺序节点，创建成功后取回顺序号当做自己的workerID号，启动服务。</li>
</ul>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://pdai.tech/images/arch/arch-z-id-9.png"
                      alt="img" 
                ></p>
<p>为了减少对 Zookeeper的依赖性，会在本机文件系统上缓存一个workerID文件。当ZooKeeper出现问题，恰好机器出现问题需要重启时，能保证服务能够正常启动。</p>
<p>上文阐述过在类 snowflake算法上都存在时钟回拨的问题，Leaf-snowflake在解决时钟回拨的问题上是通过校验自身系统时间与 <code>leaf_forever/$&#123;self&#125;</code>节点记录时间做比较然后启动报警的措施。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://pdai.tech/images/arch/arch-z-id-10.png"
                      alt="img" 
                ></p>
<p>美团官方建议是由于强依赖时钟，对时间的要求比较敏感，<strong>在机器工作时NTP同步也会造成秒级别的回退，建议可以直接关闭NTP同步。要么在时钟回拨的时候直接不提供服务直接返回ERROR_CODE，等时钟追上即可。或者做一层重试，然后上报报警系统，更或者是发现有时钟回拨之后自动摘除本身节点并报警。</strong></p>
<p>在性能上官方提供的数据目前 Leaf 的性能在4C8G 的机器上QPS能压测到近5w/s，TP999 1ms。</p>
]]></content>
      <categories>
        <category>分布式</category>
        <category>全局唯一ID</category>
      </categories>
      <tags>
        <tag>全局唯一ID</tag>
      </tags>
  </entry>
  <entry>
    <title>分布式唯一ID-数据库生成</title>
    <url>/posts/63cd793d/</url>
    <content><![CDATA[<p>Redis实现分布式唯一ID主要是通过提供像 <code>INCR</code> 和 <code>INCRBY</code> 这样的自增原子命令，由于Redis自身的单线程的特点所以能保证生成的 ID 肯定是唯一有序的。</p>
<p>但是单机存在性能瓶颈，无法满足高并发的业务需求，所以可以采用集群的方式来实现。集群的方式又会涉及到和数据库集群同样的问题，所以也需要设置分段和步长来实现。</p>
<p>为了避免长期自增后数字过大可以通过与当前时间戳组合起来使用，另外为了保证并发和业务多线程的问题可以采用<span style="border-bottom: 2px solid yellow"> Redis + Lua </span>的方式进行编码，保证安全。</p>
<p>Redis 实现分布式全局唯一ID，它的性能比较高，生成的数据是有序的，对排序业务有利，但是同样它依赖于redis，<strong>需要系统引进redis组件，增加了系统的配置复杂性</strong>。</p>
<p>当然现在Redis的使用性很普遍，所以如果其他业务已经引进了Redis集群，则可以资源利用考虑使用Redis来实现。</p>
]]></content>
      <categories>
        <category>分布式</category>
        <category>全局唯一ID</category>
      </categories>
      <tags>
        <tag>全局唯一ID</tag>
      </tags>
  </entry>
  <entry>
    <title>分布式全局唯一ID</title>
    <url>/posts/21c5149c/</url>
    <content><![CDATA[<blockquote>
<p>本文主要介绍常见的分布式ID生成方式，大致分类的话可以分为两类：<strong>一种是类DB型的</strong>，根据设置不同起始值和步长来实现趋势递增，需要考虑服务的容错性和可用性; <strong>另一种是类snowflake型</strong>，这种就是将64位划分为不同的段，每段代表不同的涵义，基本就是时间戳、机器ID和序列数。这种方案就是需要考虑时钟回拨的问题以及做一些 buffer 的缓冲设计提高性能。</p>
</blockquote>
<h2 id="全局唯一id"><a class="markdownIt-Anchor" href="#全局唯一id"></a> 全局唯一ID</h2>
<p>传统的单体架构的时候，我们基本是单库然后业务单表的结构。每个业务表的ID一般我们都是从1增，通过AUTO_INCREMENT=1设置自增起始值，但是在分布式服务架构模式下分库分表的设计，使得多个库或多个表存储相同的业务数据。这种情况根据数据库的自增ID就会产生相同ID的情况，不能保证主键的唯一性。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://pdai.tech/images/arch/arch-z-id-1.png"
                      alt="img" 
                ></p>
<p>如上图，如果第一个订单存储在 DB1 上则订单 ID 为1，当一个新订单又入库了存储在 DB2 上订单 ID 也为1。我们系统的架构虽然是分布式的，但是在用户层应是无感知的，重复的订单主键显而易见是不被允许的。那么针对分布式系统如何做到主键唯一性呢？</p>
<div class="note-large notel-green"><div class="notel-title"><p>方案</p>
</div><div class="notel-content"><ul>
<li>UUID</li>
<li>数据库</li>
<li>Redis</li>
<li>雪花算法</li>
<li>百度-uidgenerator</li>
<li>美团-Leaf</li>
</ul>
 </div></div>
]]></content>
      <categories>
        <category>分布式</category>
        <category>全局唯一ID</category>
      </categories>
      <tags>
        <tag>全局唯一ID</tag>
      </tags>
  </entry>
  <entry>
    <title>Nacos 作为配置中心 - springboot</title>
    <url>/posts/8625c51c/</url>
    <content><![CDATA[<p>本文将介绍如何在 Springboot 项目中使用Nacos作为配置中心，进行动态配置管理。在此前提下，我们需要先安装Nacos Server，可参考官方文档 <a class="link"   href="https://nacos.io/zh-cn/docs/quick-start.html" >Quick Start <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>。</p>
<h2 id="准备工作"><a class="markdownIt-Anchor" href="#准备工作"></a> 准备工作</h2>
<p>在开始之前，需要完成以下准备工作：</p>
<ol>
<li>安装并启动 Nacos Server。</li>
<li>创建一个 Spring Boot 项目。</li>
<li>添加必要的依赖：<code>spring-cloud-starter-alibaba-nacos-config</code>。</li>
</ol>
<h2 id="添加依赖"><a class="markdownIt-Anchor" href="#添加依赖"></a> 添加依赖</h2>
<p>在 <code>pom.xml</code> 中添加以下依赖：</p>
<div class="highlight-container" data-rel="Xml"><figure class="iseeu highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-alibaba-nacos-config<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;nacos.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></div>
<h2 id="配置文件"><a class="markdownIt-Anchor" href="#配置文件"></a> 配置文件</h2>
<p>在 <code>bootstrap.yml</code> 中添加以下配置：</p>
<div class="highlight-container" data-rel="Yaml"><figure class="iseeu highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">profiles:</span></span><br><span class="line">    <span class="attr">active:</span> <span class="string">dev</span> <span class="comment"># 激活的 profile</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">nacos:</span></span><br><span class="line">      <span class="attr">config:</span></span><br><span class="line">        <span class="attr">server-addr:</span> <span class="string">localhost:8848</span> <span class="comment"># Nacos Server 地址</span></span><br><span class="line">        <span class="attr">namespace:</span> <span class="comment"># 命名空间，可选</span></span><br><span class="line">        <span class="attr">group:</span> <span class="string">DEFAULT_GROUP</span> <span class="comment"># 分组，默认为 DEFAULT_GROUP</span></span><br><span class="line">        <span class="attr">prefix:</span> <span class="string">demo-config</span> <span class="comment"># 配置文件前缀</span></span><br><span class="line">        <span class="attr">file-extension:</span> <span class="string">yml</span> <span class="comment"># 配置文件扩展名，可选</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用 optional 属性配置不同类型和环境的配置文件</span></span><br><span class="line">  <span class="attr">config:</span></span><br><span class="line">    <span class="attr">import:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">optional:nacos:$&#123;spring.cloud.nacos.config.prefix&#125;.$&#123;spring.profiles.active&#125;.$&#123;spring.cloud.nacos.config.file-extension&#125;</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">optional:nacos:$&#123;spring.cloud.nacos.config.prefix&#125;.$&#123;spring.cloud.nacos.config.file-extension&#125;</span></span><br></pre></td></tr></table></figure></div>
<p>在这个示例中，使用 <code>spring.config.import</code> 属性的 <code>optional</code> 属性来加载不同类型和环境的配置文件（指定 nacos 的 DataId）。<code>$&#123;spring.cloud.nacos.config.prefix&#125;</code> 表示从 Nacos 中加载的配置文件的前缀，<code>$&#123;spring.profiles.active&#125;</code> 表示当前激活的 profile，<code>$&#123;spring.cloud.nacos.config.file-extension&#125;</code> 表示配置文件的扩展名。</p>
<p>首先，它会尝试加载 <code>demo-config.dev.yml</code>，如果找不到，则尝试加载 <code>demo-config.yml</code>。</p>
<h2 id="配置中心"><a class="markdownIt-Anchor" href="#配置中心"></a> 配置中心</h2>
<p>在 Nacos 控制台中创建一个名为 <code>demo-config.yml</code> 和 <code>demo-config.dev.yml</code> 的配置文件，并添加以下内容：</p>
<p><strong>demo-config.yml</strong></p>
<div class="highlight-container" data-rel="Yaml"><figure class="iseeu highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">name:</span> <span class="string">LoveHeer</span></span><br></pre></td></tr></table></figure></div>
<p><strong>demo-config.dev.yml</strong></p>
<div class="highlight-container" data-rel="Yaml"><figure class="iseeu highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">name:</span> <span class="string">dev-LoveHeer</span></span><br></pre></td></tr></table></figure></div>
<h2 id="编写代码"><a class="markdownIt-Anchor" href="#编写代码"></a> 编写代码</h2>
<p>创建一个 <code>DemoController</code>，并添加以下代码：</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DemoController</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;name&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/hello&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">hello</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Hello, &quot;</span> + name + <span class="string">&quot;!&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>这段代码读取了一个名为 <code>name</code> 的配置，并将其注入到 <code>DemoController</code> 中。</p>
<div class="note note-warning icon-padding"><i class="note-icon fa-solid fa-exclamation-circle"></i><p>如要实现动态刷新，需要在<code>DemoController</code>上添加 <code>@RefreshScope</code> 注解</p>
</div>
<h2 id="运行应用程序"><a class="markdownIt-Anchor" href="#运行应用程序"></a> 运行应用程序</h2>
<p>现在，我们可以运行 Spring Boot 应用程序并访问 <code>/hello</code> 端点。如果一切顺利，您将看到以下输出：</p>
<div class="highlight-container" data-rel="Html"><figure class="iseeu highlight html"><table><tr><td class="code"><pre><span class="line">Hello, dev-LoveHeer!</span><br></pre></td></tr></table></figure></div>
<h2 id="总结"><a class="markdownIt-Anchor" href="#总结"></a> 总结</h2>
]]></content>
      <categories>
        <category>Nacos</category>
        <category>使用示例</category>
      </categories>
      <tags>
        <tag>Nacos</tag>
      </tags>
  </entry>
  <entry>
    <title>分布式-UUID</title>
    <url>/posts/874292de/</url>
    <content><![CDATA[<p><code>UUID （Universally Unique Identifier）</code>，通用唯一识别码的缩写。UUID是由一组32位数的16进制数字所构成，所以UUID理论上的总数为 <code>16^32=2^128</code>，约等于 <code>3.4 x 10^38</code>。也就是说若每纳秒产生1兆个UUID，要花100亿年才会将所有UUID用完。</p>
<p>生成的UUID是由 8-4-4-4-12格式的数据组成，其中32个字符和4个连字符’ - '，一般我们使用的时候会将连字符删除 uuid.<code>toString().replaceAll(&quot;-&quot;,&quot;&quot;)</code>。</p>
<p>目前UUID的产生方式有5种版本，每个版本的算法不同，应用范围也不同。</p>
<ul>
<li><code>基于时间的UUID</code> - 版本1： 这个一般是通过当前时间，随机数，和本地Mac地址来计算出来，可以通过 org.apache.logging.log4j.core.util包中的 UuidUtil.getTimeBasedUuid()来使用或者其他包中工具。由于使用了MAC地址，因此能够确保唯一性，但是同时也暴露了MAC地址，私密性不够好。</li>
<li><code>DCE安全的UUID</code> - 版本2 DCE（Distributed Computing Environment）安全的UUID和基于时间的UUID算法相同，但会把时间戳的前4位置换为POSIX的UID或GID。这个版本的UUID在实际中较少用到。</li>
<li><code>基于名字的UUID（MD5）</code>- 版本3 基于名字的UUID通过计算名字和名字空间的MD5散列值得到。这个版本的UUID保证了：相同名字空间中不同名字生成的UUID的唯一性；不同名字空间中的UUID的唯一性；相同名字空间中相同名字的UUID重复生成是相同的。</li>
<li><code>随机UUID</code> - 版本4 根据随机数，或者伪随机数生成UUID。这种UUID产生重复的概率是可以计算出来的，但是重复的可能性可以忽略不计，因此该版本也是被经常使用的版本。JDK中使用的就是这个版本。</li>
<li><code>基于名字的UUID（SHA1）</code> - 版本5 和基于名字的UUID算法类似，只是散列值计算使用SHA1（Secure Hash Algorithm 1）算法。</li>
</ul>
<p>我们 Java中 JDK自带的 UUID产生方式就是版本4根据随机数生成的 UUID 和版本3基于名字的 UUID，有兴趣的可以去看看它的源码。</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取一个版本4根据随机字节数组的UUID。</span></span><br><span class="line">    <span class="type">UUID</span> <span class="variable">uuid</span> <span class="operator">=</span> UUID.randomUUID();</span><br><span class="line">    System.out.println(uuid.toString().replaceAll(<span class="string">&quot;-&quot;</span>,<span class="string">&quot;&quot;</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取一个版本3(基于名称)根据指定的字节数组的UUID。</span></span><br><span class="line">    <span class="type">byte</span>[] nbyte = &#123;<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>&#125;;</span><br><span class="line">    <span class="type">UUID</span> <span class="variable">uuidFromBytes</span> <span class="operator">=</span> UUID.nameUUIDFromBytes(nbyte);</span><br><span class="line">    System.out.println(uuidFromBytes.toString().replaceAll(<span class="string">&quot;-&quot;</span>,<span class="string">&quot;&quot;</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>得到的UUID结果，</p>
<div class="highlight-container" data-rel="Console"><figure class="iseeu highlight console"><table><tr><td class="code"><pre><span class="line">59f51e7ea5ca453bbfaf2c1579f09f1d</span><br><span class="line">7f49b84d0bbc38e9a493718013baace6</span><br></pre></td></tr></table></figure></div>
<p>虽然 UUID 生成方便，本地生成没有网络消耗，但是使用起来也有一些缺点，</p>
<ul>
<li><strong>不易于存储</strong>：UUID太长，16字节128位，通常以36长度的字符串表示，很多场景不适用。</li>
<li><strong>信息不安全</strong>：基于MAC地址生成UUID的算法可能会造成MAC地址泄露，暴露使用者的位置。</li>
<li><strong>对MySQL索引不利</strong>：如果作为数据库主键，在InnoDB引擎下，UUID的无序性可能会引起数据位置频繁变动，严重影响性能，可以查阅 Mysql 索引原理 B+树的知识。</li>
</ul>
]]></content>
      <categories>
        <category>分布式</category>
        <category>全局唯一ID</category>
      </categories>
      <tags>
        <tag>全局唯一ID</tag>
      </tags>
  </entry>
  <entry>
    <title>Nacos 服务注册中心-Springcloud</title>
    <url>/posts/e4410d9d/</url>
    <content><![CDATA[<p><a class="link"   href="https://nacos.io/" >Nacos <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a> 是一个开源的动态服务发现、配置管理和服务管理平台。在这篇博文中，使用 Nacos 作为 Spring Boot 的注册中心，并通过 Java 示例来演示。</p>
<h2 id="准备工作"><a class="markdownIt-Anchor" href="#准备工作"></a> 准备工作</h2>
<p>在开始之前，需要完成以下准备工作：</p>
<ol>
<li>安装并启动 Nacos Server。</li>
<li>创建一个 Spring Boot 项目。</li>
<li>添加必要的依赖：<code>spring-cloud-starter-alibaba-nacos-discovery</code>。</li>
</ol>
<h2 id="添加依赖"><a class="markdownIt-Anchor" href="#添加依赖"></a> 添加依赖</h2>
<p>在 <code>pom.xml</code> 中添加以下依赖：</p>
<div class="highlight-container" data-rel="Xml"><figure class="iseeu highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-alibaba-nacos-discovery<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;nacos.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></div>
<h2 id="配置服务"><a class="markdownIt-Anchor" href="#配置服务"></a> 配置服务</h2>
<p>在 <code>application.yml</code> 中添加以下配置：</p>
<div class="highlight-container" data-rel="Yaml"><figure class="iseeu highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">8080</span> <span class="comment"># 应用程序端口</span></span><br><span class="line"></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">demo</span> <span class="comment"># 应用名称</span></span><br><span class="line"></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">nacos:</span></span><br><span class="line">      <span class="attr">discovery:</span></span><br><span class="line">        <span class="attr">server-addr:</span> <span class="string">localhost:8848</span> <span class="comment"># Nacos Server 地址</span></span><br></pre></td></tr></table></figure></div>
<p>这段代码配置了应用程序的端口和名称，并将 Nacos Server 的地址设置为服务发现的地址。</p>
<h2 id="注册服务"><a class="markdownIt-Anchor" href="#注册服务"></a> 注册服务</h2>
<p>创建一个 <code>DemoApplication</code>，并添加以下代码：</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@EnableDiscoveryClient</span> <span class="comment">// 开启服务注册和发现功能</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DemoApplication</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        SpringApplication.run(DemoApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>这段代码使用 <code>@EnableDiscoveryClient</code> 注解开启服务注册和发现功能。</p>
<h2 id="发布服务"><a class="markdownIt-Anchor" href="#发布服务"></a> 发布服务</h2>
<p>创建一个 <code>DemoController</code>，并添加以下代码：</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DemoController</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/hello&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">hello</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Hello, world!&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>这段代码创建了一个 <code>/hello</code> 端点，并返回 “Hello, world!”。</p>
<h2 id="运行应用程序"><a class="markdownIt-Anchor" href="#运行应用程序"></a> 运行应用程序</h2>
<p>现在，我们可以运行 Spring Boot 应用程序，并访问 <code>/hello</code> 端点。如果一切顺利，您将看到以下输出：</p>
<div class="highlight-container" data-rel="Html"><figure class="iseeu highlight html"><table><tr><td class="code"><pre><span class="line">Hello, world!</span><br></pre></td></tr></table></figure></div>
<h2 id="查看注册中心"><a class="markdownIt-Anchor" href="#查看注册中心"></a> 查看注册中心</h2>
<p>在 <code>Nacos 控制台</code>的服务列表中，您应该会看到一个名为 <code>demo</code> 的服务已经成功注册。</p>
<h2 id="总结"><a class="markdownIt-Anchor" href="#总结"></a> 总结</h2>
<p>在本文中，我们学习了如何使用 Nacos 作为 Spring Boot 的注册中心，并通过 Java 示例来演示。希望这篇文章对您有所帮助！</p>
]]></content>
      <categories>
        <category>Nacos</category>
        <category>使用示例</category>
      </categories>
      <tags>
        <tag>Nacos</tag>
      </tags>
  </entry>
  <entry>
    <title>Nacos 概念</title>
    <url>/posts/68e0beb6/</url>
    <content><![CDATA[<p>Nacos 引入了一些基本的概念，系统性的了解一下这些概念可以帮助您更好的理解和正确的使用 Nacos 产品。</p>
<div class="note note-warning icon-padding"><i class="note-icon fa-solid fa-exclamation-circle"></i><p>内容摘抄自<a class="link"   href="https://nacos.io/zh-cn/docs/v2/quickstart/quick-start.html" >Nacos官方文档 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>，可以点击链接移步官方文档</p>
</div>
<h2 id="地域"><a class="markdownIt-Anchor" href="#地域"></a> 地域</h2>
<p>物理的数据中心，资源创建成功后不能更换。</p>
<h2 id="可用区"><a class="markdownIt-Anchor" href="#可用区"></a> 可用区</h2>
<p>同一地域内，电力和网络互相独立的物理区域。同一可用区内，实例的网络延迟较低。</p>
<h2 id="接入点"><a class="markdownIt-Anchor" href="#接入点"></a> 接入点</h2>
<p>地域的某个服务的入口域名。</p>
<h2 id="命名空间"><a class="markdownIt-Anchor" href="#命名空间"></a> 命名空间</h2>
<p>用于进行租户粒度的配置隔离。不同的命名空间下，可以存在相同的 Group 或 Data ID 的配置。Namespace 的常用场景之一是不同环境的配置的区分隔离，例如开发测试环境和生产环境的资源（如配置、服务）隔离等。</p>
<h2 id="配置"><a class="markdownIt-Anchor" href="#配置"></a> 配置</h2>
<p>在系统开发过程中，开发者通常会将一些需要变更的参数、变量等从代码中分离出来独立管理，以独立的配置文件的形式存在。目的是让静态的系统工件或者交付物（如 WAR，JAR 包等）更好地和实际的物理运行环境进行适配。配置管理一般包含在系统部署的过程中，由系统管理员或者运维人员完成。配置变更是调整系统运行时的行为的有效手段。</p>
<h2 id="配置管理"><a class="markdownIt-Anchor" href="#配置管理"></a> 配置管理</h2>
<p>系统配置的编辑、存储、分发、变更管理、历史版本管理、变更审计等所有与配置相关的活动。</p>
<h2 id="配置项"><a class="markdownIt-Anchor" href="#配置项"></a> 配置项</h2>
<p>一个具体的可配置的参数与其值域，通常以 param-key=param-value 的形式存在。例如我们常配置系统的日志输出级别（logLevel=INFO|WARN|ERROR） 就是一个配置项。</p>
<h2 id="配置集"><a class="markdownIt-Anchor" href="#配置集"></a> 配置集</h2>
<p>一组相关或者不相关的配置项的集合称为配置集。在系统中，一个配置文件通常就是一个配置集，包含了系统各个方面的配置。例如，一个配置集可能包含了数据源、线程池、日志级别等配置项。</p>
<h2 id="配置集-id"><a class="markdownIt-Anchor" href="#配置集-id"></a> 配置集 ID</h2>
<p>Nacos 中的某个配置集的 ID。配置集 ID 是组织划分配置的维度之一。Data ID 通常用于组织划分系统的配置集。一个系统或者应用可以包含多个配置集，每个配置集都可以被一个有意义的名称标识。Data ID 通常采用类 Java 包（如 com.taobao.tc.refund.log.level）的命名规则保证全局唯一性。此命名规则非强制。</p>
<h2 id="配置分组"><a class="markdownIt-Anchor" href="#配置分组"></a> 配置分组</h2>
<p>Nacos 中的一组配置集，是组织配置的维度之一。通过一个有意义的字符串（如 Buy 或 Trade ）对配置集进行分组，从而区分 Data ID 相同的配置集。当您在 Nacos 上创建一个配置时，如果未填写配置分组的名称，则配置分组的名称默认采用 DEFAULT_GROUP 。配置分组的常见场景：不同的应用或组件使用了相同的配置类型，如 database_url 配置和 MQ_topic 配置。</p>
<h2 id="配置快照"><a class="markdownIt-Anchor" href="#配置快照"></a> 配置快照</h2>
<p>Nacos 的客户端 SDK 会在本地生成配置的快照。当客户端无法连接到 Nacos Server 时，可以使用配置快照显示系统的整体容灾能力。配置快照类似于 Git 中的本地 commit，也类似于缓存，会在适当的时机更新，但是并没有缓存过期（expiration）的概念。</p>
<h2 id="服务"><a class="markdownIt-Anchor" href="#服务"></a> 服务</h2>
<p>通过预定义接口网络访问的提供给客户端的软件功能。</p>
<h2 id="服务名"><a class="markdownIt-Anchor" href="#服务名"></a> 服务名</h2>
<p>服务提供的标识，通过该标识可以唯一确定其指代的服务。</p>
<h2 id="服务注册中心"><a class="markdownIt-Anchor" href="#服务注册中心"></a> 服务注册中心</h2>
<p>存储服务实例和服务负载均衡策略的数据库。</p>
<h2 id="服务发现"><a class="markdownIt-Anchor" href="#服务发现"></a> 服务发现</h2>
<p>在计算机网络上，（通常使用服务名）对服务下的实例的地址和元数据进行探测，并以预先定义的接口提供给客户端进行查询。</p>
<h2 id="元信息"><a class="markdownIt-Anchor" href="#元信息"></a> 元信息</h2>
<p>Nacos数据（如配置和服务）描述信息，如服务版本、权重、容灾策略、负载均衡策略、鉴权配置、各种自定义标签 (label)，从作用范围来看，分为服务级别的元信息、集群的元信息及实例的元信息。</p>
<h2 id="应用"><a class="markdownIt-Anchor" href="#应用"></a> 应用</h2>
<p>用于标识服务提供方的服务的属性。</p>
<h2 id="服务分组"><a class="markdownIt-Anchor" href="#服务分组"></a> 服务分组</h2>
<p>不同的服务可以归类到同一分组。</p>
<h2 id="虚拟集群"><a class="markdownIt-Anchor" href="#虚拟集群"></a> 虚拟集群</h2>
<p>同一个服务下的所有服务实例组成一个默认集群, 集群可以被进一步按需求划分，划分的单位可以是虚拟集群。</p>
<h2 id="实例"><a class="markdownIt-Anchor" href="#实例"></a> 实例</h2>
<p>提供一个或多个服务的具有可访问网络地址（IP:Port）的进程。</p>
<h2 id="权重"><a class="markdownIt-Anchor" href="#权重"></a> 权重</h2>
<p>实例级别的配置。权重为浮点数。权重越大，分配给该实例的流量越大。</p>
<h2 id="健康检查"><a class="markdownIt-Anchor" href="#健康检查"></a> 健康检查</h2>
<p>以指定方式检查服务下挂载的实例 (Instance) 的健康度，从而确认该实例 (Instance) 是否能提供服务。根据检查结果，实例 (Instance) 会被判断为健康或不健康。对服务发起解析请求时，不健康的实例 (Instance) 不会返回给客户端。</p>
<h2 id="健康保护阈值"><a class="markdownIt-Anchor" href="#健康保护阈值"></a> 健康保护阈值</h2>
<p>为了防止因过多实例 (Instance) 不健康导致流量全部流向健康实例 (Instance) ，继而造成流量压力把健康实例 (Instance) 压垮并形成雪崩效应，应将健康保护阈值定义为一个 0 到 1 之间的浮点数。当域名健康实例数 (Instance) 占总服务实例数 (Instance) 的比例小于该值时，无论实例 (Instance) 是否健康，都会将这个实例 (Instance) 返回给客户端。这样做虽然损失了一部分流量，但是保证了集群中剩余健康实例 (Instance) 能正常工作。</p>
]]></content>
      <categories>
        <category>Nacos</category>
        <category>概念架构</category>
      </categories>
      <tags>
        <tag>Nacos</tag>
      </tags>
  </entry>
  <entry>
    <title>Nacos 架构</title>
    <url>/posts/59ff8987/</url>
    <content><![CDATA[<p>Nacos 开源之前在阿里内部已经发展了十年，沉淀了很多优秀的能力，也有很多历史负担，在开源的时候我们取其精华进行开源，为了提升代码的健壮性和扩展性，进行了充分的分层和模块化设计。</p>
<div class="note note-warning icon-padding"><i class="note-icon fa-solid fa-exclamation-circle"></i><p>内容摘抄自<a class="link"   href="https://nacos.io/zh-cn/docs/v2/quickstart/quick-start.html" >Nacos官方文档 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>，可以点击链接移步官方文档</p>
</div>
<h2 id="基本架构及概念"><a class="markdownIt-Anchor" href="#基本架构及概念"></a> 基本架构及概念</h2>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="nacos_arch.jpg"
                      alt="nacos_arch.jpg" 
                ></p>
<h3 id="服务-service"><a class="markdownIt-Anchor" href="#服务-service"></a> 服务 (Service)</h3>
<p>服务是指一个或一组软件功能（例如特定信息的检索或一组操作的执行），其目的是不同的客户端可以为不同的目的重用（例如通过跨进程的网络调用）。Nacos 支持主流的服务生态，如 Kubernetes Service、gRPC|Dubbo RPC Service 或者 Spring Cloud RESTful Service。</p>
<h3 id="服务注册中心-service-registry"><a class="markdownIt-Anchor" href="#服务注册中心-service-registry"></a> 服务注册中心 (Service Registry)</h3>
<p>服务注册中心，它是服务，其实例及元数据的数据库。服务实例在启动时注册到服务注册表，并在关闭时注销。服务和路由器的客户端查询服务注册表以查找服务的可用实例。服务注册中心可能会调用服务实例的健康检查 API 来验证它是否能够处理请求。</p>
<h3 id="服务元数据-service-metadata"><a class="markdownIt-Anchor" href="#服务元数据-service-metadata"></a> 服务元数据 (Service Metadata)</h3>
<p>服务元数据是指包括服务端点(endpoints)、服务标签、服务版本号、服务实例权重、路由规则、安全策略等描述服务的数据。</p>
<h3 id="服务提供方-service-provider"><a class="markdownIt-Anchor" href="#服务提供方-service-provider"></a> 服务提供方 (Service Provider)</h3>
<p>是指提供可复用和可调用服务的应用方。</p>
<h3 id="服务消费方-service-consumer"><a class="markdownIt-Anchor" href="#服务消费方-service-consumer"></a> 服务消费方 (Service Consumer)</h3>
<p>是指会发起对某个服务调用的应用方。</p>
<h3 id="配置-configuration"><a class="markdownIt-Anchor" href="#配置-configuration"></a> 配置 (Configuration)</h3>
<p>在系统开发过程中通常会将一些需要变更的参数、变量等从代码中分离出来独立管理，以独立的配置文件的形式存在。目的是让静态的系统工件或者交付物（如 WAR，JAR 包等）更好地和实际的物理运行环境进行适配。配置管理一般包含在系统部署的过程中，由系统管理员或者运维人员完成这个步骤。配置变更是调整系统运行时的行为的有效手段之一。</p>
<h3 id="配置管理-configuration-management"><a class="markdownIt-Anchor" href="#配置管理-configuration-management"></a> 配置管理 (Configuration Management)</h3>
<p>在数据中心中，系统中所有配置的编辑、存储、分发、变更管理、历史版本管理、变更审计等所有与配置相关的活动统称为配置管理。</p>
<h3 id="名字服务-naming-service"><a class="markdownIt-Anchor" href="#名字服务-naming-service"></a> 名字服务 (Naming Service)</h3>
<p>提供分布式系统中所有对象(Object)、实体(Entity)的“名字”到关联的元数据之间的映射管理服务，例如 ServiceName -&gt; Endpoints Info, Distributed Lock Name -&gt; Lock Owner/Status Info, DNS Domain Name -&gt; IP List, 服务发现和 DNS 就是名字服务的2大场景。</p>
<h3 id="配置服务-configuration-service"><a class="markdownIt-Anchor" href="#配置服务-configuration-service"></a> 配置服务 (Configuration Service)</h3>
<p>在服务或者应用运行过程中，提供动态配置或者元数据以及配置管理的服务提供者。</p>
<h3 id="更多概念"><a class="markdownIt-Anchor" href="#更多概念"></a> <a class="link"   href="https://nacos.io/zh-cn/docs/v2/concepts.html" >更多概念… <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></h3>
<h2 id="逻辑架构及其组件介绍"><a class="markdownIt-Anchor" href="#逻辑架构及其组件介绍"></a> 逻辑架构及其组件介绍</h2>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="nacos-logic.png"
                      alt="nacos-logic.jpg" 
                ></p>
<ul>
<li>服务管理：实现服务CRUD，域名CRUD，服务健康状态检查，服务权重管理等功能</li>
<li>配置管理：实现配置管CRUD，版本管理，灰度管理，监听管理，推送轨迹，聚合数据等功能</li>
<li>元数据管理：提供元数据CURD 和打标能力</li>
<li>插件机制：实现三个模块可分可合能力，实现扩展点SPI机制</li>
<li>事件机制：实现异步化事件通知，sdk数据变化异步通知等逻辑</li>
<li>日志模块：管理日志分类，日志级别，日志可移植性（尤其避免冲突），日志格式，异常码+帮助文档</li>
<li>回调机制：sdk通知数据，通过统一的模式回调用户处理。接口和数据结构需要具备可扩展性</li>
<li>寻址模式：解决ip，域名，nameserver、广播等多种寻址模式，需要可扩展</li>
<li>推送通道：解决server与存储、server间、server与sdk间推送性能问题</li>
<li>容量管理：管理每个租户，分组下的容量，防止存储被写爆，影响服务可用性</li>
<li>流量管理：按照租户，分组等多个维度对请求频率，长链接个数，报文大小，请求流控进行控制</li>
<li>缓存机制：容灾目录，本地缓存，server缓存机制。容灾目录使用需要工具</li>
<li>启动模式：按照单机模式，配置模式，服务模式，dns模式，或者all模式，启动不同的程序+UI</li>
<li>一致性协议：解决不同数据，不同一致性要求情况下，不同一致性机制</li>
<li>存储模块：解决数据持久化、非持久化存储，解决数据分片问题</li>
<li>Nameserver：解决namespace到clusterid的路由问题，解决用户环境与nacos物理环境映射问题</li>
<li>CMDB：解决元数据存储，与三方cmdb系统对接问题，解决应用，人，资源关系</li>
<li>Metrics：暴露标准metrics数据，方便与三方监控系统打通</li>
<li>Trace：暴露标准trace，方便与SLA系统打通，日志白平化，推送轨迹等能力，并且可以和计量计费系统打通</li>
<li>接入管理：相当于阿里云开通服务，分配身份、容量、权限过程</li>
<li>用户管理：解决用户管理，登录，sso等问题</li>
<li>权限管理：解决身份识别，访问控制，角色管理等问题</li>
<li>审计系统：扩展接口方便与不同公司审计系统打通</li>
<li>通知系统：核心数据变更，或者操作，方便通过SMS系统打通，通知到对应人数据变更</li>
<li>OpenAPI：暴露标准Rest风格HTTP接口，简单易用，方便多语言集成</li>
<li>Console：易用控制台，做服务管理、配置管理等操作</li>
<li>SDK：多语言sdk</li>
<li>Agent：dns-f类似模式，或者与mesh等方案集成</li>
<li>CLI：命令行对产品进行轻量化管理，像git一样好用</li>
</ul>
<h2 id="领域模型"><a class="markdownIt-Anchor" href="#领域模型"></a> 领域模型</h2>
<h3 id="数据模型"><a class="markdownIt-Anchor" href="#数据模型"></a> 数据模型</h3>
<p>Nacos 数据模型 Key 由三元组唯一确定, Namespace默认是空串，公共命名空间（public），分组默认是 DEFAULT_GROUP。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="nacos_data_model.jpeg"
                      alt="nacos_data_model" 
                ></p>
<h3 id="服务领域模型"><a class="markdownIt-Anchor" href="#服务领域模型"></a> 服务领域模型</h3>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="nacos_naming_data_model.jpeg"
                      alt="nacos_naming_data_model" 
                ></p>
<h3 id="配置领域模型"><a class="markdownIt-Anchor" href="#配置领域模型"></a> 配置领域模型</h3>
<p>围绕配置，主要有两个关联的实体，一个是配置变更历史，一个是服务标签（用于打标分类，方便索引），由 ID 关联。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="nacos_config_er.jpeg"
                      alt="nacos_config_er" 
                ></p>
<h2 id="类视图"><a class="markdownIt-Anchor" href="#类视图"></a> 类视图</h2>
<h3 id="nacos-sdk-类视图"><a class="markdownIt-Anchor" href="#nacos-sdk-类视图"></a> Nacos-SDK 类视图</h3>
<p>服务部分待续</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="nacos_sdk_class_relation.png"
                      alt="nacos_sdk_class_relation" 
                ></p>
<h2 id="构建物-部署及启动模式"><a class="markdownIt-Anchor" href="#构建物-部署及启动模式"></a> 构建物、部署及启动模式</h2>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="deploy.png"
                      alt="deploy" 
                ></p>
<h3 id="两种交付工件"><a class="markdownIt-Anchor" href="#两种交付工件"></a> 两种交付工件</h3>
<p>Nacos 支持标准 Docker 镜像(TODO: 0.2版本开始支持）及 zip(tar.gz)压缩包的构建物。</p>
<h3 id="两种启动模式"><a class="markdownIt-Anchor" href="#两种启动模式"></a> 两种启动模式</h3>
<p>Nacos 支持将注册中心(Service Registry）与配置中心(Config Center) 在一个进程合并部署或者将2者分离部署的两种模式。</p>
<h3 id="免费的公有云服务模式"><a class="markdownIt-Anchor" href="#免费的公有云服务模式"></a> 免费的公有云服务模式</h3>
<p>除了您自己部署和启动 Nacos 服务之外，在云计算时代，Nacos 也支持公有云模式，在阿里云公有云的商业产品（如<a class="link"   href="https://cn.aliyun.com/product/aliware/mse?spm=nacos-website.topbar.0.0.0m" >MSE <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>, <a class="link"   href="https://www.aliyun.com/product/edas" >EDAS <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>) 中会提供 Nacos 的免费的公有云服务。我们也欢迎和支持其他的公有云提供商提供 Nacos 的公有云服务。</p>
]]></content>
      <categories>
        <category>Nacos</category>
        <category>概念架构</category>
      </categories>
      <tags>
        <tag>Nacos</tag>
      </tags>
  </entry>
  <entry>
    <title>Nacos 简介</title>
    <url>/posts/9d0a5cc1/</url>
    <content><![CDATA[<p>欢迎来到 Nacos 的世界！</p>
<p>Nacos /nɑ:kəʊs/ 是 Dynamic Naming and Configuration Service的首字母简称，一个更易于构建云原生应用的动态服务发现、配置管理和服务管理平台。</p>
<p>Nacos 致力于帮助您发现、配置和管理微服务。Nacos 提供了一组简单易用的特性集，帮助您快速实现动态服务发现、服务配置、服务元数据及流量管理。</p>
<p>Nacos 帮助您更敏捷和容易地构建、交付和管理微服务平台。 Nacos 是构建以“服务”为中心的现代应用架构 (例如微服务范式、云原生范式) 的服务基础设施。</p>
<div class="note note-warning icon-padding"><i class="note-icon fa-solid fa-exclamation-circle"></i><p>内容摘抄自<a class="link"   href="https://nacos.io/zh-cn/docs/v2/quickstart/quick-start.html" >Nacos官方文档 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>，可以点击链接移步官方文档</p>
</div>
<h2 id="什么是-nacos"><a class="markdownIt-Anchor" href="#什么是-nacos"></a> 什么是 Nacos？</h2>
<p>服务（Service）是 Nacos 世界的一等公民。Nacos 支持几乎所有主流类型的“服务”的发现、配置和管理：</p>
<p><a class="link"   href="https://kubernetes.io/docs/concepts/services-networking/service/" >Kubernetes Service <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<p><a class="link"   href="https://grpc.io/docs/guides/concepts.html#service-definition" >gRPC <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a> &amp; <a class="link"   href="https://dubbo.incubator.apache.org/" >Dubbo RPC Service <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<p><a class="link"   href="https://spring.io/projects/spring-restdocs" >Spring Cloud RESTful Service <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<p>Nacos 的关键特性包括:</p>
<ul>
<li>
<p><strong>服务发现和服务健康监测</strong></p>
<p>Nacos 支持基于 DNS 和基于 RPC 的服务发现。服务提供者使用 <a class="link"   href="https://nacos.io/zh-cn/docs/sdk.html" >原生SDK <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>、<a class="link"   href="https://nacos.io/zh-cn/docs/open-api.html" >OpenAPI <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>、或一个<a class="link"   href="https://nacos.io/zh-cn/docs/other-language.html" >独立的Agent TODO <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>注册 Service 后，服务消费者可以使用<a class="link"   href="https://nacos.io/zh-cn/docs/xx" >DNS TODO <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a> 或<a class="link"   href="https://nacos.io/zh-cn/docs/open-api.html" >HTTP&amp;API <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>查找和发现服务。</p>
<p>Nacos 提供对服务的实时的健康检查，阻止向不健康的主机或服务实例发送请求。Nacos 支持传输层 (PING 或 TCP)和应用层 (如 HTTP、MySQL、用户自定义）的健康检查。 对于复杂的云环境和网络拓扑环境中（如 VPC、边缘网络等）服务的健康检查，Nacos 提供了 agent 上报模式和服务端主动检测2种健康检查模式。Nacos 还提供了统一的健康检查仪表盘，帮助您根据健康状态管理服务的可用性及流量。</p>
</li>
<li>
<p><strong>动态配置服务</strong></p>
<p>动态配置服务可以让您以中心化、外部化和动态化的方式管理所有环境的应用配置和服务配置。</p>
<p>动态配置消除了配置变更时重新部署应用和服务的需要，让配置管理变得更加高效和敏捷。</p>
<p>配置中心化管理让实现无状态服务变得更简单，让服务按需弹性扩展变得更容易。</p>
<p>Nacos 提供了一个简洁易用的UI (<a class="link"   href="http://console.nacos.io/nacos/index.html" >控制台样例 Demo <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>) 帮助您管理所有的服务和应用的配置。Nacos 还提供包括配置版本跟踪、金丝雀发布、一键回滚配置以及客户端配置更新状态跟踪在内的一系列开箱即用的配置管理特性，帮助您更安全地在生产环境中管理配置变更和降低配置变更带来的风险。</p>
</li>
<li>
<p><strong>动态 DNS 服务</strong></p>
<p>动态 DNS 服务支持权重路由，让您更容易地实现中间层负载均衡、更灵活的路由策略、流量控制以及数据中心内网的简单DNS解析服务。动态DNS服务还能让您更容易地实现以 DNS 协议为基础的服务发现，以帮助您消除耦合到厂商私有服务发现 API 上的风险。</p>
<p>Nacos 提供了一些简单的 <a class="link"   href="https://nacos.io/zh-cn/docs/xx" >DNS APIs TODO <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a> 帮助您管理服务的关联域名和可用的 IP:PORT 列表.</p>
</li>
<li>
<p><strong>服务及其元数据管理</strong></p>
<p>Nacos 能让您从微服务平台建设的视角管理数据中心的所有服务及元数据，包括管理服务的描述、生命周期、服务的静态依赖分析、服务的健康状态、服务的流量管理、路由及安全策略、服务的 SLA 以及最首要的 metrics 统计数据。</p>
</li>
<li>
<p><a class="link"   href="https://nacos.io/zh-cn/docs/docs/zh-cn/archive/roadmap.html" >更多的特性列表 … <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
</li>
</ul>
<h2 id="nacos-地图"><a class="markdownIt-Anchor" href="#nacos-地图"></a> Nacos 地图</h2>
<p>一图看懂 Nacos，下面架构部分会详细介绍。 <img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="nacos_map.jpg"
                      alt="nacos_map" 
                ></p>
<ul>
<li>特性大图：要从功能特性，非功能特性，全面介绍我们要解的问题域的特性诉求</li>
<li>架构大图：通过清晰架构，让您快速进入 Nacos 世界</li>
<li>业务大图：利用当前特性可以支持的业务场景，及其最佳实践</li>
<li>生态大图：系统梳理 Nacos 和主流技术生态的关系</li>
<li>优势大图：展示 Nacos 核心竞争力</li>
<li>战略大图：要从战略到战术层面讲 Nacos 的宏观优势</li>
</ul>
<h2 id="nacos-生态图"><a class="markdownIt-Anchor" href="#nacos-生态图"></a> Nacos 生态图</h2>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="nacos_landscape.png"
                      alt="nacos_landscape.png" 
                ></p>
<p>如 Nacos 全景图所示，Nacos 无缝支持一些主流的开源生态，例如</p>
<ul>
<li><a class="link"   href="https://nacos.io/en-us/docs/quick-start-spring-cloud.html" >Spring Cloud <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></li>
<li><a class="link"   href="https://nacos.io/zh-cn/docs/use-nacos-with-dubbo.html" >Apache Dubbo and Dubbo Mesh <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></li>
<li><a class="link"   href="https://nacos.io/zh-cn/docs/use-nacos-with-kubernetes.html" >Kubernetes and CNCF <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>。</li>
</ul>
<p>使用 Nacos 简化服务发现、配置管理、服务治理及管理的解决方案，让微服务的发现、管理、共享、组合更加容易。</p>
]]></content>
      <categories>
        <category>Nacos</category>
        <category>概念架构</category>
      </categories>
      <tags>
        <tag>Nacos</tag>
      </tags>
  </entry>
  <entry>
    <title>Nacos 作为配置中心 - Java</title>
    <url>/posts/7ce5f9de/</url>
    <content><![CDATA[<p>本文将介绍如何在Java项目中使用Nacos作为配置中心，进行动态配置管理。在此前提下，我们需要先安装Nacos Server，可参考官方文档 <a class="link"   href="https://nacos.io/zh-cn/docs/quick-start.html" >Quick Start <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>。</p>
<h2 id="依赖导入"><a class="markdownIt-Anchor" href="#依赖导入"></a> 依赖导入</h2>
<div class="note note-info icon-padding"><i class="note-icon fa-solid fa-info-circle"></i><p>参考<a class="link"   href="https://nacos.io/zh-cn/docs/v2/guide/user/sdk.html" >官方文档 Java SDK <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
</div>
<p>首先，我们需要引入Nacos的Java SDK库，这里以Maven为例：</p>
<div class="highlight-container" data-rel="Xml"><figure class="iseeu highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba.nacos<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>nacos-client<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;nacos.sdk.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></div>
<p>其中，<code>$&#123;nacos.sdk.version&#125;</code>代表版本号，可以根据实际情况进行配置。</p>
<h2 id="连接到nacos"><a class="markdownIt-Anchor" href="#连接到nacos"></a> 连接到Nacos</h2>
<p>使用Nacos作为配置中心，需要先连接到Nacos Server，我们可以通过以下代码来连接：</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">NacosConnectDemo</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> NacosException &#123;</span><br><span class="line">        <span class="comment">// Nacos Server地址</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">serverAddr</span> <span class="operator">=</span> <span class="string">&quot;localhost:8848&quot;</span></span><br><span class="line">        <span class="comment">// 创建配置服务客户端对象</span></span><br><span class="line">        <span class="type">NacosConfigService</span> <span class="variable">configService</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">NacosConfigService</span>(serverAddr);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>上述代码中，我们创建了一个<code>NacosConfigService</code>对象，用于连接到指定的Nacos Server地址。</p>
<h2 id="获取配置信息"><a class="markdownIt-Anchor" href="#获取配置信息"></a> 获取配置信息</h2>
<p>在连接到Nacos Server后，我们就可以获取配置信息。对于Java来说，我们可以使用以下代码来获取配置信息：</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">NacosConfigDemo</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> NacosException &#123;</span><br><span class="line">        <span class="comment">// Nacos Server地址</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">serverAddr</span> <span class="operator">=</span> <span class="string">&quot;localhost:8848&quot;</span>;</span><br><span class="line">        <span class="comment">// 配置命名空间</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">namespace</span> <span class="operator">=</span> <span class="string">&quot;test_namespace&quot;</span>;</span><br><span class="line">        <span class="comment">// 配置分组</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">group</span> <span class="operator">=</span> <span class="string">&quot;test_group&quot;</span>;</span><br><span class="line">        <span class="comment">// 配置项名称</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">dataId</span> <span class="operator">=</span> <span class="string">&quot;test_config&quot;</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 创建配置服务客户端对象</span></span><br><span class="line">        <span class="type">ConfigService</span> <span class="variable">configService</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">NacosConfigService</span>(serverAddr);</span><br><span class="line">        <span class="comment">// 获取配置信息</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">content</span> <span class="operator">=</span> configService.getConfig(dataId, group, <span class="number">5000</span>);</span><br><span class="line">        </span><br><span class="line">        System.out.println(content);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>上述代码中，我们创建了一个<code>ConfigService</code>对象，用于获取指定的配置信息。其中，我们需要指定配置命名空间、配置分组以及配置项名称等信息。</p>
<h2 id="监听配置变更"><a class="markdownIt-Anchor" href="#监听配置变更"></a> 监听配置变更</h2>
<p>在获取到配置信息后，我们可以通过以下代码来监听配置变更：</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">NacosConfigListenerDemo</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> NacosException &#123;</span><br><span class="line">        <span class="comment">// Nacos Server地址</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">serverAddr</span> <span class="operator">=</span> <span class="string">&quot;localhost:8848&quot;</span>;</span><br><span class="line">        <span class="comment">// 配置命名空间</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">namespace</span> <span class="operator">=</span> <span class="string">&quot;test_namespace&quot;</span>;</span><br><span class="line">        <span class="comment">// 配置分组</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">group</span> <span class="operator">=</span> <span class="string">&quot;test_group&quot;</span>;</span><br><span class="line">        <span class="comment">// 配置项名称</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">dataId</span> <span class="operator">=</span> <span class="string">&quot;test_config&quot;</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 创建配置服务客户端对象</span></span><br><span class="line">        <span class="type">ConfigService</span> <span class="variable">configService</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">NacosConfigService</span>(serverAddr);</span><br><span class="line">        <span class="comment">// 添加监听器</span></span><br><span class="line">        configService.addListener(dataId, group, <span class="keyword">new</span> <span class="title class_">Listener</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">receiveConfigInfo</span><span class="params">(String configInfo)</span> &#123;</span><br><span class="line">                System.out.println(configInfo);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> Executor <span class="title function_">getExecutor</span><span class="params">()</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>上述代码中，我们添加了一个配置信息变更的监听器，当Nacos Server中的对应配置发生变更时，会自动触发该监听器。</p>
<h2 id="更新配置信息"><a class="markdownIt-Anchor" href="#更新配置信息"></a> 更新配置信息</h2>
<p>在获取到配置信息后，我们可以通过以下代码来更新配置信息：</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">NacosUpdateConfigDemo</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> NacosException &#123;</span><br><span class="line">        <span class="comment">// Nacos Server地址</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">serverAddr</span> <span class="operator">=</span> <span class="string">&quot;localhost:8848&quot;</span>;</span><br><span class="line">        <span class="comment">// 配置命名空间</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">namespace</span> <span class="operator">=</span> <span class="string">&quot;test_namespace&quot;</span>;</span><br><span class="line">        <span class="comment">// 配置分组</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">group</span> <span class="operator">=</span> <span class="string">&quot;test_group&quot;</span>;</span><br><span class="line">        <span class="comment">// 配置项名称</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">dataId</span> <span class="operator">=</span> <span class="string">&quot;test_config&quot;</span>;</span><br><span class="line">        <span class="comment">// 新的配置内容</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">content</span> <span class="operator">=</span> <span class="string">&quot;new config content&quot;</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 创建配置服务客户端对象</span></span><br><span class="line">        <span class="type">ConfigService</span> <span class="variable">configService</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">NacosConfigService</span>(serverAddr);</span><br><span class="line">        <span class="comment">// 更新配置</span></span><br><span class="line">        <span class="type">boolean</span> <span class="variable">isPublished</span> <span class="operator">=</span> configService.publishConfig(dataId, group, content);</span><br><span class="line">        </span><br><span class="line">        System.out.println(isPublished ? <span class="string">&quot;更新配置成功&quot;</span> : <span class="string">&quot;更新配置失败&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>上述代码中，我们使用<code>publishConfig</code>方法来更新指定的配置信息。</p>
<h2 id="删除配置信息"><a class="markdownIt-Anchor" href="#删除配置信息"></a> 删除配置信息</h2>
<p>在获取到配置信息后，我们也可以通过以下代码来删除配置信息：</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">NacosDeleteConfigDemo</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> NacosException &#123;</span><br><span class="line">        <span class="comment">// Nacos Server地址</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">serverAddr</span> <span class="operator">=</span> <span class="string">&quot;localhost:8848&quot;</span>;</span><br><span class="line">        <span class="comment">// 配置命名空间</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">namespace</span> <span class="operator">=</span> <span class="string">&quot;test_namespace&quot;</span>;</span><br><span class="line">        <span class="comment">// 配置分组</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">group</span> <span class="operator">=</span> <span class="string">&quot;test_group&quot;</span>;</span><br><span class="line">        <span class="comment">// 配置项名称</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">dataId</span> <span class="operator">=</span> <span class="string">&quot;test_config&quot;</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 创建配置服务客户端对象</span></span><br><span class="line">        <span class="type">ConfigService</span> <span class="variable">configService</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">NacosConfigService</span>(serverAddr);</span><br><span class="line">        <span class="comment">// 删除配置</span></span><br><span class="line">        <span class="type">boolean</span> <span class="variable">isDeleted</span> <span class="operator">=</span> configService.removeConfig(dataId, group);</span><br><span class="line">        </span><br><span class="line">        System.out.println(isDeleted ? <span class="string">&quot;删除配置成功&quot;</span> : <span class="string">&quot;删除配置失败&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>上述代码中，我们使用<code>removeConfig</code>方法来删除指定的配置信息。</p>
<h2 id="总结"><a class="markdownIt-Anchor" href="#总结"></a> 总结</h2>
<p>Nacos 作为配置中心具有诸多优势，能够帮助开发者实现动态配置管理，在分布式环境中提供高可用性和容错性，并且支持多种数据格式和服务注册与发现。</p>
]]></content>
      <categories>
        <category>Nacos</category>
        <category>使用示例</category>
      </categories>
      <tags>
        <tag>Nacos</tag>
      </tags>
  </entry>
  <entry>
    <title>项目纪实-大Excel解析设计</title>
    <url>/posts/ac7ff69a/</url>
    <content><![CDATA[<p>使用Excel表格可以一次性导入大量数据，而页面的编辑需要逐条录入。对于需要导入大批量的数据时，使用Excel表格可以提高效率并且减少错误。所以在实际的项目中EXCEL导入的功能也是被大量采用。</p>
<h2 id="需求-设计"><a class="markdownIt-Anchor" href="#需求-设计"></a> 需求、设计</h2>
<h3 id="需求"><a class="markdownIt-Anchor" href="#需求"></a> 需求</h3>
<p>当前公司在接入一家医院后，需要将该医院的耗材资质数据导入到我们的管理平台。步骤如下：</p>
<ol>
<li>在我们平台上下载EXCEL模版；</li>
<li>由实施人员根据院内耗材资质信息进行EXCEL模版的数据填写；</li>
<li>使用平台上的EXCEL导入功能，将填写完整的EXCEL表格上传到管理平台；</li>
<li>平台解析EXCEL表格，校验数据并导入数据库；</li>
</ol>
<h3 id="设计"><a class="markdownIt-Anchor" href="#设计"></a> 设计</h3>
<p>对于我们程序猿来说，我们的关注点是在下载EXCEL模版、EXCEL导入、EXCEL解析、数据存到数据库等这些与程序相关的步骤。那么我们来逐个分析下这些功能的实现：</p>
<ul>
<li>
<p><code>下载EXCEL模版</code>：这个功能相对来说是比较简单的，最常用的就是讲一个空的EXCEL表格上传的oss资源服务器上，在提供一个下载接口，将oss上的EXCEL文件返回给客户端即可；</p>
</li>
<li>
<p><code>EXCEL的导入、解析</code>：导入就是文件的上传，就不多讲了。EXCEL的解析呢，一般来说都是使用的开源<code>POI工具包</code>，除此之外还有阿里的<code>easyexcle</code>、基于poi 封装的<code>easypoi</code> 项目、<code>hutool 工具包</code>。</p>
</li>
<li>
<p><code>数据入库</code>：将解析EXCEL文件得到的数据存入数据库中。使用第三方的仓库层框架，如<code>mybatis</code>、<code>jpa</code>等。</p>
</li>
</ul>
<p>以上就是一个使用EXCEL导入数据的完整流程以及所涉及到的功能点分析。</p>
<p>我们根据上边的分析来看，设计一个EXCEL文件导入功能，其实并不是很困难。但是以上分析是在 与其他需求不存在关联、忽略数据量、只考虑了EXCEL文件导入的情况下来进行设计的，如果我们加上一些需求再来看：</p>
<ul>
<li>校验每个值是否符合平台数据字典的规则？</li>
<li>导入数据是否有重复？</li>
<li>导入的数据对应的资质证件是否有效？</li>
<li>导入的数据对应的资质证件是否在平台上已经存在了？</li>
<li>导入数据出现异常怎样处理？</li>
<li>多个人员在操作导入操作时怎么处理？</li>
<li>…</li>
</ul>
<p>这样一来，在数据量较大的情况下，每添加一个相关的需求，程序的执行性能就会成指数级的下降，因为每个数据都要走一遍这些规则。那我们该如何处理呢？</p>
<p>既然有问题，就有解决问题的方法。解决方案：<span style="border-bottom: 2px solid green">数据分片 + 并发处理 + 缓存 + 异常处理</span></p>
<h2 id="数据分片"><a class="markdownIt-Anchor" href="#数据分片"></a> 数据分片</h2>
<p>一个EXCEL文件的数据量比较大时，我们可以将一个EXCEL文件拆分成多个EXCEL文件，将数据平分在每个EXCEL文件中，这就完整了EXCEL的数据分片。</p>
<h2 id="并发处理"><a class="markdownIt-Anchor" href="#并发处理"></a> 并发处理</h2>
<p>在处理大数据、多任务等等情况下，使用并发编程来提供程序的性能，是我们的不二只选。处理大数据量的EXCEL亦是如此。</p>
<h3 id="线程池"><a class="markdownIt-Anchor" href="#线程池"></a> 线程池</h3>
<p>当我们的接口收到上传的EXCEL文件时，就将其封装成一个解析任务，丢到线程池中执行。</p>
<p>解析EXCEL文件时使用线程池，有以下几个好处：</p>
<ul>
<li>复用线程资源，避免由线程创建、销毁带来的性能消耗。</li>
<li>隔离解析任务，避免每个任务之间的相互影响。</li>
<li>隔离整个解析任务锁使用的CPU资源，避免由于解析EXCEL文件占用了服务器的大量CPU资源，影响到其它接口的性能情况。</li>
</ul>
<h3 id="生产消费模型"><a class="markdownIt-Anchor" href="#生产消费模型"></a> 生产消费模型</h3>
<p>当我们使用POI解析EXCEL文件时，poi会将整个EXCEL文件中的数据加载到内存中，在大量的EXCEL文件同时进行解析时，极易发生OOM异常。</p>
<p>解决方案有两种：</p>
<ul>
<li>poi 官方提供的 SAX 事件驱动模型；</li>
<li>使用阿里开源的 easyexcel;</li>
</ul>
<p>上边两种方式都解决的内存占用过大的问题，下边就是使用这些框架来解析excel文件拿到其中的数据。</p>
<p>将每个excel解析的数据，先上传到一个数据队列中，新建一个线程池，这个线程池负责消费队列中的数据。</p>
<p>消费线程池完成两个任务：</p>
<ol>
<li>对数据进行校验</li>
<li>将校验通过或失败的数据存储到redis缓存中</li>
</ol>
<p>上诉的过程其实就是一个典型的生产消费者模型，就数据的解析和数据校验分开，实现异步同时执行。</p>
]]></content>
      <categories>
        <category>项目纪实</category>
        <category>大Excel解析</category>
      </categories>
      <tags>
        <tag>项目纪实</tag>
        <tag>Excel导入</tag>
      </tags>
  </entry>
  <entry>
    <title>项目纪实-Redis延迟消息设计</title>
    <url>/posts/198b6734/</url>
    <content><![CDATA[<h2 id="背景"><a class="markdownIt-Anchor" href="#背景"></a> 背景</h2>
<div class="note-large notel-green"><div class="notel-title"><p>需求</p>
</div><div class="notel-content"><ul>
<li>
<p>商家收到订单超过12小时没有确认，发送提醒消息；</p>
</li>
<li>
<p>商家确定订单超过24小时没有发货，发送提醒消息；</p>
</li>
</ul>
 </div></div>
<h2 id="方案"><a class="markdownIt-Anchor" href="#方案"></a> 方案</h2>
<h3 id="使用mq的延迟队列"><a class="markdownIt-Anchor" href="#使用mq的延迟队列"></a> <s>使用MQ的延迟队列</s></h3>
<p>我们项目使用的开源的Rocketmq，延迟级别有限制（一共有18 级别，最长时间 2h）并不嫩满足上述的需求；</p>
<h3 id="使用-redis-的有序集合-zset"><a class="markdownIt-Anchor" href="#使用-redis-的有序集合-zset"></a> <strong>使用 Redis 的有序集合 zset</strong></h3>
<p>Redis 有序集合和集合一样也是 string 类型元素的集合,且不允许重复的成员。不同的是每个元素都会关联一个 double 类型的分数。redis 正是通过分数来为集合中的成员进行从小到大的排序。有序集合的成员是唯一的,但分数(score)却可以重复。</p>
<div class="note-large notel-green"><div class="notel-title"><p>使用ZSET的score特性实现延迟效果</p>
</div><div class="notel-content"><ol>
<li>指定 一个key</li>
<li>将提醒的信息数据封装成一个对象实例，作为成员；</li>
<li>score 值为<code>当前系统时间戳 + 需要延迟的时间戳</code>；</li>
<li>实现一个Redis Key（就是第一步设置的key）监控服务；</li>
<li>监控服务使用<code>zrangeByScore()</code>方法，根据<code>当前时间</code>拉取zset集合中的数据；</li>
<li>将拉取到的数据，使用对应的消息通知api发送；</li>
<li>发送之后再将拉取的成员删除即可；</li>
</ol>
 </div></div>
]]></content>
      <categories>
        <category>项目纪实</category>
        <category>Redis延迟消息</category>
      </categories>
      <tags>
        <tag>项目纪实</tag>
      </tags>
  </entry>
  <entry>
    <title>Springboot2.7集成ShardingSphereJdbc5.1.1</title>
    <url>/posts/db89d0f7/</url>
    <content><![CDATA[<p>ShardingSphere是一个开源的分布式数据库中间件，它支持多种关系型数据库，例如MySQL、Oracle、SQL Server等。在本篇博客中，将介绍如何使用Spring Boot 2.7集成ShardingSphere-jdbc5.1.1，并提供相应的配置文件和Java代码演示。</p>
<h2 id="环境准备"><a class="markdownIt-Anchor" href="#环境准备"></a> 环境准备</h2>
<ul>
<li>JDK 1.8+</li>
<li>Maven</li>
<li>MySQL数据库</li>
<li>Springboot 2.7.4</li>
<li>ShardingSphere-Jdbc-5.1.1</li>
</ul>
<h2 id="添加依赖"><a class="markdownIt-Anchor" href="#添加依赖"></a> 添加依赖</h2>
<p>在pom.xml文件中添加以下依赖：</p>
<div class="highlight-container" data-rel="Xml"><figure class="iseeu highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.shardingsphere<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>shardingsphere-jdbc-core-spring-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.1.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></div>
<h2 id="配置数据源和分片规则"><a class="markdownIt-Anchor" href="#配置数据源和分片规则"></a> 配置数据源和分片规则</h2>
<p>在application.yml文件中添加以下配置：</p>
<div class="highlight-container" data-rel="Yaml"><figure class="iseeu highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">shardingsphere:</span></span><br><span class="line">    <span class="attr">mode:</span></span><br><span class="line">      <span class="comment"># 内存模式</span></span><br><span class="line">      <span class="attr">type:</span> <span class="string">Memory</span></span><br><span class="line">    <span class="attr">props:</span></span><br><span class="line">      <span class="comment"># 打印SQl</span></span><br><span class="line">      <span class="attr">sql-show:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">datasource:</span></span><br><span class="line">      <span class="attr">names:</span> <span class="string">ds0,ds1</span></span><br><span class="line">      <span class="attr">ds0:</span></span><br><span class="line">        <span class="attr">type:</span> <span class="string">com.zaxxer.hikari.HikariDataSource</span></span><br><span class="line">        <span class="attr">driver-class-name:</span> <span class="string">com.mysql.jdbc.Driver</span></span><br><span class="line">        <span class="attr">jdbc-url:</span> <span class="string">jdbc:mysql://localhost:3306/ds0</span></span><br><span class="line">        <span class="attr">username:</span> <span class="string">root</span></span><br><span class="line">        <span class="attr">password:</span> <span class="string">root</span></span><br><span class="line">      <span class="attr">ds1:</span></span><br><span class="line">        <span class="attr">type:</span> <span class="string">com.zaxxer.hikari.HikariDataSource</span></span><br><span class="line">        <span class="attr">driver-class-name:</span> <span class="string">com.mysql.jdbc.Driver</span></span><br><span class="line">        <span class="attr">jdbc-url:</span> <span class="string">jdbc:mysql://localhost:3306/ds1</span></span><br><span class="line">        <span class="attr">username:</span> <span class="string">root</span></span><br><span class="line">        <span class="attr">password:</span> <span class="string">root</span></span><br><span class="line">    <span class="attr">rules:</span></span><br><span class="line">      <span class="attr">sharding:</span></span><br><span class="line">        <span class="attr">tables:</span></span><br><span class="line">          <span class="attr">t_user:</span></span><br><span class="line">            <span class="attr">actual-data-nodes:</span> <span class="string">ds$-&gt;&#123;0..1&#125;.t_user$-&gt;&#123;0..1&#125;</span></span><br><span class="line">            <span class="comment"># 主键生成策略</span></span><br><span class="line">            <span class="attr">key-generate-strategy:</span></span><br><span class="line">              <span class="comment"># 分布式序列列名称</span></span><br><span class="line">              <span class="attr">column:</span> <span class="string">id</span></span><br><span class="line">              <span class="comment"># 分布式序列算法名称</span></span><br><span class="line">              <span class="attr">key-generator-name:</span> <span class="string">alg_snowflake</span></span><br><span class="line">            <span class="comment"># 分库策略</span></span><br><span class="line">            <span class="attr">database-strategy:</span></span><br><span class="line">              <span class="attr">standard:</span></span><br><span class="line">                <span class="comment"># 分片算法名称</span></span><br><span class="line">                <span class="attr">sharding-algorithm-name:</span> <span class="string">alg_inline_userid</span></span><br><span class="line">                <span class="comment"># 分片列名称</span></span><br><span class="line">                <span class="attr">sharding-column:</span> <span class="string">id</span></span><br><span class="line">            <span class="comment"># 分表策略</span></span><br><span class="line">            <span class="attr">table-strategy:</span></span><br><span class="line">              <span class="attr">standard:</span></span><br><span class="line">                <span class="comment"># 分片算法名称</span></span><br><span class="line">                <span class="attr">sharding-algorithm-name:</span> <span class="string">alg_hash_mod</span></span><br><span class="line">                <span class="comment"># 分片列名称</span></span><br><span class="line">                <span class="attr">sharding-column:</span> <span class="string">id</span></span><br><span class="line">        <span class="comment"># 分片算法配置</span></span><br><span class="line">        <span class="attr">sharding-algorithms:</span></span><br><span class="line">          <span class="comment"># 行表达式分片算法</span></span><br><span class="line">          <span class="attr">alg_inline_userid:</span></span><br><span class="line">            <span class="attr">props:</span></span><br><span class="line">              <span class="comment"># 分片算法属性配置</span></span><br><span class="line">              <span class="attr">algorithm-expression:</span> <span class="string">ds$-&gt;&#123;id</span> <span class="string">%</span> <span class="number">2</span><span class="string">&#125;</span></span><br><span class="line">            <span class="comment"># 分片算法类型</span></span><br><span class="line">            <span class="attr">type:</span> <span class="string">INLINE</span></span><br><span class="line">          <span class="attr">alg_mod:</span></span><br><span class="line">            <span class="attr">props:</span></span><br><span class="line">              <span class="comment"># 分片算法属性配置</span></span><br><span class="line">              <span class="attr">sharding-count:</span> <span class="number">2</span></span><br><span class="line">            <span class="comment"># 取模分片算法</span></span><br><span class="line">            <span class="attr">type:</span> <span class="string">MOD</span></span><br><span class="line">          <span class="attr">alg_hash_mod:</span></span><br><span class="line">            <span class="attr">props:</span></span><br><span class="line">              <span class="comment"># 分片算法属性配置</span></span><br><span class="line">              <span class="attr">sharding-count:</span> <span class="number">2</span></span><br><span class="line">            <span class="comment"># 分片算法类型</span></span><br><span class="line">            <span class="attr">type:</span> <span class="string">HASH_MOD</span></span><br><span class="line">        <span class="attr">key-generators:</span></span><br><span class="line">          <span class="comment"># 分布式序列算法配置</span></span><br><span class="line">          <span class="attr">alg_snowflake:</span></span><br><span class="line">            <span class="comment"># 分布式序列算法类型</span></span><br><span class="line">            <span class="attr">type:</span> <span class="string">SNOWFLAKE</span></span><br></pre></td></tr></table></figure></div>
<p>这里我们配置了两个数据源（ds0和ds1），并且对user表进行了分片，根据id字段对表进行水平分割。具体细节可以参考<a class="link"   href="https://shardingsphere.apache.org/document/5.1.1/cn/user-manual/shardingsphere-jdbc/" >官方文档 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>。</p>
<h2 id="java代码演示"><a class="markdownIt-Anchor" href="#java代码演示"></a> Java代码演示</h2>
<p>在代码中注入ShardingSphere数据源，在使用的时候直接使用即可，和平常的数据源在使用上并无两样。例如 JdbcTemplate：</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">UserService</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> JdbcTemplate jdbcTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addUser</span><span class="params">(User user)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">sql</span> <span class="operator">=</span> <span class="string">&quot;INSERT INTO user(name, age) VALUES(?, ?)&quot;</span>;</span><br><span class="line">        Object[] params = <span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;user.getName(), user.getAge()&#125;;</span><br><span class="line">        jdbcTemplate.update(sql, params);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> List&lt;User&gt; <span class="title function_">getAllUsers</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">sql</span> <span class="operator">=</span> <span class="string">&quot;SELECT id, name, age FROM user&quot;</span>;</span><br><span class="line">        <span class="keyword">return</span> jdbcTemplate.query(sql, <span class="keyword">new</span> <span class="title class_">BeanPropertyRowMapper</span>&lt;&gt;(User.class));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> User <span class="title function_">getUserById</span><span class="params">(Long id)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">sql</span> <span class="operator">=</span> <span class="string">&quot;SELECT id, name, age FROM user WHERE id=?&quot;</span>;</span><br><span class="line">        Object[] params = <span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;id&#125;;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> jdbcTemplate.queryForObject(sql, params, <span class="keyword">new</span> <span class="title class_">BeanPropertyRowMapper</span>&lt;&gt;(User.class));</span><br><span class="line">        &#125; <span class="keyword">catch</span> (EmptyResultDataAccessException ex) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">deleteUserById</span><span class="params">(Long id)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">sql</span> <span class="operator">=</span> <span class="string">&quot;DELETE FROM user WHERE id=?&quot;</span>;</span><br><span class="line">        Object[] params = <span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;id&#125;;</span><br><span class="line">        jdbcTemplate.update(sql, params);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<div class="note-large notel-yellow"><div class="notel-title"><p>在与<code>Springboot3+</code>整合时注意</p>
</div><div class="notel-content"><ol>
<li>我用Springboot3 在和 5.1.1版本整合时出现了数据源注入失败的问题，经过断点调试发现Springboot3在启动时没有加载shardingSphere5.1.1的自动装配类<code>ShardingSphereAutoConfiguration</code>，所以要在Springboot启动类上加上<code>ShardingSphereAutoConfiguration</code>的路径，以便Springboot3启动时加载。如：</li>
</ol>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication(scanBasePackages = &#123;</span></span><br><span class="line"><span class="meta">        &quot;love.heer.example.shardingspherejdbc&quot;,</span></span><br><span class="line"><span class="meta">        &quot;org.apache.shardingsphere&quot;  // ShardingSphereAutoConfiguration 的源路径</span></span><br><span class="line"><span class="meta">&#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ShardingSphereJdbcDemoApp</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        SpringApplication.run(ShardingSphereJdbcDemoApp.class, args);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<ol start="2">
<li>Springboot 3+ 最佳整合方式，还是使用最新版本的ShardingSphere来进行整合，新版本的整合方法也进行了调整，详情可见<a class="link"   href="https://shardingsphere.apache.org/document/current/cn/quick-start/shardingsphere-jdbc-quick-start/" >官方文档 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>。</li>
</ol>
 </div></div>
<h2 id="总结"><a class="markdownIt-Anchor" href="#总结"></a> 总结</h2>
<p>在本篇博客中，介绍了如何使用Spring Boot 2.7集成ShardingSphere-jdbc5.1.1，并提供了相应的配置文件和Java代码演示，<strong>配置文件比较重要，配置对应的属性时要细心点</strong>。ShardingSphere是一个非常强大的分布式数据库中间件，可以帮助我们处理高并发的数据访问问题。</p>
]]></content>
      <categories>
        <category>ShardingSphere</category>
        <category>ShardingSphereJdbc</category>
      </categories>
      <tags>
        <tag>ShardingSphere</tag>
        <tag>Springboot</tag>
      </tags>
  </entry>
  <entry>
    <title>ShardingSphereJdbc 执行流程</title>
    <url>/posts/61dead18/</url>
    <content><![CDATA[<p>ShardingSphere是一种分布式数据库中间件，为了方便数据分片而设计，ShardingSphere-JDBC5是其中的一个子项目。它提供了对JDBC的扩展，允许在单个逻辑数据源上实现数据分片。</p>
<h2 id="执行流程"><a class="markdownIt-Anchor" href="#执行流程"></a> 执行流程</h2>
<p>ShardingSphere-JDBC主要由两部分组成：客户端和服务端。客户端的作用是将SQL解析后分发给不同的服务节点，服务端负责处理请求并返回结果。下面是执行流程图：</p>
<pre class="mermaid">graph TD;
    User[用户] --> Application(应用)
    
    subgraph ShardingSphereJDBC执行流程 
    Application -- 发起SQL请求 --> Proxy(Proxy) 
    
    Proxy -- 解析SQL --> Router(Router) 
    Proxy -- 执行SQL --> Executor(Executor) 
    
    Router -- 分片规则解析 --> ShardingRule(Sharding Rule) 
    Router -- 路由 --> DataSourceRouter(DataSource Router) 
    
    DataSourceRouter -- 数据源选择 --> DataSource1(数据源1) 
    DataSourceRouter -- 数据源选择 --> DataSource2(数据源2) 
    
    DataSource1 -- 执行SQL --> Database1(Database1) 
    DataSource2 -- 执行SQL --> Database2(Database2) 
    
    Database1 -- 返回结果 --> Executor 
    Database2 -- 返回结果 --> Executor 
    
    Executor -- 结果聚合 --> Proxy 
    Proxy -- 返回结果 --> Application
    end</pre>
<p>以上是整个执行流程，下面将详细介绍每一步的内容。</p>
<h3 id="解析sql"><a class="markdownIt-Anchor" href="#解析sql"></a> 解析SQL</h3>
<p>首先，客户端需要先解析用户提交的SQL语句，这里使用的是JSqlParser这个库。该库能够将SQL语句解析成一个AST（抽象语法树），然后我们可以从AST中提取出所有的表名、列名、操作符等信息。</p>
<h3 id="获取分片规则"><a class="markdownIt-Anchor" href="#获取分片规则"></a> 获取分片规则</h3>
<p>接下来，客户端需要获取分片规则。分片规则是由用户在配置文件中设置的，它指定了数据的分片方式，比如按照ID值进行分片，或者按照日期进行分片。客户端会将这些规则发送给服务端，以便服务端能够正确地处理请求。</p>
<h3 id="生成分片执行计划"><a class="markdownIt-Anchor" href="#生成分片执行计划"></a> 生成分片执行计划</h3>
<p>有了分片规则之后，客户端就可以根据每一条SQL语句生成一个分片执行计划了。执行计划包含了每个分片节点需要执行的SQL语句以及对应的参数值。这里使用了一个叫做ShardingEngine的核心类来生成执行计划。</p>
<h3 id="执行sql"><a class="markdownIt-Anchor" href="#执行sql"></a> 执行SQL</h3>
<p>客户端将执行计划发送到服务端之后，服务端就可以开始执行SQL语句了。服务端会根据执行计划中指定的SQL语句和参数值在对应的数据库节点上执行查询操作，并将结果返回给客户端。</p>
<h3 id="合并结果"><a class="markdownIt-Anchor" href="#合并结果"></a> 合并结果</h3>
<p>由于数据被分散到了多个节点上，所以服务端在执行SQL语句之后，需要将结果合并成一个整体的结果集。这里采用了JDBC的ResultSet接口来实现结果集的合并操作。</p>
<h2 id="总结"><a class="markdownIt-Anchor" href="#总结"></a> 总结</h2>
<p>ShardingSphere-JDBC5是一个非常实用的分布式数据库中间件，它能够帮助我们快速地实现数据分片，提高查询性能和吞吐量。整个项目架构清晰，核心类也比较简单易懂。使用ShardingSphere可以让我们更加专注于业务开发，而不需要过多地关注底层的数据分片实现细节。</p>
]]></content>
      <categories>
        <category>ShardingSphere</category>
        <category>ShardingSphereJdbc</category>
      </categories>
      <tags>
        <tag>ShardingSphere</tag>
      </tags>
  </entry>
  <entry>
    <title>AOP 认识和使用</title>
    <url>/posts/34c58368/</url>
    <content><![CDATA[<p><strong>Spring</strong> 是一个开源的、轻量级的企业级应用框架，提供了多种功能，其中之一就是 <strong>AOP (Aspect Oriented Programming) 面向切面编程</strong>。本文将着重介绍Spring AOP的相关概念、实现和使用方式。</p>
<h2 id="什么是aop"><a class="markdownIt-Anchor" href="#什么是aop"></a> 什么是AOP？</h2>
<p>AOP指“面向切面编程”，是一种编程思想，它通过在需要增强的方法前后插入代码片段（切面），来实现对这些方法的增强。借助 AOP，我们可以将多个对象间共同的关注点（如日志、事务管理等）抽象成一个切面，从而避免代码重复，降低代码的耦合度，并且提高代码的可维护性和可读性。</p>
<h2 id="spring-aop"><a class="markdownIt-Anchor" href="#spring-aop"></a> Spring AOP</h2>
<p>Spring AOP 是基于 AOP 思想的实现，它主要由两部分组成：切面（Aspect）和连接点（Join Point）。其中，切面是定义了增强逻辑的类，连接点是指程序执行过程中能够插入切面的位置。Spring AOP 主要通过创建代理对象来实现增强，代理对象包装了目标对象，并将其与切面进行关联，从而实现增强。</p>
<h3 id="spring-aop-的实现方式"><a class="markdownIt-Anchor" href="#spring-aop-的实现方式"></a> Spring AOP 的实现方式</h3>
<p>Spring AOP 的实现方式主要有两种：XML配置文件和注解。下面我们来逐一介绍。</p>
<h4 id="xml-配置文件"><a class="markdownIt-Anchor" href="#xml-配置文件"></a> XML 配置文件</h4>
<p>在 Spring AOP 中，通过在 XML 配置文件中定义切面和增强逻辑，来描述对象之间的关系。XML 配置文件中主要包含以下几个元素：</p>
<ul>
<li><code>&lt;aop:aspect&gt;</code>：定义一个切面。</li>
<li><code>&lt;aop:pointcut&gt;</code>：定义连接点。</li>
<li><code>&lt;aop:before&gt;</code>：定义前置通知（即方法执行前执行）。</li>
<li><code>&lt;aop:after&gt;</code>：定义后置通知（即方法执行后执行）。</li>
<li><code>&lt;aop:around&gt;</code>：定义环绕通知（即可以在方法执行前后进行操作）。</li>
<li><code>&lt;aop:after-returning&gt;</code>：定义返回通知（即方法执行成功后执行）。</li>
<li><code>&lt;aop:after-throwing&gt;</code>：定义异常通知（即方法出现异常时执行）。</li>
</ul>
<p>下面是一个简单的 XML 配置文件示例：</p>
<div class="highlight-container" data-rel="Xml"><figure class="iseeu highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:aop</span>=<span class="string">&quot;http://www.springframework.org/schema/aop&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd</span></span></span><br><span class="line"><span class="string"><span class="tag">                           http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop.xsd&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 定义目标对象（被代理对象） --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;helloService&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.example.service.impl.HelloServiceImpl&quot;</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 定义切面 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">aop:aspect</span> <span class="attr">id</span>=<span class="string">&quot;loggingAspect&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;helloService&quot;</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 定义连接点 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">aop:pointcut</span> <span class="attr">id</span>=<span class="string">&quot;sayHelloPointcut&quot;</span> <span class="attr">expression</span>=<span class="string">&quot;execution(* com.example.service.HelloService.sayHello(..))&quot;</span> /&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 定义前置通知 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">aop:before</span> <span class="attr">pointcut-ref</span>=<span class="string">&quot;sayHelloPointcut&quot;</span> <span class="attr">method</span>=<span class="string">&quot;beforeSayHello&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">aop:aspect</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure></div>
<h4 id="注解"><a class="markdownIt-Anchor" href="#注解"></a> 注解</h4>
<p>除了使用 XML 配置文件来描述对象之间的关系外，Spring 还支持使用注解的方式来实现 AOP。下面是一些常用的注解：</p>
<ul>
<li><code>@Aspect</code>：定义一个切面。</li>
<li><code>@Pointcut</code>：定义连接点。</li>
<li><code>@Before</code>：定义前置通知。</li>
<li><code>@After</code>：定义后置通知。</li>
<li><code>@Around</code>：定义环绕通知。</li>
<li><code>@AfterReturning</code>：定义返回通知。</li>
<li><code>@AfterThrowing</code>：定义异常</li>
</ul>
<h3 id="spring-aop的使用"><a class="markdownIt-Anchor" href="#spring-aop的使用"></a> Spring AOP的使用</h3>
<p>当使用Spring AOP时，我们可以使用注解来声明切面和通知。以下是一个简单的示例:</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Aspect</span> <span class="comment">// 切面类必须用此注解进行标记</span></span><br><span class="line"><span class="meta">@Component</span> <span class="comment">// 将该切面类纳入Spring容器中管理</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LoggingAspect</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 前置通知，在目标方法执行前执行</span></span><br><span class="line">    <span class="meta">@Before(&quot;execution(* com.example.demo.service.*.*(..))&quot;)</span> </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">logBefore</span><span class="params">(JoinPoint joinPoint)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;前置通知： &quot;</span> + joinPoint.getSignature().getName() + <span class="string">&quot; 方法将被执行&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 后置通知，在目标方法执行完毕后执行</span></span><br><span class="line">    <span class="meta">@AfterReturning(pointcut = &quot;execution(* com.example.demo.service.*.*(..))&quot;, returning = &quot;result&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">logAfterReturning</span><span class="params">(JoinPoint joinPoint, Object result)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;后置通知： &quot;</span> + joinPoint.getSignature().getName() + <span class="string">&quot; 方法已执行完毕，返回值为：&quot;</span> + result);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 异常通知，当目标方法抛出异常时执行</span></span><br><span class="line">    <span class="meta">@AfterThrowing(pointcut = &quot;execution(* com.example.demo.service.*.*(..))&quot;, throwing = &quot;exception&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">logAfterThrowing</span><span class="params">(JoinPoint joinPoint, Exception exception)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;异常通知： &quot;</span> + joinPoint.getSignature().getName() + <span class="string">&quot; 方法发生异常，异常信息为：&quot;</span> + exception.getMessage());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 环绕通知，可以在目标方法执行前和执行后做一些事情</span></span><br><span class="line">    <span class="meta">@Around(&quot;execution(* com.example.demo.service.*.*(..))&quot;)</span> </span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">logAround</span><span class="params">(ProceedingJoinPoint joinPoint)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;环绕通知： &quot;</span> + joinPoint.getSignature().getName() + <span class="string">&quot; 方法开始执行&quot;</span>);</span><br><span class="line">        <span class="type">Object</span> <span class="variable">result</span> <span class="operator">=</span> joinPoint.proceed();</span><br><span class="line">        System.out.println(<span class="string">&quot;环绕通知： &quot;</span> + joinPoint.getSignature().getName() + <span class="string">&quot; 方法已执行完毕，返回值为：&quot;</span> + result);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>在上面的示例中，我们定义了一个切面类<code>LoggingAspect</code>。它使用了四个不同类型的通知（前置，后置，异常和环绕）来记录目标方法的执行情况。</p>
<p>每个注解都有一个<code>pointcut</code>参数，指定了要应用通知的切入点表达式。这里我们使用<code>execution</code>表达式来匹配<code>com.example.demo.service</code>包中所有的方法。</p>
<p>在<code>@AfterReturning</code>和<code>@AfterThrowing</code>注解中，我们还定义了<code>returning</code>和<code>throwing</code>参数，分别用于捕获目标方法的返回值和抛出的异常。</p>
<p>最后，在每个通知的方法体中，我们可以使用<code>JoinPoint</code>或<code>ProceedingJoinPoint</code>对象获取目标方法的信息，并执行需要的业务逻辑。</p>
<h2 id="spring-aop的优点"><a class="markdownIt-Anchor" href="#spring-aop的优点"></a> Spring AOP的优点</h2>
<p>Spring AOP 主要有以下几个优点：</p>
<ol>
<li>降低了代码的耦合度。使用 AOP 可以将多个对象间共同的关注点抽象成一个切面，从而避免代码重复，降低代码的耦合度。</li>
<li>提高了代码的可维护性和可读性。由于增强逻辑被封装在切面中，因此代码的逻辑关系更加清晰，易于理解和维护。</li>
<li>方便进行单元测试。由于对象的创建和依赖关系由 Spring IOC 容器负责管理，因此在进行单元测试时，可以将容器中的对象替换成模拟对象，从而方便地进行测试。</li>
</ol>
<h2 id="总结"><a class="markdownIt-Anchor" href="#总结"></a> 总结</h2>
<p>Spring AOP 是 Spring 框架的核心功能之一，它能够帮助开发者实现代码功能的复用和解耦。通过本文的介绍，我们了解了 Spring AOP 的相关概念、实现方式和使用方法，相信读者已经对 Spring AOP 有了更深入的理解。</p>
]]></content>
      <categories>
        <category>Spring</category>
        <category>基础知识</category>
        <category>AOP</category>
      </categories>
      <tags>
        <tag>Spring</tag>
        <tag>AOP</tag>
      </tags>
  </entry>
  <entry>
    <title>项目纪实-一起观影</title>
    <url>/posts/f3a92809/</url>
    <content><![CDATA[<h2 id="功能需求"><a class="markdownIt-Anchor" href="#功能需求"></a> 功能需求</h2>
<ol>
<li>CP/守护可以邀请对方一起观影</li>
<li>双方进度同步（网络情况等其他因素会导致延迟过大）、设置同步（倍速、更换视频）</li>
</ol>
<h2 id="功能流程"><a class="markdownIt-Anchor" href="#功能流程"></a> 功能流程</h2>
<h3 id="流程图"><a class="markdownIt-Anchor" href="#流程图"></a> 流程图</h3>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="01.jpeg"
                      alt="img" 
                ></p>
<h3 id="流程说明"><a class="markdownIt-Anchor" href="#流程说明"></a> 流程说明</h3>
<ol>
<li>用户邀请CP或者守护一起观影，发送一对一消息给对方；</li>
<li>对方收到消息可以选择同意和拒绝，拒绝后被邀请方不进入观影界面，同意后被邀请方进入观影界面；</li>
<li>双方在观影界面可以选择视频App来选择影片进行投屏观看；</li>
<li>双方在观看时，可以调整进度、播放速度、更换视频操作，这些操作会同步给对方；</li>
<li>一方在观影中退出会提示对方；</li>
<li>双方都退出了观影，整个观影结束。</li>
</ol>
<h2 id="设计"><a class="markdownIt-Anchor" href="#设计"></a> 设计</h2>
<h4 id="设计模型"><a class="markdownIt-Anchor" href="#设计模型"></a> 设计模型</h4>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="02.jpeg"
                      alt="img" 
                ></p>
<h4 id="代码设计"><a class="markdownIt-Anchor" href="#代码设计"></a> 代码设计</h4>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="03.jpeg"
                      alt="img" 
                ></p>
<h4 id="简要说明"><a class="markdownIt-Anchor" href="#简要说明"></a> 简要说明</h4>
<ol>
<li>使用网易云信IM信息服务同步双方状态</li>
<li>将双方客户端一起观影状态抽象成会话<code>session</code>状态，会话状态通过心跳机制维持；</li>
<li>心跳检测机制：客户端通过/allconfig接口获取到心跳频率，服务端每15秒扫描一次客户端存活表（心跳记录表），如果1分钟没有收到客户端心跳，则执行客户端退出逻辑；</li>
<li>心跳表（watch_heart_beat_info）设计成一个观影ID（watchId）同时对应两行（两个客户端）数据，防止更新数据出现锁竞争的情况，降低延迟，增加响应速度；</li>
<li>同步进度的补偿算法：(当前系统的时间戳 - 最近心态包发送到服务器的时间戳) + 最近心跳包中播放的进度 + 866</li>
</ol>
]]></content>
      <categories>
        <category>项目纪实</category>
        <category>一起观影</category>
      </categories>
      <tags>
        <tag>项目纪实</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring 事件</title>
    <url>/posts/f3d2f3e4/</url>
    <content><![CDATA[<p><strong>Spring</strong> 是一个开源的、轻量级的企业级应用框架，提供了多种功能，其中之一就是 <strong>事件机制</strong>。本文将着重介绍Spring事件机制的相关概念、实现和使用方式。</p>
<h2 id="什么是spring事件"><a class="markdownIt-Anchor" href="#什么是spring事件"></a> 什么是Spring事件？</h2>
<p>Spring 事件是指在应用程序中发生的某些事情，比如用户登录、订单提交等，这些事件可以被监听并作出相应的响应。在 Spring 中，我们可以通过创建事件和监听器来实现事件机制。</p>
<h2 id="spring-事件机制"><a class="markdownIt-Anchor" href="#spring-事件机制"></a> Spring 事件机制</h2>
<p>Spring 事件机制主要由三部分组成：事件（Event）、监听器（Listener）和发布者（Publisher）。其中，事件是指发生的某个动作或状态变化，监听器是负责监听事件的对象，发布者则是负责发布事件的对象。</p>
<h3 id="spring-事件的实现方式"><a class="markdownIt-Anchor" href="#spring-事件的实现方式"></a> Spring 事件的实现方式</h3>
<p>Spring 事件的实现方式主要有两种：基于接口的实现和基于注解的实现。下面我们来逐一介绍。</p>
<h4 id="基于接口的实现"><a class="markdownIt-Anchor" href="#基于接口的实现"></a> 基于接口的实现</h4>
<p>在 Spring 中，我们可以通过定义一个继承自 <code>ApplicationEvent</code> 的类来表示一个事件，并通过继承自 <code>ApplicationListener</code> 接口的类来监听该事件。下面是一个使用基于接口实现的示例：</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 定义事件类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserRegisterEvent</span> <span class="keyword">extends</span> <span class="title class_">ApplicationEvent</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">UserRegisterEvent</span><span class="params">(Object source)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(source);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义监听器类</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserRegisterListener</span> <span class="keyword">implements</span> <span class="title class_">ApplicationListener</span>&lt;UserRegisterEvent&gt; &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onApplicationEvent</span><span class="params">(UserRegisterEvent event)</span> &#123;</span><br><span class="line">        <span class="comment">// 处理用户注册事件</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 发布事件</span></span><br><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> ApplicationContext applicationContext;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">registerUser</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 处理用户注册逻辑...</span></span><br><span class="line">    <span class="type">UserRegisterEvent</span> <span class="variable">event</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">UserRegisterEvent</span>(<span class="built_in">this</span>);</span><br><span class="line">    applicationContext.publishEvent(event);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<h4 id="基于注解的实现"><a class="markdownIt-Anchor" href="#基于注解的实现"></a> 基于注解的实现</h4>
<p>在 Spring 4.2 及以上版本中，我们还可以通过使用 <code>@EventListener</code> 注解来声明一个监听器，并使用该注解来监听某个事件。下面是一个使用基于注解实现的示例：</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 定义事件类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserRegisterEvent</span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 发布事件</span></span><br><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> ApplicationEventPublisher publisher;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">registerUser</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 处理用户注册逻辑...</span></span><br><span class="line">    <span class="type">UserRegisterEvent</span> <span class="variable">event</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">UserRegisterEvent</span>();</span><br><span class="line">    publisher.publishEvent(event);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义监听器类</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserRegisterListener</span> &#123;</span><br><span class="line">    <span class="meta">@EventListener</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">handleUserRegisterEvent</span><span class="params">(UserRegisterEvent event)</span> &#123;</span><br><span class="line">        <span class="comment">// 处理用户注册事件</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<h3 id="spring-事件的使用"><a class="markdownIt-Anchor" href="#spring-事件的使用"></a> Spring 事件的使用</h3>
<p>使用 Spring 事件主要分为三步：创建事件、发布事件和监听事件。</p>
<h4 id="创建事件"><a class="markdownIt-Anchor" href="#创建事件"></a> 创建事件</h4>
<p>我们可以通过继承 <code>ApplicationEvent</code> 类来定义自己的事件类型。</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyEvent</span> <span class="keyword">extends</span> <span class="title class_">ApplicationEvent</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String message;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MyEvent</span><span class="params">(Object source, String message)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(source);</span><br><span class="line">        <span class="built_in">this</span>.message = message;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getMessage</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> message;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<h4 id="发布事件"><a class="markdownIt-Anchor" href="#发布事件"></a> 发布事件</h4>
<p>发布事件需要借助 <code>ApplicationEventPublisher</code> 接口，我们可以通过依赖注入来获取它。</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> ApplicationEventPublisher publisher;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">publishMyEvent</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">MyEvent</span> <span class="variable">event</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyEvent</span>(<span class="built_in">this</span>, <span class="string">&quot;Hello, world!&quot;</span>);</span><br><span class="line">    publisher.publishEvent(event);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<h4 id="监听事件"><a class="markdownIt-Anchor" href="#监听事件"></a> 监听事件</h4>
<p>监听事件需要实现 <code>ApplicationListener</code> 接口，并重写 <code>onApplicationEvent()</code> 方法。在 Spring 4.2 及以上版本中，我们也可以使用 <code>@EventListener</code> 注解来监听事件。</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 实现 ApplicationListener 接口</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyEventListener</span> <span class="keyword">implements</span> <span class="title class_">ApplicationListener</span>&lt;MyEvent&gt; &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onApplicationEvent</span><span class="params">(MyEvent event)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Received message: &quot;</span> + event.getMessage());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用 @EventListener 注解</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyEventListener</span> &#123;</span><br><span class="line">    <span class="meta">@EventListener</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">handleMyEvent</span><span class="params">(MyEvent event)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Received message: &quot;</span> + event.getMessage());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<h2 id="spring-事件的优点"><a class="markdownIt-Anchor" href="#spring-事件的优点"></a> Spring 事件的优点</h2>
<p>使用 Spring 事件机制有以下几个优点： 1. 降低了代码的耦合度。通过将事件和监听器分离，使得应用程序中不同部分之间的耦合度降低。 2. 提高了代码的可维护性和可读性。由于事件和监听器被封装成独立的类，因此代码的逻辑关系更加清晰，易于理解和维护。 3. 方便进行单元测试。由于监听器和发布者都是独立的类，因此在进行单元测试时，可以将它们替换成模拟对象，从而方便地进行测试。 ## 总结 Spring 事件机制是 Spring 框架的一个重要功能，它可以帮助开发者实现应用程序中的事件处理和响应。通过本文的介绍，我们了解了 Spring 事件机制的相关概念、实现方式和使用方法，相信读者已经对 Spring 事件机制有了更深入的理解。</p>
]]></content>
      <categories>
        <category>Spring</category>
        <category>基础知识</category>
        <category>事件</category>
      </categories>
      <tags>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring 中的钩子接口</title>
    <url>/posts/25e11da7/</url>
    <content><![CDATA[<blockquote>
<p>在Spring框架中，有许多钩子接口可以让我们在Spring容器的生命周期中添加自定义行为和逻辑。</p>
</blockquote>
<h2 id="有哪些接口"><a class="markdownIt-Anchor" href="#有哪些接口"></a> 有哪些接口？</h2>
<div class="note-large notel-green"><div class="notel-title"><p>常用的钩子接口</p>
</div><div class="notel-content"><ol>
<li><code>BeanFactoryPostProcessor</code>: 实现此接口的类可以修改容器中的BeanDefinition元数据，在Bean实例化之前对其进行修改或添加属性。例如，可以通过该接口将配置文件中的占位符解析为真实的值。</li>
<li><code>BeanPostProcessor</code>: 实现此接口的类可以在每个Bean实例创建后和使用前在其上执行定制化处理。它们可以拦截Bean的创建过程，并返回一个代理对象，以便将其他行为织入到Bean的生命周期中。</li>
<li><code>ApplicationContextAware</code>: 实现此接口的类可以获得正在运行的ApplicationContext实例的引用。这使它们可以与容器交互，例如，查找另一个bean并直接调用其方法。</li>
<li><code>InitializingBean</code>: 实现此接口的类可以在Bean属性设置完毕后，执行任何初始化代码。例如，可以检查必需的属性是否已经配置。</li>
<li><code>DisposableBean</code>: 实现此接口的bean可以在容器销毁时执行清理操作。例如，释放占用的资源或关闭数据库连接等操作。</li>
<li><code>ApplicationListener</code>: 实现此接口的类可以监听应用程序内的事件，如ContextRefreshedEvent、ContextClosedEvent、RequestHandledEvent等。当相应事件发生时，容器将通知所有注册的ApplicationListener实例。</li>
</ol>
 </div></div>
<p>这些钩子接口是Spring框架最常用和最有用的。它们可以让我们在应用程序生命周期中添加各种自定义行为和逻辑，从而使我们的应用程序更加灵活和可扩展。</p>
<h2 id="举个栗子"><a class="markdownIt-Anchor" href="#举个栗子"></a> 举个栗子</h2>
<h3 id="beanfactorypostprocessor"><a class="markdownIt-Anchor" href="#beanfactorypostprocessor"></a> BeanFactoryPostProcessor</h3>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CustomBeanFactoryPostProcessor</span> <span class="keyword">implements</span> <span class="title class_">BeanFactoryPostProcessor</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">postProcessBeanFactory</span><span class="params">(ConfigurableListableBeanFactory beanFactory)</span> <span class="keyword">throws</span> BeansException &#123;</span><br><span class="line">        <span class="comment">// 在Bean实例化之前对其进行修改或添加属性</span></span><br><span class="line">        <span class="type">BeanDefinition</span> <span class="variable">bd</span> <span class="operator">=</span> beanFactory.getBeanDefinition(<span class="string">&quot;myBean&quot;</span>);</span><br><span class="line">        <span class="type">MutablePropertyValues</span> <span class="variable">mpv</span> <span class="operator">=</span> bd.getPropertyValues();</span><br><span class="line">        mpv.addPropertyValue(<span class="string">&quot;customAttribute&quot;</span>, <span class="string">&quot;customValue&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>在上面的示例中，我们实现了<code>BeanFactoryPostProcessor</code>接口，并重写了其中的<code>postProcessBeanFactory</code>方法。通过传入的<code>beanFactory</code>对象，我们可以修改或添加bean的元数据。例如，在这里我们获取名为&quot;myBean&quot;的bean定义，并向其添加一个自定义属性。</p>
<h3 id="beanpostprocessor"><a class="markdownIt-Anchor" href="#beanpostprocessor"></a> BeanPostProcessor</h3>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CustomBeanPostProcessor</span> <span class="keyword">implements</span> <span class="title class_">BeanPostProcessor</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">postProcessBeforeInitialization</span><span class="params">(Object bean, String beanName)</span> <span class="keyword">throws</span> BeansException &#123;</span><br><span class="line">        <span class="comment">// 在Bean实例创建后和使用前在其上执行定制化处理</span></span><br><span class="line">        <span class="keyword">if</span> (bean <span class="keyword">instanceof</span> MyBean) &#123;</span><br><span class="line">            ((MyBean) bean).setCustomAttribute(<span class="string">&quot;customValue&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> bean;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">postProcessAfterInitialization</span><span class="params">(Object bean, String beanName)</span> <span class="keyword">throws</span> BeansException &#123;</span><br><span class="line">        <span class="keyword">return</span> bean;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>在这个示例中，我们实现了<code>BeanPostProcessor</code>接口，并重写了其中的<code>postProcessBeforeInitialization</code>和<code>postProcessAfterInitialization</code>方法。这个接口允许我们拦截bean的创建过程，并在其上执行自定义行为。例如，在这里，我们检查bean是否属于<code>MyBean</code>类型，如果是，则设置一个自定义属性。</p>
<h3 id="applicationcontextaware"><a class="markdownIt-Anchor" href="#applicationcontextaware"></a> ApplicationContextAware</h3>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CustomApplicationContextAware</span> <span class="keyword">implements</span> <span class="title class_">ApplicationContextAware</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> ApplicationContext applicationContext;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setApplicationContext</span><span class="params">(ApplicationContext applicationContext)</span> <span class="keyword">throws</span> BeansException &#123;</span><br><span class="line">        <span class="comment">// 获取正在运行的ApplicationContext实例的引用</span></span><br><span class="line">        <span class="built_in">this</span>.applicationContext = applicationContext;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doSomething</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 与容器交互，例如，查找另一个bean并直接调用其方法</span></span><br><span class="line">        <span class="type">AnotherBean</span> <span class="variable">otherBean</span> <span class="operator">=</span> applicationContext.getBean(AnotherBean.class);</span><br><span class="line">        otherBean.doSomethingElse();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>在这个示例中，我们实现了<code>ApplicationContextAware</code>接口，并重写了其中的<code>setApplicationContext</code>方法。因此，当容器初始化时，Spring将自动调用该方法，传入对正在运行的<code>ApplicationContext</code>实例的引用。我们可以通过这个引用与容器交互，例如，查找另一个bean并调用其方法。</p>
<h3 id="initializingbean"><a class="markdownIt-Anchor" href="#initializingbean"></a> InitializingBean</h3>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CustomInitializingBean</span> <span class="keyword">implements</span> <span class="title class_">InitializingBean</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String requiredProperty;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">afterPropertiesSet</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// 在Bean属性设置完毕后，执行任何初始化代码</span></span><br><span class="line">        <span class="keyword">if</span> (requiredProperty == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(<span class="string">&quot;Required property is not set&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setRequiredProperty</span><span class="params">(String requiredProperty)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.requiredProperty = requiredProperty;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>在这个示例中，我们实现了<code>InitializingBean</code>接口，并重写了其中的<code>afterPropertiesSet</code>方法。当属性设置完毕后，Spring将自动调用该方法。在这里，我们检查必需的属性是否已经配置。</p>
<h3 id="disposablebean"><a class="markdownIt-Anchor" href="#disposablebean"></a> DisposableBean</h3>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Component</span><br><span class="line">public class CustomDisposableBean implements DisposableBean &#123;</span><br><span class="line"></span><br><span class="line">    private Connection connection;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void destroy() throws Exception &#123;</span><br><span class="line">        // 在容器销毁时执行清理操作</span><br><span class="line">        if (connection != null) &#123;</span><br><span class="line">            connection.close();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setConnection(Connection connection) &#123;</span><br><span class="line">        this.connection = connection;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>在这个示例中，我们实现了<code>DisposableBean</code>接口，并重写了其中的<code>destroy</code>方法。当容器销毁时，Spring将自动调用该方法。在这里，我们释放占用的资源或关闭数据库连接等操作。</p>
<h3 id="applicationlistener"><a class="markdownIt-Anchor" href="#applicationlistener"></a> ApplicationListener</h3>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CustomApplicationListener</span> <span class="keyword">implements</span> <span class="title class_">ApplicationListener</span>&lt;ContextRefreshedEvent&gt; &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onApplicationEvent</span><span class="params">(ContextRefreshedEvent event)</span> &#123;</span><br><span class="line">    		<span class="keyword">if</span> (event.getApplicationContext().getParent() == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 监听应用程序内的事件，当ContextRefreshedEvent发生时执行逻辑</span></span><br><span class="line">        		System.out.println(<span class="string">&quot;Application context has been refreshed&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>在这个示例中，我们实现了<code>ApplicationListener</code>接口，并重写了其中的<code>onApplicationEvent</code>方法。这里我们监听了<code>ContextRefreshedEvent</code>事件，在容器刷新时自动调用该方法。在这里，我们检查父容器是否为空，如果是，则输出一条日志消息。这可以防止逻辑重复执行，因为子容器也会触发该事件。</p>
<h2 id="总结"><a class="markdownIt-Anchor" href="#总结"></a> 总结</h2>
<p>总之，Spring框架提供了许多钩子接口，可以让我们在容器的生命周期中添加自定义行为和逻辑。每个接口都有不同的目的和用途，可以根据需要使用。</p>
]]></content>
      <categories>
        <category>Spring</category>
        <category>基础知识</category>
        <category>钩子接口</category>
      </categories>
      <tags>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title>认识 IOC</title>
    <url>/posts/fdde700a/</url>
    <content><![CDATA[<p><strong>Spring</strong> 是一个开源的、轻量级的企业级应用框架，提供了许多常用功能，其中最重要的是 <strong>IOC (Inverse of Control) 控制反转</strong>。本文将着重介绍Spring IOC的相关概念、实现和使用方式。</p>
<h2 id="什么是ioc"><a class="markdownIt-Anchor" href="#什么是ioc"></a> 什么是IOC？</h2>
<p>IOC指“控制反转”，也叫依赖注入（Dependency Injection, DI）。它是一种设计思想，基于这个思想的框架就是IOC容器。在传统的编程中，对象的创建与对象间的依赖关系是由程序员自己管理和维护的。而在IOC容器中，由容器去负责创建对象，并且维护对象之间的依赖关系。</p>
<p>IOC 控制反转的过程：</p>
<pre class="mermaid">graph LR
A[Client] --> B((IOC Container))
B --> C(Service1)
B --> D(Service2)</pre>
<h2 id="spring-ioc容器"><a class="markdownIt-Anchor" href="#spring-ioc容器"></a> Spring IOC容器</h2>
<p>Spring IOC 容器就是一个对象工厂，它负责管理对象的创建、组装、初始化和销毁等过程。Spring 的 IOC 容器可以看做是一个大工厂，工厂里面可以生产各种不同类型的产品（对象），并且负责将这些对象推销出去（注入到其他对象中）。</p>
<h3 id="spring-ioc容器的实现"><a class="markdownIt-Anchor" href="#spring-ioc容器的实现"></a> Spring IOC容器的实现</h3>
<p>Spring IOC容器的实现主要分为两种方式：XML配置文件和注解。下面我们来逐一介绍。</p>
<h4 id="xml-配置文件"><a class="markdownIt-Anchor" href="#xml-配置文件"></a> XML 配置文件</h4>
<p>在 Spring IOC 容器中，通过在 XML 配置文件中定义 bean 来描述对象之间的依赖关系。XML 配置文件中主要包含以下几个元素：</p>
<ul>
<li><code>&lt;beans&gt;</code>：根元素，用于定义 Spring IOC 容器。</li>
<li><code>&lt;bean&gt;</code>：定义一个 bean 对象。</li>
<li><code>&lt;property&gt;</code>：为 bean 设置属性值。</li>
<li><code>&lt;constructor-arg&gt;</code>：通过构造方法注入属性值。</li>
<li><code>&lt;import&gt;</code>：导入其他配置文件。</li>
</ul>
<p>下面是一个简单的 XML 配置文件示例：</p>
<div class="highlight-container" data-rel="Xml"><figure class="iseeu highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 定义一个 HelloServiceImpl 对象 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;helloService&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.example.service.impl.HelloServiceImpl&quot;</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 为 HelloServiceImpl 设置属性值 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;message&quot;</span> <span class="attr">value</span>=<span class="string">&quot;Hello, Spring!&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure></div>
<h4 id="注解"><a class="markdownIt-Anchor" href="#注解"></a> 注解</h4>
<p>除了使用 XML 配置文件来描述对象之间的依赖关系外，Spring 还支持使用注解的方式来实现 IOC。下面是一些常用的注解：</p>
<ul>
<li><code>@Component</code>：标记一个类为组件（即 bean），通常与 <code>@Autowired</code> 一起使用。</li>
<li><code>@Repository</code>：标记一个类为 DAO（数据访问对象）。</li>
<li><code>@Service</code>：标记一个类为服务层组件。</li>
<li><code>@Controller</code>：标记一个类为控制器。</li>
</ul>
<p>下面是一个使用注解的示例：</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Service(&quot;helloService&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HelloServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">HelloService</span> &#123;</span><br><span class="line">    <span class="meta">@Value(&quot;Hello, Spring!&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String message;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sayHello</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(message);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<h3 id="spring-ioc容器的使用"><a class="markdownIt-Anchor" href="#spring-ioc容器的使用"></a> Spring IOC容器的使用</h3>
<p>使用 Spring IOC 容器需要先创建容器对象，然后通过容器对象获取 bean 对象。</p>
<h4 id="创建容器对象"><a class="markdownIt-Anchor" href="#创建容器对象"></a> 创建容器对象</h4>
<p>Spring IOC 容器有两种实现方式：<code>ClassPathXmlApplicationContext</code> 和 <code>AnnotationConfigApplicationContext</code>。其中，<code>ClassPathXmlApplicationContext</code> 用于加载 XML 配置文件，<code>AnnotationConfigApplicationContext</code> 用于加载注解。</p>
<p>下面是一个使用 <code>ClassPathXmlApplicationContext</code> 的示例：</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">ApplicationContext</span> <span class="variable">context</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ClassPathXmlApplicationContext</span>(<span class="string">&quot;classpath:applicationContext.xml&quot;</span>);</span><br></pre></td></tr></table></figure></div>
<h4 id="获取bean对象"><a class="markdownIt-Anchor" href="#获取bean对象"></a> 获取bean对象</h4>
<p>容器对象创建好之后，我们就可以通过其提供的方法来获取 bean 对象了。下面是一些常用的方法：</p>
<ul>
<li>
<p><code>getBean(String name)</code>：</p>
</li>
<li>
<p>根据 bean 的名称（id）获取 bean 对象。</p>
<ul>
<li><code>getBean(Class&lt;T&gt; requiredType)</code>：根据 bean 的类型获取 bean 对象。</li>
<li><code>getBean(String name, Class&lt;T&gt; requiredType)</code>：根据 bean 的名称和类型获取 bean 对象。</li>
</ul>
<p>下面是一个使用 <code>getBean()</code> 方法获取 bean 对象的示例：</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">HelloService</span> <span class="variable">helloService</span> <span class="operator">=</span> context.getBean(<span class="string">&quot;helloService&quot;</span>, HelloService.class);</span><br></pre></td></tr></table></figure></div>
<h2 id="spring-ioc容器的优点"><a class="markdownIt-Anchor" href="#spring-ioc容器的优点"></a> Spring IOC容器的优点</h2>
<p>Spring IOC 容器主要有以下几个优点：</p>
<ol>
<li>降低了组件之间的耦合度，提高了代码的可维护性和灵活性。</li>
<li>可以实现依赖性倒转原则（Dependency Inversion Principle, DIP），即高层模块不依赖于底层模块，两者都依赖于抽象；抽象不依赖于具体实现方式，具体实现方式依赖于抽象。</li>
<li>方便进行单元测试。由于对象的创建和依赖关系由 Spring IOC 容器负责管理，因此在进行单元测试时，可以将容器中的对象替换成模拟对象，从而方便地进行测试。</li>
<li>提高了代码的可读性和可维护性。由于对象之间的依赖关系在 XML 配置文件或注解中明确地表达出来，因此代码的逻辑关系更加清晰，易于理解和维护。</li>
</ol>
<h2 id="总结"><a class="markdownIt-Anchor" href="#总结"></a> 总结</h2>
<p>Spring IOC 容器是 Spring 框架的核心功能之一，它能够帮助开发者管理对象之间的依赖关系，提高代码的可维护性和可读性。通过本文的介绍，我们了解了 Spring IOC 的相关概念、实现方式和使用方法，相信读者已经对 Spring IOC 有了更深入的理解。</p>
</li>
</ul>
]]></content>
      <categories>
        <category>Spring</category>
        <category>基础知识</category>
        <category>IOC</category>
      </categories>
      <tags>
        <tag>Spring</tag>
        <tag>IOC</tag>
      </tags>
  </entry>
  <entry>
    <title>获取 Bean</title>
    <url>/posts/34c58368/</url>
    <content><![CDATA[<p>Spring是一款常用的Java开源框架，提供了强大的依赖注入功能。在Spring应用程序中，属性注入是最常见的特性之一。本篇博文将展示Spring5中五种常见的属性注入方式，包括<code>@Autowired</code>、<code>@Resource</code>、<code>@Inject</code>、<code>构造器注入</code>和<code>Setter方法注入</code>，并对其进行比较和介绍推荐的使用方式。</p>
<h2 id="autowired"><a class="markdownIt-Anchor" href="#autowired"></a> @Autowired</h2>
<p><code>@Autowired</code>是Spring中最常用的自动装配注解。通过<code>@Autowired</code>注解，可以自动将一个bean注入到另一个bean中。它支持基于类型和名称两种自动装配方式。</p>
<h3 id="基于类型的自动装配"><a class="markdownIt-Anchor" href="#基于类型的自动装配"></a> 基于类型的自动装配</h3>
<p>当需要自动将一个bean注入到另一个bean时，Spring会自动扫描容器中所有注册的bean，并根据类型来匹配需要注入的bean。如果有且只有一个bean匹配，则将该bean注入到需要的位置。</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">UserService</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserController</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> UserService userService;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>在上面的例子中，<code>UserController</code>中的<code>userService</code>字段会自动注入<code>UserServiceImpl</code>的实例。</p>
<h3 id="基于名称的自动装配"><a class="markdownIt-Anchor" href="#基于名称的自动装配"></a> 基于名称的自动装配</h3>
<p>当容器中存在多个符合条件的bean时，需要指定要注入的bean的名称。可以在<code>@Autowired</code>注解上使用<code>@Qualifier</code>注解指定需要注入的bean的名称。</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserServiceImpl1</span> <span class="keyword">implements</span> <span class="title class_">UserService</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserServiceImpl2</span> <span class="keyword">implements</span> <span class="title class_">UserService</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserController</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="meta">@Qualifier(&quot;userServiceImpl1&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> UserService userService;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>在上面的例子中，<code>UserController</code>中的<code>userService</code>字段将会自动注入名称为&quot;userServiceImpl1&quot;的bean。</p>
<h3 id="构造器注入"><a class="markdownIt-Anchor" href="#构造器注入"></a> 构造器注入</h3>
<p>构造器注入是一种更加推荐的属性注入方式。通过构造器注入，可以保证依赖项在对象创建时就已经被注入进来了，并且使得对象不可变，从而提高代码的可测试性和可维护性。同时也避免了循环依赖问题。</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserController</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> UserService userService;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">UserController</span><span class="params">(UserService userService)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.userService = userService;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>在上面的例子中，<code>userService</code>依赖项通过构造函数进行注入，确保了用户控制器实例创建时依赖项已经被注入成功。</p>
<h3 id="setter方法注入"><a class="markdownIt-Anchor" href="#setter方法注入"></a> Setter方法注入</h3>
<p>Setter方法注入是一种比较老旧的属性注入方式。虽然它提供了灵活的注入方式，但是Setter方法注入容易造成循环依赖问题，降低代码可测试性和可维护性。</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserController</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> UserService userService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setUserService</span><span class="params">(UserService userService)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.userService = userService;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>在上面的例子中，<code>userService</code>依赖项通过Setter方法进行注入，这种方式可以使用<code>@Autowired</code>注解指定自动注入的bean。</p>
<h2 id="resource"><a class="markdownIt-Anchor" href="#resource"></a> @Resource</h2>
<p><code>@Resource</code>是J2EE的一个标准注解，也可以用于属性注入。和<code>@Autowired</code>一样，它支持基于类型和名称两种自动装配方式。但是，它不支持<code>required</code>属性，所以无法指定是否必须注入。</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserController</span> &#123;</span><br><span class="line">    <span class="meta">@Resource(name = &quot;userServiceImpl1&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> UserService userService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> UserDao userDao;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>在上面的例子中，<code>userService</code>字段将会自动注入名称为&quot;userServiceImpl1&quot;的bean，<code>userDao</code>字段将会自动注入类型为<code>UserDao</code>的bean。</p>
<h2 id="inject"><a class="markdownIt-Anchor" href="#inject"></a> @Inject</h2>
<p><code>@Inject</code>是JSR-330中定义的一种注解，也可以用于属性注入。它和<code>@Autowired</code>的使用方式类似，但在功能上略有不同。它不支持<code>required</code>属性，但可以使用<code>@Nullable</code>或<code>@NotNull</code>注解来指定是否允许注入null值。</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserController</span> &#123;</span><br><span class="line">    <span class="meta">@Inject</span></span><br><span class="line">    <span class="keyword">private</span> UserService userService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Inject</span></span><br><span class="line">    <span class="meta">@NotNull</span></span><br><span class="line">    <span class="keyword">private</span> UserDao userDao;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>在上面的例子中，<code>userService</code>字段将会自动注入类型为<code>UserService</code>的bean，而<code>userDao</code>字段必须被注入，且不允许为null。</p>
<h2 id="推荐的使用方式"><a class="markdownIt-Anchor" href="#推荐的使用方式"></a> 推荐的使用方式</h2>
<p>从可读性、可维护性和可测试性的角度出发，推荐使用构造器注入的方式进行属性注入。通过构造器注入，可以确保依赖项在对象创建时就已经被注入进来了，并且使得对象不可变，从而提高代码的可测试性和可维护性。同时也避免了循环依赖问题。</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserController</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> UserService userService;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">UserController</span><span class="params">(UserService userService)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.userService = userService;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>在上面的例子中，<code>userService</code>依赖项通过构造函数进行注入，确保了用户控制器实例创建时依赖项已经被注入成功。如果必须要使用Setter方法进行属性注入，可以将构造函数和Setter方法结合起来实现。</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserController</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> UserService userService;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">UserController</span><span class="params">()</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setUserService</span><span class="params">(UserService userService)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.userService = userService;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<h2 id="结论"><a class="markdownIt-Anchor" href="#结论"></a> 结论</h2>
<p>以上就是Spring5中常见的属性注入方式：<code>@Autowired</code>、<code>@Resource</code>、<code>@Inject</code>、构造器注入和Setter方法注入。它们都可以自动装配bean，并提供了不同的特性和功能，开发者可以根据自己的需求和偏好选择适合自己的方式来进行属性注入。从可读性、可维护性和可测试性的角度出发，推荐使用构造器注入的方式进行属性注入。</p>
]]></content>
      <categories>
        <category>Spring</category>
        <category>基础知识</category>
        <category>IOC</category>
      </categories>
      <tags>
        <tag>Spring</tag>
        <tag>IOC</tag>
      </tags>
  </entry>
  <entry>
    <title>注入 Bean</title>
    <url>/posts/fb9820ae/</url>
    <content><![CDATA[<p>在Spring框架中，Bean是指Spring容器中的一个对象。而IOC是控制反转，是Spring框架的核心；它通过将对象之间的依赖关系交给容器来管理，从而实现了对象之间的解耦。</p>
<p>而在Spring框架中，Bean的注入方式主要有三种：</p>
<ol>
<li>XML 文件方式</li>
<li>Java 配置类方式</li>
<li>注解方式</li>
</ol>
<p>下面我们分别来详细介绍这三种注入方式。</p>
<h3 id="1-xml-文件方式"><a class="markdownIt-Anchor" href="#1-xml-文件方式"></a> 1. XML 文件方式</h3>
<p>在XML文件中使用 <code>bean</code> 标签定义一个Bean，并且通过 <code>property</code> 标签来设置Bean属性。如下所示：</p>
<div class="highlight-container" data-rel="Xml"><figure class="iseeu highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;user&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.example.User&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;username&quot;</span> <span class="attr">value</span>=<span class="string">&quot;Tom&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span> <span class="attr">value</span>=<span class="string">&quot;123456&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure></div>
<p>上述XML配置表示将一个名为 <code>user</code> 的Bean注入到容器中，并且该Bean的类型为 <code>com.example.User</code>，同时设置了该Bean的两个属性 <code>username</code> 和 <code>password</code>。</p>
<p>在代码中获取该Bean时，只需要通过 <code>getBean</code> 方法即可：</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">ApplicationContext</span> <span class="variable">context</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ClassPathXmlApplicationContext</span>(<span class="string">&quot;applicationContext.xml&quot;</span>);</span><br><span class="line"><span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> (User)context.getBean(<span class="string">&quot;user&quot;</span>);</span><br></pre></td></tr></table></figure></div>
<h3 id="2-java-配置类方式"><a class="markdownIt-Anchor" href="#2-java-配置类方式"></a> 2. Java 配置类方式</h3>
<div class="note note-info icon-padding"><i class="note-icon fa-solid fa-info-circle"></i><p>Springboot 主要使用的方式</p>
</div>
<p>在Java配置类中，使用 <code>@Configuration</code> 注解声明当前类为配置类，然后使用 <code>@Bean</code> 注解定义一个Bean，并且通过 <code>@Autowired</code> 注解来注入依赖。如下所示：</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AppConfig</span> &#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> User <span class="title function_">user</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>();</span><br><span class="line">        user.setUsername(<span class="string">&quot;Tom&quot;</span>);</span><br><span class="line">        user.setPassword(<span class="string">&quot;123456&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> user;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserService</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> User user;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>上述Java配置类中，定义了一个名为 <code>user</code> 的Bean，并且通过 <code>@Autowired</code> 注解将其注入到 <code>UserService</code> 中。</p>
<p>在代码中获取该Bean时，只需要通过 <code>@Autowired</code> 或者 <code>@Resource</code> 注解即可：</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> User user;</span><br></pre></td></tr></table></figure></div>
<h3 id="3-注解方式"><a class="markdownIt-Anchor" href="#3-注解方式"></a> 3. 注解方式</h3>
<p>在Spring框架中，提供了很多注解来实现依赖注入。比如常见的 <code>@Autowired</code>、<code>@Resource</code>、<code>@Inject</code> 等注解。其中 <code>@Autowired</code> 注解是最常用的一种注解，它可以自动注入某个类型的Bean。如下所示：</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserService</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> User user;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>上述代码中，我们使用 <code>@Autowired</code> 注解来注入 <code>User</code> 类型的Bean。</p>
<p>除了 <code>@Autowired</code> 注解外，还有其他注解可以用来实现依赖注入，例如：<code>@Resource</code>、<code>@Inject</code> 等注解。这些注解都能够自动注入某个类型的Bean。</p>
<h2 id="总结"><a class="markdownIt-Anchor" href="#总结"></a> 总结</h2>
<p>以上就是Spring5 IOC Bean 注入的三种方式：XML 文件方式、Java 配置类方式以及注解方式。开发人员可以根据自己的需求来选择最合适的注入方式。</p>
]]></content>
      <categories>
        <category>Spring</category>
        <category>基础知识</category>
        <category>IOC</category>
      </categories>
      <tags>
        <tag>Spring</tag>
        <tag>IOC</tag>
      </tags>
  </entry>
  <entry>
    <title>高可用-容灾</title>
    <url>/posts/87bf88f3/</url>
    <content><![CDATA[<blockquote>
<p>容灾技术是系统的高可用性技术的一个组成部分，容灾系统更加强调处理外界环境对系统的影响，特别是灾难性事件对整个IT节点的影响，提供节点级别的系统恢复功能。故障转移（failover），即当活动的服务或应用意外终止时，快速启用<strong>冗余</strong>或备用的服务器、系统、硬件或者网络接替它们工作。故障恢复是在计划内或计划外中断解决后<strong>切换回主站点</strong>的过程。</p>
</blockquote>
<h2 id="什么是容灾和备份"><a class="markdownIt-Anchor" href="#什么是容灾和备份"></a> 什么是容灾和备份？</h2>
<blockquote>
<p>容灾技术是系统的高可用性技术的一个组成部分，容灾系统更加强调处理外界环境对系统的影响，特别是灾难性事件对整个IT节点的影响，提供节点级别的系统恢复功能。</p>
</blockquote>
<p>容灾备份实际上是两个概念:</p>
<ul>
<li><strong>容灾</strong>是为了在遭遇灾害时能保证信息系统能正常运行，帮助企业实现业务连续性的目标；</li>
<li><strong>备份</strong>是为了应对灾难来临时造成的数据丢失问题。</li>
</ul>
<p>在容灾备份一体化产品出现之前，容灾系统与备份系统是独立的。容灾备份产品的最终目标是帮助企业应对人为误操作、软件错误、病毒入侵等“软”性灾害以及硬件故障、自然灾害等“硬”性灾害。</p>
<h3 id="容灾的分类"><a class="markdownIt-Anchor" href="#容灾的分类"></a> 容灾的分类</h3>
<p>从其对系统的保护程度来分，可以将容灾系统分为:</p>
<ul>
<li><strong>数据级容灾</strong>是指通过建立异地容灾中心，做数据的远程备份，在灾难发生之后要确保原有的数据不会丢失或者遭到破坏，但在数据级容灾这个级别，发生灾难时应用是会中断的。在数据级容灾方式下，所建立的异地容灾中心可以简单地把它理解成一个远程的数据备份中心。数据级容灾的恢复时间比较长，但是相比其他容灾级别来讲它的费用比较低，而且构建实施也相对简单。</li>
<li><strong>应用级容灾</strong>是在数据级容灾的基础之上，在备份站点同样构建一套相同的应用系统，通过同步或异步复制技术，这样可以保证关键应用在允许的时间范围内恢复运行，尽可能减少灾难带来的损失，让用户基本感受不到灾难的发生，这样就使系统所提供的服务是完整的、可靠的和安全的。应用级容灾生产中心和异地灾备中心之间的数据传输是采用异类的广域网传输方式；同时应用级容灾系统需要通过更多的软件来实现，可以使多种应用在灾难发生时可以进行快速切换，确保业务的连续性。</li>
<li><strong>业务级容灾</strong>是全业务的灾备，除了必要的IT相关技术，还要求具备全部的基础设施。其大部分内容是非IT系统（如电话、办公地点等），当大灾难发生后，原有的办公场所都会受到破坏，除了数据和应用的恢复，更需要一个备份的工作场所能够正常的开展业务。</li>
</ul>
<h3 id="容灾的技术指标"><a class="markdownIt-Anchor" href="#容灾的技术指标"></a> 容灾的技术指标</h3>
<blockquote>
<p>主要有RPO（数据恢复点目标）和 RTO（恢复时间目标）, 从客户的角度而言就是RPO需要为0（没有数据丢失），RTO越接近0越好（恢复时间越短越好）。</p>
</blockquote>
<p><strong>RPO（Recovery Point Objective）</strong>：即数据恢复点目标，主要指的是业务系统所能容忍的数据丢失量，指灾难发生后，从IT系统宕机导致业务停顿之时开始，到IT系统恢复至可以支持各部门运作、恢复运营之时，此两点之间的时间段称为RTO，广道容灾备份系统RTO达到分钟级。</p>
<p><strong>RTO（Recovery Time Objective）</strong>：即恢复时间目标，主要指的是所能容忍的业务停止服务的最长时间，也就是从灾难发生到业务系统恢复服务功能所需要的最短时间周期。</p>
<p>指从系统和应用数据而言，要实现能够恢复至可以支持各部门业务运作，系统及生产数据应恢复到怎样的更新程度，这种更新程度可以是上一周的备份数据，也可以是上一次交易的实时数据。</p>
<p>RPO针对的是数据丢失，而RTO针对的是服务丢失，二者没有必然的关联性。RTO和RPO的确定必须在进行风险分析和业务影响分析后根据不同的业务需求确定。对于不同企业的同一种业务，RTO和RPO的需求也会有所不同。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://pdai.tech/images/arch/arch-backup-1.webp"
                      alt="img" 
                ></p>
<h3 id="容灾和容错的区别"><a class="markdownIt-Anchor" href="#容灾和容错的区别"></a> 容灾和容错的区别</h3>
<blockquote>
<p>例子中的图片来源于<a class="link"   href="http://www.pbenson.net/2014/02/the-difference-between-fault-tolerance-high-availability-disaster-recovery/" >这里 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>，能够非常好的帮助你理解。</p>
</blockquote>
<ul>
<li><strong>容灾（Disaster Tolerance）</strong>：就是在上述的灾难发生时，在保证生产系统的数据尽量少丢失的情况下，保持生存系统的业务不间断地运行。容灾通常是通过冗余方式来实现的。</li>
</ul>
<p>举例：飞机上有两个发动机，一个是主发动机，另外一个是备用发动机，主发动机坏了以后，立马切换到备用的发动机。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://pdai.tech/images/arch/arch-backup-4.png"
                      alt="img" 
                ></p>
<ul>
<li><strong>容错（fault tolerance）</strong>: 发生故障时，系统还能继续运行。容错的目的是，发生故障时，系统的运行水平可能有所下降，但是依然可用，不会完全失败。</li>
</ul>
<p>举例：飞机有四个引擎，如果一个引擎坏了，剩下三个引擎，还能继续飞，这就是&quot;容错&quot;。同样的，汽车的一个轮子扎破了，剩下三个轮子，也还是勉强能行驶。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://pdai.tech/images/arch/arch-backup-2.png"
                      alt="img" 
                ></p>
<h3 id="容灾备份的等级"><a class="markdownIt-Anchor" href="#容灾备份的等级"></a> 容灾备份的等级</h3>
<blockquote>
<p>国际标准SHARE 78 对容灾系统的定义有七个层次：从最简单的仅在本地进行磁带备份，到将备份的磁带存储在异地，再到建立应用系统实时切换的异地备份系统，恢复时间也可以从几天到小时级到分钟级、秒级或零数据丢失等。目前针对这七个层次，都有相应的容灾方案，所以，用户在选择容灾方案时应重点区分它们各自的特点和适用范围，结合自己对容灾系统的要求判断选择哪个层次的方案。</p>
</blockquote>
<ul>
<li><strong>0级：无异地备份</strong></li>
</ul>
<p>0等级容灾方案数据仅在本地进行备份，没有在异地备份数据，未制定灾难恢复计划。这种方式是成本最低的灾难恢复解决方案，但不具备真正灾难恢复能力。</p>
<p>在这种容灾方案中，最常用的是备份管理软件加上磁带机，可以是手工加载磁带机或自动加载磁带机。它是所有容灾方案的基础，从个人用户到企业级用户都广泛采用了这种方案。其特点是用户投资较少，技术实现简单。缺点是一旦本地发生毁灭性灾难，将丢失全部的本地备份数据，业务无法恢复。</p>
<ul>
<li><strong>1级：实现异地备份</strong></li>
</ul>
<p>第1级容灾方案是将关键数据备份到本地磁带介质上，然后送往异地保存，但异地没有可用的备份中心、备份数据处理系统和备份网络通信系统，未制定灾难恢复计划。灾难发生后，使用新的主机，利用异地数据备份介质（磁带）将数据恢复起来。</p>
<p>这种方案成本较低，运用本地备份管理软件，可以在本地发生毁灭性灾难后，恢复从异地运送过来的备份数据到本地，进行业务恢复。但难以管理，即很难知道什么数据在什么地方，恢复时间长短依赖于何时硬件平台能够被提供和准备好。以前被许多进行关键业务生产的大企业所广泛采用，作为异地容灾的手段。目前，这一等级方案在许多中小网站和中小企业用户中采用较多。对于要求快速进行业务恢复和海量数据恢复的用户，这种方案是不能够被接受的。</p>
<ul>
<li><strong>2级：热备份站点备份</strong></li>
</ul>
<p>第2级容灾方案是将关键数据进行备份并存放到异地，制定有相应灾难恢复计划，具有热备份能力的站点灾难恢复。一旦发生灾难，利用热备份主机系统将数据恢复。它与第1级容灾方案的区别在于异地有一个热备份站点，该站点有主机系统，平时利用异地的备份管理软件将运送到异地的数据备份介质（磁带）上的数据备份到主机系统。当灾难发生时可以快速接管应用，恢复生产。</p>
<p>由于有了热备中心，用户投资会增加，相应的管理人员要增加。技术实现简单，利用异地的热备份系统，可以在本地发生毁灭性灾难后，快速进行业务恢复。但这种容灾方案由于备份介质是采用交通运输方式送往异地，异地热备中心保存的数据是上一次备份的数据，可能会有几天甚至几周的数据丢失。这对于关键数据的容灾是不能容忍的。</p>
<ul>
<li><strong>3级：在线数据恢复</strong></li>
</ul>
<p>第3级容灾方案是通过网络将关键数据进行备份并存放至异地，制定有相应灾难恢复计划，有备份中心，并配备部分数据处理系统及网络通信系统。该等级方案特点是用电子数据传输取代交通工具传输备份数据，从而提高了灾难恢复的速度。利用异地的备份管理软件将通过网络传送到异地的数据备份到主机系统。一旦灾难发生，需要的关键数据通过网络可迅速恢复，通过网络切换，关键应用恢复时间可降低到一天或小时级。这一等级方案由于备份站点要保持持续运行，对网络的要求较高，因此成本相应有所增加。</p>
<ul>
<li><strong>4级：定时数据备份</strong></li>
</ul>
<p>第4级容灾方案是在第3级容灾方案的基础上，利用备份管理软件自动通过通信网络将部分关键数据定时备份至异地，并制定相应的灾难恢复计划。一旦灾难发生，利用备份中心已有资源及异地备份数据恢复关键业务系统运行。</p>
<p>这一等级方案特点是备份数据是采用自动化的备份管理软件备份到异地，异地热备中心保存的数据是定时备份的数据，根据备份策略的不同，数据的丢失与恢复时间达到天或小时级。由于对备份管理软件设备和网络设备的要求较高，因此投入成本也会增加。但由于该级别备份的特点，业务恢复时间和数据的丢失量还不能满足关键行业对关键数据容灾的要求。</p>
<ul>
<li><strong>5级：实时数据备份</strong></li>
</ul>
<p>第5级容灾方案在前面几个级别的基础上使用了硬件的镜像技术和软件的数据复制技术，也就是说，可以实现在应用站点与备份站点的数据都被更新。数据在两个站点之间相互镜像，由远程异步提交来同步，因为关键应用使用了双重在线存储，所以在灾难发生时，仅仅很小部分的数据被丢失，恢复的时间被降低到了分钟级或秒级。由于对存储系统和数据复制软件的要求较高，所需成本也大大增加。</p>
<p>这一等级的方案由于既能保证不影响当前交易的进行，又能实时复制交易产生的数据到异地，所以这一层次的方案是目前应用最广泛的一类，正因为如此，许多厂商都有基于自己产品的容灾解决方案。如存储厂商EMC等推出的基于智能存储服务器的数据远程拷贝；系统复制软件提供商VERITAS等提供的基于系统软件的数据远程复制；数据库厂商Oracle和Sybase提供的数据库复制方案等。但这些方案有一个不足之处就是异地的备份数据是处于备用（Standby）备份状态而不是实时可用的数据，这样灾难发生后需要一定时间来进行业务恢复。更为理想的应该是备份站点不仅仅是一个分离的备份系统，而且还处于活动状态，能够提供生产应用服务，所以可以提供快速的业务接管，而备份数据则可以双向传输，数据的丢失与恢复时间达到分钟甚至秒级。据了解，目前DSG公司的RealSync全局复制软件能够提供这一功能。</p>
<ul>
<li><strong>6级：零数据丢失</strong></li>
</ul>
<p>第6级容灾方案是灾难恢复中最昂贵的方式，也是速度最快的恢复方式，它是灾难恢复的最高级别，利用专用的存储网络将关键数据同步镜像至备份中心，数据不仅在本地进行确认，而且需要在异地（备份）进行确认。因为，数据是镜像地写到两个站点，所以灾难发生时异地容灾系统保留了全部的数据，实现零数据丢失。</p>
<p>这一方案在本地和远程的所有数据被更新的同时，利用了双重在线存储和完全的网络切换能力，不仅保证数据的完全一致性，而且存储和网络等环境具备了应用的自动切换能力。一旦发生灾难，备份站点不仅有全部的数据，而且应用可以自动接管，实现零数据丢失的备份。通常在这两个系统中的光纤设备连接中还提供冗余通道，以备工作通道出现故障时及时接替工作，当然由于对存储系统和存储系统专用网络的要求很高，用户的投资巨大。采取这种容灾方式的用户主要是资金实力较为雄厚的大型企业和电信级企业。但在实际应用过程中，由于完全同步的方式对生产系统的运行效率会产生很大影响，所以适用于生产交易较少或非实时交易的关键数据系统，目前采用该级别容灾方案的用户还很少。</p>
<h2 id="容灾备份的解决方案"><a class="markdownIt-Anchor" href="#容灾备份的解决方案"></a> 容灾备份的解决方案</h2>
<blockquote>
<p>阿里云的容灾备份解决方案为例。</p>
</blockquote>
<h3 id="ecs的容灾备份"><a class="markdownIt-Anchor" href="#ecs的容灾备份"></a> ECS的容灾备份</h3>
<blockquote>
<p>来源于阿里云<a class="link"   href="https://help.aliyun.com/document_detail/98198.html?spm=5176.22414175.sslink.10.473f5c2de0EUTt" >官方文档 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
</blockquote>
<ul>
<li><strong>备份恢复</strong></li>
</ul>
<p>阿里云ECS可通过<strong>快照</strong>与<strong>镜像</strong>对系统盘、数据盘进行备份。如果存储在磁盘上的数据本身就是错误的数据，例如由于应用错误导致的数据错误，或者黑客利用应用漏洞进行恶意读写，此时就可以使用快照服务将磁盘上的数据恢复到期望的状态。另外ECS可通过镜像重新初始化磁盘或使用自定义镜像新购ECS实例。</p>
<ul>
<li><strong>容灾应用</strong></li>
</ul>
<p>ECS可以从架构上实现容灾场景下的应用。例如，在应用前端购买SLB产品，后端相同应用部署至少两台ECS服务器，或者是使用阿里云的弹性伸缩技术，根据自定义ECS自身资源的使用规则进行弹性扩容。这样即便其中一台ECS服务器故障或者资源利用超负荷，也不会使服务对外终止，从而实现容灾场景下的应用。下图以同城两可用区机房部署ECS集群为例，所有通信均在阿里云千兆内网中完成，响应快速并减少了公网流量费用：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://pdai.tech/images/arch/arch-backup-7.png"
                      alt="img" 
                ></p>
<ol>
<li><strong>负载均衡SLB</strong>：设备侧通过多可用区级别SLB做首层流量接入，用户流量被分发至两个及以上的可用区机房，机房内均部署ECS集群。</li>
<li><strong>ECS集群</strong>：可用区机房部署的ECS节点是对等的，单节点故障不影响数据层应用和服务器管控功能。发生故障后系统会自动热迁移，另外的ECS节点可以持续提供业务访问，防止可能的单点故障或者热迁移失败导致的业务访问中断。热迁移失败后通过系统事件获知故障信息，您可以及时部署新节点。</li>
<li><strong>数据层</strong>：在地域级别部署对象存储，不同可用区机房的ECS节点可以直接读取文件信息。若是数据库应用，使用多可用区ApsaraDB for RDS服务做承载，主节点支持多可用区读写，与应用层流量来源无冲突关系。同时，备节点支持多可用区读能力，防止主节点故障时，ECS无法读取数据。</li>
</ol>
<h3 id="同城容灾"><a class="markdownIt-Anchor" href="#同城容灾"></a> 同城容灾</h3>
<blockquote>
<p>来源于阿里云<a class="link"   href="https://help.aliyun.com/document_detail/419804.html?spm=a2c4g.26937906.0.0.763f292cjWILT6" >官方文档 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
</blockquote>
<p><strong>同城容灾</strong>指应用服务部署是<strong>多机房、单地域</strong>时，当其中一机房出现故障时，系统可实现业务7*24小时稳定运行，即使单机房故障也不影响业务的可持续性，保障用户访问连续不间断。</p>
<p><strong>同城双活容灾</strong>架构，是指在同城建立两个可独立承担关键系统运行的数据中心，双中心具备基本等同的业务处理能力并通过高速链路实时同步数据，日常情况下可同时分担业务及管理系统的运行，并可切换运行；灾难情况下可在基本不丢失数据的情况下进行灾备应急切换，保持业务连续运行。多数企业为了兼顾成本与高可用性问题，会优先选择同城双活的部署方式。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://pdai.tech/images/arch/arch-backup-6.png"
                      alt="img" 
                ></p>
<h3 id="异地容灾两地三中心"><a class="markdownIt-Anchor" href="#异地容灾两地三中心"></a> 异地容灾(两地三中心)</h3>
<blockquote>
<p>来源于阿里云<a class="link"   href="https://help.aliyun.com/practice_detail/419526?spm=a2c4g.26937898.0.0.75ed6fc5iInM61" >官方文档 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
</blockquote>
<p><strong>异地容灾</strong>是指应用服务部署在不同地域时，当其中一地出现故障时，系统可以将出现故障地域的用户访问流量，调度至异地灾备中心，保障用户访问连续不间断。</p>
<p><strong>两地三中心容灾</strong>架构，是指在同城双中心的基础上，在异地的城市建立一个备份的灾备中心，用于双中心的数据备份，当双中心出现自然灾害等原因而发生故障时，异地灾备中心可以用备份数据进行业务的恢复。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://pdai.tech/images/arch/arch-backup-5.png"
                      alt="img" 
                ></p>
<h2 id="故障转移和恢复"><a class="markdownIt-Anchor" href="#故障转移和恢复"></a> 故障转移和恢复</h2>
<h3 id="什么是故障转移"><a class="markdownIt-Anchor" href="#什么是故障转移"></a> 什么是故障转移</h3>
<blockquote>
<p>故障转移（failover），即当活动的服务或应用意外终止时，快速启用冗余或备用的服务器、系统、硬件或者网络接替它们工作。 故障转移(failover)与交换转移操作基本相同，只是故障转移通常是<strong>自动完成</strong>的，没有警告提醒手动完成，而交换转移需要手动进行。</p>
</blockquote>
<p>要使故障转移正常工作，必须有一个数据备份裸机服务器或虚拟机充当恢复站点系统，以便在发生故障时替换主站点。由于故障转移是灾难恢复中必不可少的步骤，因此数据备份系统本身必须不受故障影响。</p>
<p>需要持续可用性的系统需要整体故障转移和灾难恢复。在服务器级别，数据备份环境跟踪主服务器的“脉冲”，并在检测到中断时执行自动故障转移。</p>
<h3 id="如何进行故障转移"><a class="markdownIt-Anchor" href="#如何进行故障转移"></a> 如何进行故障转移</h3>
<blockquote>
<p>有两种方法可以设置故障转移系统：<strong>主动-主动</strong>和<strong>主动-被动</strong>（或主动-备用）配置。两种设置都需要至少两个节点（服务器或虚拟机）才能正常工作。</p>
</blockquote>
<p>在<strong>主动-主动</strong>设置中，多个节点同时运行。这允许他们分担工作量并防止任何一个节点过载。如果一个节点停止工作，它的工作负载将被其他活动节点占用，直到它重新激活。</p>
<p><strong>主动-被动</strong>（主动-备用）设置还包括多个节点，但并非所有节点都同时处于活动状态。一旦主动节点停止工作，被动节点就会被激活并充当故障转移节点。当主节点再次运行时，数据备份节点将操作切换回主节点并再次变为被动状态。</p>
<p>无论采用哪种故障转移方法，两种配置都要求每个节点具有相同的配置。这确保了在站点之间切换时的一致性和稳定性。</p>
<h3 id="什么是故障恢复"><a class="markdownIt-Anchor" href="#什么是故障恢复"></a> 什么是故障恢复</h3>
<blockquote>
<p>故障恢复是在计划内或计划外中断解决后<strong>切换回主站点</strong>的过程。故障恢复通常在故障转移之后作为灾难恢复计划的一部分。</p>
</blockquote>
<p>故障恢复不是完成故障转移的唯一方法。使用虚拟机时，您可以执行永久故障回复，使数据备份虚拟机成为新的主站点。</p>
<h3 id="如何进行故障恢复"><a class="markdownIt-Anchor" href="#如何进行故障恢复"></a> 如何进行故障恢复</h3>
<p>成功执行故障回复需要一些准备。在切换回主站点之前，请考虑以下步骤：</p>
<ol>
<li>检查与主站点的连接的质量和网络带宽。</li>
<li>检查备份站点上的所有数据是否存在潜在错误。这对于关键文件和文档尤其重要。</li>
<li>在开始故障恢复之前彻底测试所有主系统。</li>
<li>准备并实施故障恢复计划，以最大限度地减少停机时间和用户不便。</li>
</ol>
]]></content>
      <categories>
        <category>架构</category>
        <category>高可用</category>
      </categories>
      <tags>
        <tag>架构</tag>
        <tag>高可用</tag>
      </tags>
  </entry>
  <entry>
    <title>高可用-负载均衡</title>
    <url>/posts/12671a/</url>
    <content><![CDATA[<blockquote>
<p>负载均衡（Load Balance），意思是将负载（工作任务，访问请求）进行平衡、分摊到多个操作单元（服务器，组件）上进行执行。是解决高性能，单点故障（高可用），扩展性（水平伸缩）的终极解决方案。</p>
</blockquote>
<h2 id="负载均衡简介"><a class="markdownIt-Anchor" href="#负载均衡简介"></a> 负载均衡简介</h2>
<p>面对大量用户访问、高并发请求，海量数据，可以使用高性能的服务器、大型数据库，存储设备，高性能Web服务器，采用高效率的编程语言比如(Go,Scala)等，当单机容量达到极限时，我们需要考虑业务拆分和分布式部署，来解决大型网站访问量大，并发量高，海量数据的问题。</p>
<p>从单机网站到分布式网站，很重要的区别是业务拆分和分布式部署，将应用拆分后，部署到不同的机器上，实现大规模分布式系统。分布式和业务拆分解决了，从集中到分布的问题，但是每个部署的独立业务还存在单点的问题和访问统一入口问题，为解决单点故障，我们可以采取冗余的方式。将相同的应用部署到多台机器上。解决访问统一入口问题，我们可以在集群前面增加负载均衡设备，实现流量分发。</p>
<p>负载均衡（Load Balance），意思是将负载（工作任务，访问请求）进行平衡、分摊到多个操作单元（服务器，组件）上进行执行。是解决高性能，单点故障（高可用），扩展性（水平伸缩）的终极解决方案。</p>
<h2 id="负载均衡原理"><a class="markdownIt-Anchor" href="#负载均衡原理"></a> 负载均衡原理</h2>
<p>系统的扩展可分为纵向（垂直）扩展和横向（水平）扩展。纵向扩展，是从单机的角度通过增加硬件处理能力，比如CPU处理能力，内存容量，磁盘等方面，实现服务器处理能力的提升，不能满足大型分布式系统（网站），大流量，高并发，海量数据的问题。因此需要采用横向扩展的方式，通过添加机器来满足大型网站服务的处理能力。比如：一台机器不能满足，则增加两台或者多台机器，共同承担访问压力。这就是典型的集群和负载均衡架构：如下图：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://pdai.tech/images/arch/arch-x-lb-1.png"
                      alt="img" 
                ></p>
<ul>
<li><strong>负载均衡的方式</strong></li>
</ul>
<p><strong>应用集群</strong>：将同一应用部署到多台机器上，组成处理集群，接收负载均衡设备分发的请求，进行处理，并返回相应数据。</p>
<p><strong>负载均衡设备</strong>：将用户访问的请求，根据负载均衡算法，分发到集群中的一台处理服务器。（一种把网络请求分散到一个服务器集群中的可用服务器上去的设备）</p>
<ul>
<li><strong>负载均衡的作用</strong>（解决的问题）：</li>
</ul>
<p>1.解决并发压力，提高应用处理性能（增加吞吐量，加强网络处理能力）；</p>
<p>2.提供故障转移，实现高可用；</p>
<p>3.通过添加或减少服务器数量，提供网站伸缩性（扩展性）；</p>
<p>4.安全防护；（负载均衡设备上做一些过滤，黑白名单等处理）</p>
<h2 id="负载均衡分类"><a class="markdownIt-Anchor" href="#负载均衡分类"></a> 负载均衡分类</h2>
<p>根据实现技术不同，可分为DNS负载均衡，HTTP负载均衡，IP负载均衡，链路层负载均衡等。</p>
<h3 id="dns负载均衡"><a class="markdownIt-Anchor" href="#dns负载均衡"></a> DNS负载均衡</h3>
<p>最早的负载均衡技术，利用域名解析实现负载均衡，在DNS服务器，配置多个A记录，这些A记录对应的服务器构成集群。大型网站总是部分使用DNS解析，作为第一级负载均衡。如下图：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://pdai.tech/images/arch/arch-x-lb-2.png"
                      alt="img" 
                ></p>
<ul>
<li>优点
<ul>
<li>使用简单：负载均衡工作，交给DNS服务器处理，省掉了负载均衡服务器维护的麻烦</li>
<li>提高性能：可以支持基于地址的域名解析，解析成距离用户最近的服务器地址，可以加快访问速度，改善性能；</li>
</ul>
</li>
<li>缺点
<ul>
<li><strong>可用性差</strong>：DNS解析是多级解析，新增/修改DNS后，解析时间较长；解析过程中，用户访问网站将失败；</li>
<li><strong>扩展性低</strong>：DNS负载均衡的控制权在域名商那里，无法对其做更多的改善和扩展；</li>
<li><strong>维护性差</strong>：也不能反映服务器的当前运行状态；支持的算法少；不能区分服务器的差异（不能根据系统与服务的状态来判断负载）</li>
</ul>
</li>
</ul>
<p><strong>实践建议</strong></p>
<p>将DNS作为第一级负载均衡，A记录对应着内部负载均衡的IP地址，通过内部负载均衡将请求分发到真实的Web服务器上。一般用于互联网公司，复杂的业务系统不合适使用。如下图：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://pdai.tech/images/arch/arch-x-lb-3.png"
                      alt="img" 
                ></p>
<h3 id="ip负载均衡"><a class="markdownIt-Anchor" href="#ip负载均衡"></a> IP负载均衡</h3>
<p>在网络层通过修改请求目标地址进行负载均衡。</p>
<p>用户请求数据包，到达负载均衡服务器后，负载均衡服务器在操作系统内核进程获取网络数据包，根据负载均衡算法得到一台真实服务器地址，然后将请求目的地址修改为，获得的真实ip地址，不需要经过用户进程处理。</p>
<p>真实服务器处理完成后，响应数据包回到负载均衡服务器，负载均衡服务器，再将数据包源地址修改为自身的ip地址，发送给用户浏览器。如下图：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://pdai.tech/images/arch/arch-x-lb-4.png"
                      alt="img" 
                ></p>
<p>IP负载均衡，真实物理服务器返回给负载均衡服务器，存在两种方式：（1）负载均衡服务器在修改目的ip地址的同时修改源地址。将数据包源地址设为自身盘，即源地址转换（snat）。（2）将负载均衡服务器同时作为真实物理服务器集群的网关服务器。</p>
<ul>
<li>优点
<ul>
<li>在内核进程完成数据分发，比在应用层分发性能更好；</li>
</ul>
</li>
<li>缺点
<ul>
<li>所有请求响应都需要经过负载均衡服务器，集群最大吞吐量受限于负载均衡服务器网卡带宽；</li>
</ul>
</li>
</ul>
<h3 id="链路层负载均衡"><a class="markdownIt-Anchor" href="#链路层负载均衡"></a> 链路层负载均衡</h3>
<p>在通信协议的数据链路层修改mac地址，进行负载均衡。</p>
<p>数据分发时，不修改ip地址，指修改目标mac地址，配置真实物理服务器集群所有机器虚拟ip和负载均衡服务器ip地址一致，达到不修改数据包的源地址和目标地址，进行数据分发的目的。</p>
<p>实际处理服务器ip和数据请求目的ip一致，不需要经过负载均衡服务器进行地址转换，可将响应数据包直接返回给用户浏览器，避免负载均衡服务器网卡带宽成为瓶颈。也称为直接路由模式（DR模式）。如下图：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://pdai.tech/images/arch/arch-x-lb-5.png"
                      alt="img" 
                ></p>
<p>优点：性能好；</p>
<p>缺点：配置复杂；</p>
<p>实践建议：DR模式是目前使用最广泛的一种负载均衡方式。</p>
<h3 id="混合型负载均衡"><a class="markdownIt-Anchor" href="#混合型负载均衡"></a> 混合型负载均衡</h3>
<p>由于多个服务器群内硬件设备、各自的规模、提供的服务等的差异，可以考虑给每个服务器群采用最合适的负载均衡方式，然后又在这多个服务器群间再一次负载均衡或群集起来以一个整体向外界提供服务（即把这多个服务器群当做一个新的服务器群），从而达到最佳的性能。将这种方式称之为混合型负载均衡。</p>
<p>此种方式有时也用于单台均衡设备的性能不能满足大量连接请求的情况下。是目前大型互联网公司，普遍使用的方式。</p>
<p>方式一，如下图：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://pdai.tech/images/arch/arch-x-lb-6.png"
                      alt="img" 
                ></p>
<p>以上模式适合有动静分离的场景，反向代理服务器（集群）可以起到缓存和动态请求分发的作用，当时静态资源缓存在代理服务器时，则直接返回到浏览器。如果动态页面则请求后面的应用负载均衡（应用集群）。</p>
<p>方式二，如下图：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://pdai.tech/images/arch/arch-x-lb-7.png"
                      alt="img" 
                ></p>
<p>以上模式，适合动态请求场景。</p>
<p>因混合模式，可以根据具体场景，灵活搭配各种方式，以上两种方式仅供参考。</p>
<h2 id="常见负载均衡服务器"><a class="markdownIt-Anchor" href="#常见负载均衡服务器"></a> 常见负载均衡服务器</h2>
<p>平时我们常用的有四层负载均衡和七层负载均衡，四层的负载均衡是基于IP和端口实现的，七层的负载均衡是在四层的基础上，基于URL等信息实现。</p>
<h3 id="四层负载均衡"><a class="markdownIt-Anchor" href="#四层负载均衡"></a> 四层负载均衡</h3>
<p>LVS：重量级软件，本身不支持正则表达式，部署起来比较麻烦，但是性能高，应用范围广，一般的大型互联网公司都有用到。</p>
<p>HAProxy：轻量级软件，支持的负载均衡策略非常多，较灵活。</p>
<p>Nginx：轻量级软件，支持的协议少（HTTP、HTTPS和Email协议），对于Session支持不友好。</p>
<h3 id="七层负载均衡"><a class="markdownIt-Anchor" href="#七层负载均衡"></a> 七层负载均衡</h3>
<p>HAProxy：全面支持七层代理，灵活性高，支持Session会话保持。</p>
<p>Nginx：可以针对HTTP应用进行分流，正则规则灵活，支持高并发，部署简单。</p>
<p>Apache：性能较差，一般不考虑。</p>
<p>MySQL Proxy：官方的数据库中间件，可以实现读写分离，负载均衡等功能，但是对分表分库支持不完善（可选替代品：Atlas，Cobar，TDDL）。</p>
<h2 id="常见的负载均衡算法"><a class="markdownIt-Anchor" href="#常见的负载均衡算法"></a> 常见的负载均衡算法</h2>
<p>常见的负载均衡算法包含:</p>
<ul>
<li>轮询法(Round Robin)</li>
<li>加权轮询法(Weight Round Robin)</li>
<li>平滑加权轮询法(Smooth Weight Round Robin)</li>
<li>随机法(Random)</li>
<li>加权随机法(Weight Random)</li>
<li>源地址哈希法(Hash)</li>
<li>最小连接数法(Least Connections)</li>
</ul>
]]></content>
      <categories>
        <category>架构</category>
        <category>高可用</category>
      </categories>
      <tags>
        <tag>架构</tag>
        <tag>高可用</tag>
      </tags>
  </entry>
  <entry>
    <title>高并发-降级和熔断</title>
    <url>/posts/f93a674e/</url>
    <content><![CDATA[<blockquote>
<p>在高并发环境下，<strong>服务之间的依赖关系导致调用失败，解决的方式通常是: 限流-&gt;熔断-&gt;隔离-&gt;降级, 其目的是防止雪崩效应</strong>。</p>
</blockquote>
<h2 id="为什么会有这个话题"><a class="markdownIt-Anchor" href="#为什么会有这个话题"></a> 为什么会有这个话题</h2>
<blockquote>
<p>服务之间的依赖关系导致</p>
</blockquote>
<p>当用户请求 A、P、H、I 四个服务获取数据时，在正常流量下系统稳定运行，如果某天系统进来大量流量，其中服务 I 出现 CPU、内存占用过高等问题，结果导致服务 I 出现延迟、响应过慢，随着请求的持续增加，服务 I 承受不住压力导致内部错误或资源耗尽，一直不响应，此时更糟糕的是其他服务对 I 有依赖，那么这些依赖 I 的服务一直等待 I 的响应，也会出现请求堆积、资源占用，慢慢扩散到所有微服务，引发雪崩效应。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://pdai.tech/images/arch/arch-x-reduce-1.png"
                      alt="img" 
                ></p>
<h2 id="基本的容错模式"><a class="markdownIt-Anchor" href="#基本的容错模式"></a> 基本的容错模式</h2>
<blockquote>
<p>常见的容错模式主要包含以下几种方式</p>
</blockquote>
<ul>
<li>主动超时：Http请求主动设置一个超时时间，超时就直接返回，不会造成服务堆积</li>
<li>限流：限制最大并发数</li>
<li>熔断：当错误数超过阈值时快速失败，不调用后端服务，同时隔一定时间放几个请求去重试后端服务是否能正常调用，如果成功则关闭熔断状态，失败则继续快速失败，直接返回。（此处有个重试，重试就是弹性恢复的能力）</li>
<li>隔离：把每个依赖或调用的服务都隔离开来，防止级联失败引起整体服务不可用</li>
<li>降级：服务失败或异常后，返回指定的默认信息</li>
</ul>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://pdai.tech/images/arch/arch-x-reduce-2.png"
                      alt="img" 
                ></p>
<h2 id="服务降级"><a class="markdownIt-Anchor" href="#服务降级"></a> 服务降级</h2>
<blockquote>
<p>由于爆炸性的流量冲击，对一些服务进行有策略的放弃，以此缓解系统压力，保证目前主要业务的正常运行。它主要是针对非正常情况下的应急服务措施：当此时一些业务服务无法执行时，给出一个统一的返回结果。</p>
</blockquote>
<h3 id="降级服务的特征"><a class="markdownIt-Anchor" href="#降级服务的特征"></a> 降级服务的特征</h3>
<ul>
<li>原因：整体负荷超出整体负载承受能力。</li>
<li>目的：保证重要或基本服务正常运行，非重要服务延迟使用或暂停使用</li>
<li>大小：降低服务粒度，要考虑整体模块粒度的大小，将粒度控制在合适的范围内</li>
<li>可控性：在服务粒度大小的基础上增加服务的可控性，后台服务开关的功能是一项必要配置（单机可配置文件，其他可领用数据库和缓存），可分为手动控制和自动控制。</li>
<li>次序：一般从外围延伸服务开始降级，需要有一定的配置项，重要性低的优先降级，比如可以分组设置等级1-10，当服务需要降级到某一个级别时，进行相关配置</li>
</ul>
<h3 id="降级方式"><a class="markdownIt-Anchor" href="#降级方式"></a> 降级方式</h3>
<ul>
<li>延迟服务：比如发表了评论，重要服务，比如在文章中显示正常，但是延迟给用户增加积分，只是放到一个缓存中，等服务平稳之后再执行。</li>
<li>在粒度范围内关闭服务（片段降级或服务功能降级）：比如关闭相关文章的推荐，直接关闭推荐区</li>
<li>页面异步请求降级：比如商品详情页上有推荐信息/配送至等异步加载的请求，如果这些信息响应慢或者后端服务有问题，可以进行降级；</li>
<li>页面跳转（页面降级）：比如可以有相关文章推荐，但是更多的页面则直接跳转到某一个地址</li>
<li>写降级：比如秒杀抢购，我们可以只进行Cache的更新，然后异步同步扣减库存到DB，保证最终一致性即可，此时可以将DB降级为Cache。</li>
<li>读降级：比如多级缓存模式，如果后端服务有问题，可以降级为只读缓存，这种方式适用于对读一致性要求不高的场景。</li>
</ul>
<h3 id="降级预案"><a class="markdownIt-Anchor" href="#降级预案"></a> 降级预案</h3>
<p>在进行降级之前要对系统进行梳理，看看系统是不是可以丢卒保帅；从而梳理出哪些必须誓死保护，哪些可降级；比如可以参考日志级别设置预案：</p>
<ul>
<li>一般：比如有些服务偶尔因为网络抖动或者服务正在上线而超时，可以自动降级；</li>
<li>警告：有些服务在一段时间内成功率有波动（如在95~100%之间），可以自动降级或人工降级，并发送告警；</li>
<li>错误：比如可用率低于90%，或者数据库连接池被打爆了，或者访问量突然猛增到系统能承受的最大阀值，此时可以根据情况自动降级或者人工降级；</li>
<li>严重错误：比如因为特殊原因数据错误了，此时需要紧急人工降级。</li>
</ul>
<h3 id="服务降级分类"><a class="markdownIt-Anchor" href="#服务降级分类"></a> 服务降级分类</h3>
<ul>
<li>降级按照是否自动化可分为：自动开关降级（超时、失败次数、故障、限流）和人工开关降级（秒杀、电商大促等）。</li>
<li>降级按照功能可分为：读服务降级、写服务降级。</li>
<li>降级按照处于的系统层次可分为：多级降级。</li>
</ul>
<h3 id="自动降级分类"><a class="markdownIt-Anchor" href="#自动降级分类"></a> 自动降级分类</h3>
<ul>
<li>超时降级：主要配置好超时时间和超时重试次数和机制，并使用异步机制探测回复情况</li>
<li>失败次数降级：主要是一些不稳定的api，当失败调用次数达到一定阀值自动降级，同样要使用异步机制探测回复情况</li>
<li>故障降级：比如要调用的远程服务挂掉了（网络故障、DNS故障、http服务返回错误的状态码、rpc服务抛出异常），则可以直接降级。降级后的处理方案有：默认值（比如库存服务挂了，返回默认现货）、兜底数据（比如广告挂了，返回提前准备好的一些静态页面）、缓存（之前暂存的一些缓存数据）</li>
<li>限流降级: 当我们去秒杀或者抢购一些限购商品时，此时可能会因为访问量太大而导致系统崩溃，此时开发者会使用限流来进行限制访问量，当达到限流阀值，后续请求会被降级；降级后的处理方案可以是：排队页面（将用户导流到排队页面等一会重试）、无货（直接告知用户没货了）、错误页（如活动太火爆了，稍后重试）</li>
</ul>
<h3 id="服务降级需考虑的问题"><a class="markdownIt-Anchor" href="#服务降级需考虑的问题"></a> 服务降级需考虑的问题</h3>
<ul>
<li>核心服务或非核心服务。</li>
<li>是否支持降级，及其降级策略。</li>
<li>业务放通场景，极其策略。</li>
</ul>
<h2 id="服务熔断"><a class="markdownIt-Anchor" href="#服务熔断"></a> 服务熔断</h2>
<blockquote>
<p>熔断这一概念来源于电子工程中的断路器（Circuit Breaker）。在互联网系统中，当下游服务因访问压力过大而响应变慢或失败，上游服务为了保护系统整体的可用性，可以暂时切断对下游服务的调用。</p>
</blockquote>
<h3 id="相关概念"><a class="markdownIt-Anchor" href="#相关概念"></a> 相关概念</h3>
<blockquote>
<p>在学习服务熔断时，有必要区分下如下几个相关的概念。</p>
</blockquote>
<ul>
<li>服务雪崩</li>
</ul>
<p>多个微服务之间调用的时候，假设微服务A调用微服务B和微服务C，微服务B和微服务C有调用其他的微服务，如果整个链路上某个微服务的调用响应式过长或者不可用，对微服务A的调用就会占用越来越多的系统资源，进而引起系统雪崩，所谓的”雪崩效应”</p>
<ul>
<li>断路器</li>
</ul>
<p>“断路器”本身是一种开关装置，当某个服务单元发生故障监控(类似熔断保险丝)，向调用方法返回一个符合预期的、可处理的备选响应(FallBack)，而不是长时间的等待或者抛出调用方法无法处理的异常，这样就保证了服务调用方的线程不会被长时间、不必要地占用，从而避免了故障在分布式系统中的蔓延。乃至雪崩。</p>
<ul>
<li>服务熔断</li>
</ul>
<p>熔断机制是应对雪崩效应的一种微服务链路保护机制，当整个链路的某个微服务不可用或者响应时间太长时，会进行服务的降级，进而熔断该节点微服务的调用，快速返回”错误”的响应信息。</p>
<ul>
<li>Hystrix</li>
</ul>
<p>Hystrix是一个用于分布式系统的延迟和容错的开源库。在分布式系统里，许多依赖不可避免的调用失败，比如超时、异常等，Hystrix能够保证在一个依赖出问题的情况下，不会导致整个服务失败，避免级联故障，以提高分布式系统的弹性。</p>
<h3 id="熔断流程"><a class="markdownIt-Anchor" href="#熔断流程"></a> 熔断流程</h3>
<blockquote>
<p>上述概念中，我们知道熔断流程通常通过断路器（Curcuit Breaker）模式实现，那断路器模式的熔断流程是怎么样的呢？</p>
</blockquote>
<h4 id="基本的断路器模式"><a class="markdownIt-Anchor" href="#基本的断路器模式"></a> 基本的断路器模式</h4>
<p>基本的断路器（Curcuit Breaker）结构如下：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://pdai.tech/images/arch/arch-x-reduce-3.png"
                      alt="img" 
                ></p>
<p>它有两个基本状态（close和open）和一个基本trip动作：</p>
<ul>
<li>close状态下， client向supplier发起的服务请求， 直接无阻碍通过断路器， supplier的返回值接直接由断路器交回给client.</li>
<li>open状态下，client向supplier发起的服务请求后，断路器不会将请求转到supplier, 而是直接返回client, client和supplier之间的通路是断的</li>
<li>trip: 在close状态下，如果supplier持续超时报错， 达到规定的阀值后，断路器就发生trip, 之后断路器状态就会从close进入open.</li>
</ul>
<h4 id="扩展的断路器模式"><a class="markdownIt-Anchor" href="#扩展的断路器模式"></a> 扩展的断路器模式</h4>
<p>基本的断路器模式下，保证了断路器在open状态时，保护supplier不会被调用， 但我们还需要额外的措施可以在supplier恢复服务后，可以重置断路器。一种可行的办法是断路器定期探测supplier的服务是否恢复， 一但恢复， 就将状态设置成close。断路器进行重试时的状态为半开（half-open）状态。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://pdai.tech/images/arch/arch-x-reduce-31.png"
                      alt="img" 
                ></p>
<h3 id="服务熔断与服务降级比较"><a class="markdownIt-Anchor" href="#服务熔断与服务降级比较"></a> 服务熔断与服务降级比较</h3>
<p>服务熔断对服务提供了proxy，防止服务不可能时，出现串联故障（cascading failure），导致雪崩效应。</p>
<p><strong>服务熔断一般是某个服务（下游服务）故障引起，而服务降级一般是从整体负荷考虑</strong>。</p>
<ul>
<li>共性：
<ul>
<li>目的 -&gt; 都是从可用性、可靠性出发，提高系统的容错能力。</li>
<li>最终表现-&gt;使某一些应用不可达或不可用，来保证整体系统稳定。</li>
<li>粒度 -&gt; 一般都是服务级别，但也有细粒度的层面：如做到数据持久层、只许查询不许增删改等。</li>
<li>自治 -&gt; 对其自治性要求很高。都要求具有较高的自动处理机制。</li>
</ul>
</li>
<li>区别：
<ul>
<li>触发原因 -&gt; 服务熔断通常是下级服务故障引起；服务降级通常为整体系统而考虑。</li>
<li>管理目标 -&gt; 熔断是每个微服务都需要的，是一个框架级的处理；而服务降级一般是关注业务，对业务进行考虑，抓住业务的层级，从而决定在哪一层上进行处理：比如在IO层，业务逻辑层，还是在外围进行处理。</li>
<li>实现方式 -&gt; 代码实现中的差异。</li>
</ul>
</li>
</ul>
<h3 id="服务熔断中需考虑的设计"><a class="markdownIt-Anchor" href="#服务熔断中需考虑的设计"></a> 服务熔断中需考虑的设计</h3>
<p>源自博主张善友的观点：</p>
<ul>
<li><strong>异常处理</strong>：调用受熔断器保护的服务的时候，我们必须要处理当服务不可用时的异常情况。这些异常处理通常需要视具体的业务情况而定。比如，如果应用程序只是暂时的功能降级，可能需要切换到其它的可替换的服务上来执行相同的任务或者获取相同的数据，或者给用户报告错误然后提示他们稍后重试。</li>
<li><strong>异常的类型</strong>：请求失败的原因可能有很多种。一些原因可能会比其它原因更严重。比如，请求会失败可能是由于远程的服务崩溃，这可能需要花费数分钟来恢复；也可能是由于服务器暂时负载过重导致超时。熔断器应该能够检查错误的类型，从而根据具体的错误情况来调整策略。比如，可能需要很多次超时异常才可以断定需要切换到断开状态，而只需要几次错误提示就可以判断服务不可用而快速切换到断开状态。</li>
<li><strong>日志</strong>：熔断器应该能够记录所有失败的请求，以及一些可能会尝试成功的请求，使得的管理员能够监控使用熔断器保护的服务的执行情况。 测试服务是否可用：在断开状态下，熔断器可以采用定期的ping远程的服务或者资源，来判断是否服务是否恢复，而不是使用计时器来自动切换到半断开状态。这种ping操作可以模拟之前那些失败的请求，或者可以使用通过调用远程服务提供的检查服务是否可用的方法来判断。</li>
<li><strong>手动重置</strong>：在系统中对于失败操作的恢复时间是很难确定的，提供一个手动重置功能能够使得管理员可以手动的强制将熔断器切换到闭合状态。同样的，如果受熔断器保护的服务暂时不可用的话，管理员能够强制的将熔断器设置为断开状态。 并发问题：相同的熔断器有可能被大量并发请求同时访问。熔断器的实现不应该阻塞并发的请求或者增加每次请求调用的负担。 资源的差异性：使用单个熔断器时，一个资源如果有分布在多个地方就需要小心。比如，一个数据可能存储在多个磁盘分区上(shard)，某个分区可以正常访问，而另一个可能存在暂时性的问题。在这种情况下，不同的错误响应如果混为一谈，那么应用程序访问的这些存在问题的分区的失败的可能性就会高，而那些被认为是正常的分区，就有可能被阻塞。</li>
<li><strong>加快熔断器的熔断操作</strong>:有时候，服务返回的错误信息足够让熔断器立即执行熔断操作并且保持一段时间。比如，如果从一个分布式资源返回的响应提示负载超重，那么应该等待几分钟后再重试。（HTTP协议定义了”HTTP 503 Service Unavailable”来表示请求的服务当前不可用，他可以包含其他信息比如，超时等）</li>
<li><strong>重复失败请求</strong>：当熔断器在断开状态的时候，熔断器可以记录每一次请求的细节，而不是仅仅返回失败信息，这样当远程服务恢复的时候，可以将这些失败的请求再重新请求一次。</li>
</ul>
<h3 id="服务熔断恢复需注意的问题"><a class="markdownIt-Anchor" href="#服务熔断恢复需注意的问题"></a> 服务熔断恢复需注意的问题</h3>
<p>如果服务是幂等性的，则恢复重试不会有问题；而如果服务是非幂等性的，则重试会导致数据出现问题。</p>
<h2 id="方案hystrix简介"><a class="markdownIt-Anchor" href="#方案hystrix简介"></a> 方案：Hystrix简介</h2>
<blockquote>
<p>Spring Cloud Netflix Hystrix就是隔离措施的一种实现,可以设置在某种超时或者失败情形下断开依赖调用或者返回指定逻辑,从而提高分布式系统的稳定性.</p>
</blockquote>
<h3 id="hystrix设计原则"><a class="markdownIt-Anchor" href="#hystrix设计原则"></a> Hystrix设计原则</h3>
<ul>
<li>防止单个服务的故障，耗尽整个系统服务的容器（比如tomcat）的线程资源，避免分布式环境里大量级联失败。通过第三方客户端访问（通常是通过网络）依赖服务出现失败、拒绝、超时或短路时执行回退逻辑</li>
<li>用快速失败代替排队(每个依赖服务维护一个小的线程池或信号量，当线程池满或信号量满，会立即拒绝服务而不会排队等待)和优雅的服务降级；当依赖服务失效后又恢复正常，快速恢复</li>
<li>提供接近实时的监控和警报，从而能够快速发现故障和修复。监控信息包括请求成功，失败（客户端抛出的异常），超时和线程拒绝。如果访问依赖服务的错误百分比超过阈值,断路器会跳闸，此时服务会在一段时间内停止对特定服务的所有请求</li>
<li>将所有请求外部系统（或请求依赖服务）封装到HystrixCommand或HystrixObservableCommand对象中，然后这些请求在一个独立的线程中执行。使用隔离技术来限制任何一个依赖的失败对系统的影响。每个依赖服务维护一个小的线程池（或信号量），当线程池满或信号量满，会立即拒绝服务而不会排队等待</li>
</ul>
<h3 id="hystrix特性"><a class="markdownIt-Anchor" href="#hystrix特性"></a> Hystrix特性</h3>
<ul>
<li>请求熔断： 当Hystrix Command请求后端服务失败数量超过一定比例(默认50%), 断路器会切换到开路状态(Open). 这时所有请求会直接失败而不会发送到后端服务. 断路器保持在开路状态一段时间后(默认5秒), 自动切换到半开路状态(HALF-OPEN).</li>
</ul>
<p>这时会判断下一次请求的返回情况, 如果请求成功, 断路器切回闭路状态(CLOSED), 否则重新切换到开路状态(OPEN). Hystrix的断路器就像我们家庭电路中的保险丝, 一旦后端服务不可用, 断路器会直接切断请求链, 避免发送大量无效请求影响系统吞吐量, 并且断路器有自我检测并恢复的能力.</p>
<ul>
<li>服务降级：Fallback相当于是降级操作. 对于查询操作, 我们可以实现一个fallback方法, 当请求后端服务出现异常的时候, 可以使用fallback方法返回的值. fallback方法的返回值一般是设置的默认值或者来自缓存.告知后面的请求服务不可用了，不要再来了。</li>
<li>依赖隔离(采用舱壁模式，Docker就是舱壁模式的一种)：在Hystrix中, 主要通过线程池来实现资源隔离. 通常在使用的时候我们会根据调用的远程服务划分出多个线程池.比如说，一个服务调用两外两个服务，你如果调用两个服务都用一个线程池，那么如果一个服务卡在哪里，资源没被释放</li>
</ul>
<p>后面的请求又来了，导致后面的请求都卡在哪里等待，导致你依赖的A服务把你卡在哪里，耗尽了资源，也导致了你另外一个B服务也不可用了。这时如果依赖隔离，某一个服务调用A B两个服务，如果这时我有100个线程可用，我给A服务分配50个，给B服务分配50个，这样就算A服务挂了，我的B服务依然可以用。</p>
<ul>
<li>请求缓存：比如一个请求过来请求我userId=1的数据，你后面的请求也过来请求同样的数据，这时我不会继续走原来的那条请求链路了，而是把第一次请求缓存过了，把第一次的请求结果返回给后面的请求。</li>
<li>请求合并：我依赖于某一个服务，我要调用N次，比如说查数据库的时候，我发了N条请求发了N条SQL然后拿到一堆结果，这时候我们可以把多个请求合并成一个请求，发送一个查询多条数据的SQL的请求，这样我们只需查询一次数据库，提升了效率。</li>
</ul>
<h3 id="hystrix流程"><a class="markdownIt-Anchor" href="#hystrix流程"></a> Hystrix流程</h3>
<p>Hystrix流程图如下：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://pdai.tech/images/arch/arch-x-reduce-4.png"
                      alt="img" 
                ></p>
<p>Hystrix流程说明:</p>
<ul>
<li>1:每次调用创建一个新的HystrixCommand,把依赖调用封装在run()方法中.</li>
<li>2:执行execute()/queue做同步或异步调用.</li>
<li>4:判断熔断器(circuit-breaker)是否打开,如果打开跳到步骤8,进行降级策略,如果关闭进入步骤5.</li>
<li>5:判断线程池/队列/信号量是否跑满，如果跑满进入降级步骤8,否则继续后续步骤6.</li>
<li>6:调用HystrixCommand的run方法.运行依赖逻辑
<ul>
<li>6a:依赖逻辑调用超时,进入步骤8.</li>
</ul>
</li>
<li>7:判断逻辑是否调用成功
<ul>
<li>7a:返回成功调用结果</li>
<li>7b:调用出错，进入步骤8.</li>
</ul>
</li>
<li>8:计算熔断器状态,所有的运行状态(成功, 失败, 拒绝,超时)上报给熔断器，用于统计从而判断熔断器状态.</li>
<li>9:getFallback()降级逻辑.
<ul>
<li>以下四种情况将触发getFallback调用：
<ul>
<li>(1):run()方法抛出非HystrixBadRequestException异常。</li>
<li>(2):run()方法调用超时</li>
<li>(3):熔断器开启拦截调用</li>
<li>(4):线程池/队列/信号量是否跑满</li>
</ul>
</li>
<li>9a:没有实现getFallback的Command将直接抛出异常</li>
<li>9b:fallback降级逻辑调用成功直接返回</li>
<li>9c:降级逻辑调用失败抛出异常</li>
</ul>
</li>
<li>10:返回执行成功结果</li>
</ul>
<p>这里接着前面的Ribbon进行Hystrix集成。说白了你想对一个请求进行熔断，必然不能让客户直接去调用那个请求，你必然要要对别人的请求进行包装一层和拦截，才能做点手脚，比如进行熔断，所以说要在Ribbon上动手脚。因为它是请求发起的地方。 我们刚开始请求一个服务，为了负载均衡进行了拦截一次，现在我们要进行熔断，所以必须跟Ribbon集成一次，再进行请求拦截来熔断。</p>
<h3 id="hystrix测试说明"><a class="markdownIt-Anchor" href="#hystrix测试说明"></a> Hystrix测试说明</h3>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://pdai.tech/images/arch/arch-x-reduce-5.png"
                      alt="img" 
                ></p>
<h2 id="方案sentinel简介"><a class="markdownIt-Anchor" href="#方案sentinel简介"></a> 方案：Sentinel简介</h2>
<blockquote>
<p>Sentinel 是阿里中间件团队开源的，面向分布式服务架构的轻量级高可用流量控制组件，主要以流量为切入点，从流量控制、熔断降级、系统负载保护等多个维度来帮助用户保护服务的稳定性。</p>
</blockquote>
<h3 id="sentinel特征"><a class="markdownIt-Anchor" href="#sentinel特征"></a> Sentinel特征</h3>
<ul>
<li>丰富的应用场景：Sentinel 承接了阿里巴巴近 10 年的双十一大促流量的核心场景，例如秒杀（即突发流量控制在系统容量可以承受的范围）、消息削峰填谷、集群流量控制、实时熔断下游不可用应用等。</li>
<li>完备的实时监控：Sentinel 同时提供实时的监控功能。您可以在控制台中看到接入应用的单台机器秒级数据，甚至 500 台以下规模的集群的汇总运行情况。</li>
<li>广泛的开源生态：Sentinel 提供开箱即用的与其它开源框架/库的整合模块，例如与 Spring Cloud、Dubbo、gRPC 的整合。您只需要引入相应的依赖并进行简单的配置即可快速地接入 Sentinel。</li>
<li>完善的 SPI 扩展点：Sentinel 提供简单易用、完善的 SPI 扩展接口。您可以通过实现扩展接口来快速地定制逻辑。例如定制规则管理、适配动态数据源等。</li>
</ul>
<p>Sentinel 的主要特性：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://pdai.tech/images/arch/arch-x-reduce-6.png"
                      alt="img" 
                ></p>
<p>Sentinel 的开源生态：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://pdai.tech/images/arch/arch-x-reduce-7.png"
                      alt="img" 
                ></p>
<p>Sentinel 分为两个部分:</p>
<ul>
<li>核心库（Java 客户端）不依赖任何框架/库，能够运行于所有 Java 运行时环境，同时对 Dubbo / Spring Cloud 等框架也有较好的支持。</li>
<li>控制台（Dashboard）基于 Spring Boot 开发，打包后可以直接运行，不需要额外的 Tomcat 等应用容器。</li>
</ul>
]]></content>
      <categories>
        <category>架构</category>
        <category>高并发</category>
      </categories>
      <tags>
        <tag>架构</tag>
        <tag>高并发</tag>
      </tags>
  </entry>
  <entry>
    <title>高并发-限流</title>
    <url>/posts/ac85553a/</url>
    <content><![CDATA[<blockquote>
<p>每个系统都有服务的上线，所以当流量超过服务极限能力时，系统可能会出现卡死、崩溃的情况，所以就有了降级和限流。限流其实就是：当高并发或者瞬时高并发时，为了保证系统的稳定性、可用性，系统以牺牲部分请求为代价或者延迟处理请求为代价，保证系统整体服务可用。</p>
</blockquote>
<h3 id="算法"><a class="markdownIt-Anchor" href="#算法"></a> 算法</h3>
<p>令牌桶(Token Bucket)、漏桶(leaky bucket)和计数器算法是最常用的三种限流的算法。</p>
<h3 id="分类"><a class="markdownIt-Anchor" href="#分类"></a> 分类</h3>
<h4 id="应用级-单机"><a class="markdownIt-Anchor" href="#应用级-单机"></a> 应用级 - 单机</h4>
<p>应用级限流方式只是单应用内的请求限流，不能进行全局限流。</p>
<ol>
<li>限流总资源数</li>
<li>限流总并发/连接/请求数</li>
<li>限流某个接口的总并发/请求数</li>
<li>限流某个接口的时间窗请求数</li>
<li>平滑限流某个接口的请求数</li>
<li>Guava RateLimiter</li>
</ol>
<p>####S 分布式</p>
<p>我们需要<strong>分布式限流</strong>和<strong>接入层限流</strong>来进行全局限流。</p>
<ol>
<li>redis+lua实现中的lua脚本</li>
<li>使用Nginx+Lua实现的Lua脚本</li>
<li>使用 OpenResty 开源的限流方案</li>
<li>限流框架，比如Sentinel实现降级限流熔断</li>
</ol>
<h2 id="方案一令牌桶方式token-bucket"><a class="markdownIt-Anchor" href="#方案一令牌桶方式token-bucket"></a> 方案一：令牌桶方式(Token Bucket)</h2>
<blockquote>
<p>令牌桶算法是网络流量整形（Traffic Shaping）和速率限制（Rate Limiting）中最常使用的一种算法。先有一个木桶，系统按照固定速度，往桶里加入Token，如果桶已经满了就不再添加。当有请求到来时，会各自拿走一个Token，取到Token 才能继续进行请求处理，没有Token 就拒绝服务。</p>
</blockquote>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://pdai.tech/images/arch/arch-xianliu-1.png"
                      alt="img" 
                ></p>
<p>这里如果一段时间没有请求时，桶内就会积累一些Token，下次一旦有突发流量，只要Token足够，也能一次处理，所以令牌桶算法的特点是<em>允许突发流量</em>。</p>
<h3 id="举例guava-ratelimiter-平滑突发限流smoothbursty"><a class="markdownIt-Anchor" href="#举例guava-ratelimiter-平滑突发限流smoothbursty"></a> 举例：Guava RateLimiter - 平滑突发限流(SmoothBursty)</h3>
<blockquote>
<p>Guava RateLimiter提供了令牌桶算法实现：平滑突发限流(SmoothBursty)和平滑预热限流(SmoothWarmingUp)实现。</p>
</blockquote>
<ul>
<li>Case 1</li>
</ul>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">RateLimiter</span> <span class="variable">limiter</span> <span class="operator">=</span> RateLimiter.create(<span class="number">5</span>);</span><br><span class="line">System.out.println(limiter.acquire());</span><br><span class="line">System.out.println(limiter.acquire());</span><br><span class="line">System.out.println(limiter.acquire());</span><br><span class="line">System.out.println(limiter.acquire());</span><br><span class="line">System.out.println(limiter.acquire());</span><br><span class="line">System.out.println(limiter.acquire());</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将得到类似如下的输出：</span></span><br><span class="line"><span class="number">0.0</span></span><br><span class="line"><span class="number">0.198239</span></span><br><span class="line"><span class="number">0.196083</span></span><br><span class="line"><span class="number">0.200609</span></span><br><span class="line"><span class="number">0.199599</span></span><br><span class="line"><span class="number">0.19961</span></span><br></pre></td></tr></table></figure></div>
<p>1、RateLimiter.create(5)表示桶容量为5且每秒新增5个令牌，即每隔200毫秒新增一个令牌；</p>
<p>2、limiter.acquire()表示消费一个令牌，如果当前桶中有足够令牌则成功（返回值为0），如果桶中没有令牌则暂停一段时间，比如发令牌间隔是200毫秒，则等待200毫秒后再去消费令牌（如上测试用例返回的为0.198239，差不多等待了200毫秒桶中才有令牌可用），这种实现将突发请求速率平均为了固定请求速率。如果结构不想等待可以采用tryAcquire立刻返回！</p>
<ul>
<li>Case 2 - RateLimiter的突发情况处理:</li>
</ul>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">RateLimiter</span> <span class="variable">limiter</span> <span class="operator">=</span> RateLimiter.create(<span class="number">5</span>);</span><br><span class="line">System.out.println(limiter.acquire(<span class="number">5</span>));</span><br><span class="line">System.out.println(limiter.acquire(<span class="number">1</span>));</span><br><span class="line">System.out.println(limiter.acquire(<span class="number">1</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将得到类似如下的输出：</span></span><br><span class="line"><span class="number">0.0</span></span><br><span class="line"><span class="number">0.98745</span></span><br><span class="line"><span class="number">0.183553</span></span><br><span class="line"><span class="number">0.199909</span></span><br></pre></td></tr></table></figure></div>
<p>limiter.acquire(5)表示桶的容量为5且每秒新增5个令牌，令牌桶算法允许一定程度的突发，所以可以一次性消费5个令牌，但接下来的limiter.acquire(1)将等待差不多1秒桶中才能有令牌，且接下来的请求也整形为固定速率了。</p>
<ul>
<li>Case 3 - RateLimiter的突发情况处理:</li>
</ul>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">RateLimiter</span> <span class="variable">limiter</span> <span class="operator">=</span> RateLimiter.create(<span class="number">5</span>);</span><br><span class="line">System.out.println(limiter.acquire(<span class="number">10</span>));</span><br><span class="line">System.out.println(limiter.acquire(<span class="number">1</span>));</span><br><span class="line">System.out.println(limiter.acquire(<span class="number">1</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将得到类似如下的输出：</span></span><br><span class="line"><span class="number">0.0</span></span><br><span class="line"><span class="number">1.997428</span></span><br><span class="line"><span class="number">0.192273</span></span><br><span class="line"><span class="number">0.200616</span></span><br></pre></td></tr></table></figure></div>
<p>同上边的例子类似，第一秒突发了10个请求，令牌桶算法也允许了这种突发（允许消费未来的令牌），但接下来的limiter.acquire(1)将等待差不多2秒桶中才能有令牌，且接下来的请求也整形为固定速率了。</p>
<ul>
<li>Case 4</li>
</ul>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">RateLimiter</span> <span class="variable">limiter</span> <span class="operator">=</span> RateLimiter.create(<span class="number">2</span>);</span><br><span class="line">System.out.println(limiter.acquire());</span><br><span class="line">Thread.sleep(<span class="number">2000L</span>);</span><br><span class="line">System.out.println(limiter.acquire());</span><br><span class="line">System.out.println(limiter.acquire());</span><br><span class="line">System.out.println(limiter.acquire());</span><br><span class="line">System.out.println(limiter.acquire());</span><br><span class="line">System.out.println(limiter.acquire());</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将得到类似如下的输出：</span></span><br><span class="line"><span class="number">0.0</span></span><br><span class="line"><span class="number">0.0</span></span><br><span class="line"><span class="number">0.0</span></span><br><span class="line"><span class="number">0.0</span></span><br><span class="line"><span class="number">0.499876</span></span><br><span class="line"><span class="number">0.495799</span></span><br></pre></td></tr></table></figure></div>
<p>1、创建了一个桶容量为2且每秒新增2个令牌； 2、首先调用limiter.acquire()消费一个令牌，此时令牌桶可以满足（返回值为0）； 3、然后线程暂停2秒，接下来的两个limiter.acquire()都能消费到令牌，第三个limiter.acquire()也同样消费到了令牌，到第四个时就需要等待500毫秒了。</p>
<p>此处可以看到我们设置的桶容量为2（即允许的突发量），这是因为SmoothBursty中有一个参数：最大突发秒数（maxBurstSeconds）默认值是1s，突发量/桶容量=速率*maxBurstSeconds，所以本示例桶容量/突发量为2，例子中前两个是消费了之前积攒的突发量，而第三个开始就是正常计算的了。令牌桶算法允许将一段时间内没有消费的令牌暂存到令牌桶中，留待未来使用，并允许未来请求的这种突发.</p>
<p>SmoothBursty通过平均速率和最后一次新增令牌的时间计算出下次新增令牌的时间的，另外需要一个桶暂存一段时间内没有使用的令牌（即可以突发的令牌数）。另外RateLimiter还提供了tryAcquire方法来进行无阻塞或可超时的令牌消费。</p>
<p>因为SmoothBursty允许一定程度的突发，会有人担心如果允许这种突发，假设突然间来了很大的流量，那么系统很可能扛不住这种突发。因此需要一种平滑速率的限流工具，从而系统冷启动后慢慢的趋于平均固定速率（即刚开始速率小一些，然后慢慢趋于我们设置的固定速率）。Guava也提供了SmoothWarmingUp来实现这种需求类似漏桶算法;</p>
<h3 id="举例guava-ratelimiter-smoothwarmingup"><a class="markdownIt-Anchor" href="#举例guava-ratelimiter-smoothwarmingup"></a> 举例：Guava RateLimiter - SmoothWarmingUp</h3>
<p>SmoothWarmingUp创建方式：RateLimiter.create(doublepermitsPerSecond, long warmupPeriod, TimeUnit unit)</p>
<p>permitsPerSecond表示每秒新增的令牌数，warmupPeriod表示在从冷启动速率过渡到平均速率的时间间隔。</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">RateLimiter</span> <span class="variable">limiter</span> <span class="operator">=</span> RateLimiter.create(<span class="number">5</span>,<span class="number">1000</span>, TimeUnit.MILLISECONDS);</span><br><span class="line"><span class="keyword">for</span>(inti =<span class="number">1</span>; i &lt; <span class="number">5</span>;i++) &#123;</span><br><span class="line">    System.out.println(limiter.acquire());</span><br><span class="line">&#125;</span><br><span class="line">Thread.sleep(<span class="number">1000L</span>);</span><br><span class="line"><span class="keyword">for</span>(inti =<span class="number">1</span>; i &lt; <span class="number">5</span>;i++) &#123;</span><br><span class="line">    System.out.println(limiter.acquire());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将得到类似如下的输出：</span></span><br><span class="line"><span class="number">0.0</span></span><br><span class="line"><span class="number">0.51767</span></span><br><span class="line"><span class="number">0.357814</span></span><br><span class="line"><span class="number">0.219992</span></span><br><span class="line"><span class="number">0.199984</span></span><br><span class="line"><span class="number">0.0</span></span><br><span class="line"><span class="number">0.360826</span></span><br><span class="line"><span class="number">0.220166</span></span><br><span class="line"><span class="number">0.199723</span></span><br><span class="line"><span class="number">0.199555</span></span><br></pre></td></tr></table></figure></div>
<p>速率是梯形上升速率的，也就是说冷启动时会以一个比较大的速率慢慢到平均速率；然后趋于平均速率（梯形下降到平均速率）。可以通过调节warmupPeriod参数实现一开始就是平滑固定速率。</p>
<h2 id="方案二漏桶方式"><a class="markdownIt-Anchor" href="#方案二漏桶方式"></a> 方案二：漏桶方式</h2>
<p>水(请求)先进入到漏桶里,漏桶以一定的速度出水(接口有响应速率),当水流入速度过大会直接溢出（访问频率超过接口响应速率),然后就拒绝请求,可以看出漏桶算法能强行限制数据的传输速率。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://pdai.tech/images/arch/arch-xianliu-2.png"
                      alt="img" 
                ></p>
<p>可见这里有两个变量,一个是桶的大小,支持流量突发增多时可以存多少的水(burst),另一个是水桶漏洞的大小(rate)。</p>
<p>因为漏桶的漏出速率是固定的参数,所以,即使网络中不存在资源冲突(没有发生拥塞),漏桶算法也不能使流突发(burst)到端口速率.因此,漏桶算法对于存在突发特性的流量来说缺乏效率.</p>
<h3 id="令牌桶和漏桶对比"><a class="markdownIt-Anchor" href="#令牌桶和漏桶对比"></a> 令牌桶和漏桶对比</h3>
<ul>
<li>令牌桶是按照固定速率往桶中添加令牌，请求是否被处理需要看桶中令牌是否足够，当令牌数减为零时则拒绝新的请求；</li>
<li>漏桶则是按照常量固定速率流出请求，流入请求速率任意，当流入的请求数累积到漏桶容量时，则新流入的请求被拒绝；</li>
<li>令牌桶限制的是平均流入速率（允许突发请求，只要有令牌就可以处理，支持一次拿3个令牌，4个令牌），并允许一定程度突发流量；</li>
<li>漏桶限制的是常量流出速率（即流出速率是一个固定常量值，比如都是1的速率流出，而不能一次是1，下次又是2），从而平滑突发流入速率；</li>
<li>令牌桶允许一定程度的突发，而漏桶主要目的是平滑流入速率；</li>
<li>两个算法实现可以一样，但是方向是相反的，对于相同的参数得到的限流效果是一样的。</li>
</ul>
<h2 id="方案三计数器方式"><a class="markdownIt-Anchor" href="#方案三计数器方式"></a> 方案三：计数器方式</h2>
<p>计数器限流算法也是比较常用的，主要用来限制总并发数，比如数据库连接池大小、线程池大小、程序访问并发数等都是使用计数器算法。也是最简单粗暴的算法。</p>
<h3 id="采用atomicinteger"><a class="markdownIt-Anchor" href="#采用atomicinteger"></a> 采用AtomicInteger</h3>
<p>使用AomicInteger来进行统计当前正在并发执行的次数，如果超过域值就简单粗暴的直接响应给用户，说明系统繁忙，请稍后再试或其它跟业务相关的信息。</p>
<p>弊端：使用 AomicInteger 简单粗暴超过域值就拒绝请求，可能只是瞬时的请求量高，也会拒绝请求。</p>
<p>###S 采用令牌Semaphore</p>
<p>使用Semaphore信号量来控制并发执行的次数，如果超过域值信号量，则进入阻塞队列中排队等待获取信号量进行执行。如果阻塞队列中排队的请求过多超出系统处理能力，则可以在拒绝请求。</p>
<p>相对Atomic优点：如果是瞬时的高并发，可以使请求在阻塞队列中排队，而不是马上拒绝请求，从而达到一个流量削峰的目的。</p>
<h3 id="采用threadpoolexecutor-java线程池"><a class="markdownIt-Anchor" href="#采用threadpoolexecutor-java线程池"></a> 采用ThreadPoolExecutor java线程池</h3>
<p>固定线程池大小,超出固定先线程池和最大的线程数,拒绝线程请求;</p>
<h2 id="压力测试"><a class="markdownIt-Anchor" href="#压力测试"></a> 压力测试</h2>
<blockquote>
<p>给个思路</p>
</blockquote>
<ul>
<li>Linux AB</li>
</ul>
<p>可以参考<a href="">Linux - ab压力测试</a></p>
<ul>
<li>写代码</li>
</ul>
<p>比如：</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SneakyThrows</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">(<span class="type">int</span> clientSize)</span> &#123;</span><br><span class="line">    <span class="type">CountDownLatch</span> <span class="variable">downLatch</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CountDownLatch</span>(clientSize);</span><br><span class="line">    <span class="type">ExecutorService</span> <span class="variable">fixedThreadPool</span> <span class="operator">=</span> Executors.newFixedThreadPool(clientSize);</span><br><span class="line">    IntStream.range(<span class="number">0</span>, clientSize).forEach(i -&gt;</span><br><span class="line">            fixedThreadPool.submit(() -&gt; &#123;</span><br><span class="line">                <span class="type">RestTemplate</span> <span class="variable">restTemplate</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RestTemplate</span>();</span><br><span class="line">                restTemplate.getForObject(<span class="string">&quot;http://localhost:8080/limit1&quot;</span>, ResponseResult.class);</span><br><span class="line">                downLatch.countDown();</span><br><span class="line">            &#125;)</span><br><span class="line">    );</span><br><span class="line">    downLatch.await();</span><br><span class="line">    fixedThreadPool.shutdown();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<ul>
<li>其它测试工具，LoadRunner，Jmeter…</li>
</ul>
]]></content>
      <categories>
        <category>架构</category>
        <category>高并发</category>
      </categories>
      <tags>
        <tag>架构</tag>
        <tag>高并发</tag>
      </tags>
  </entry>
  <entry>
    <title>Java17环境配置- MacOS</title>
    <url>/posts/21377094/</url>
    <content><![CDATA[<p>Java 17 是一种新版本的Java开发环境，使用 Java 17 进行程序开发时需要在计算机上安装 Java 17 环境。本文将介绍如何在 MacOS 中配置 Java 17环境。</p>
<h2 id="macos系统中配置java-17环境"><a class="markdownIt-Anchor" href="#macos系统中配置java-17环境"></a> MacOS系统中配置Java 17环境：</h2>
<h3 id="1-下载java-17安装包"><a class="markdownIt-Anchor" href="#1-下载java-17安装包"></a> 1. 下载Java 17安装包。</h3>
<p>在<a class="link"   href="https://www.oracle.com/java/technologies/javase/jdk17-archive-downloads.html" >Oracle官网 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>上下载 Java 17<br />
的安装包，选择与MacOS系统相应的版本。</p>
<h3 id="2-安装-java-17"><a class="markdownIt-Anchor" href="#2-安装-java-17"></a> 2. 安装 Java 17。</h3>
<p>双击下载好的 Java 17 安装包，按照步骤进行安装即可。</p>
<h3 id="3-配置环境变量"><a class="markdownIt-Anchor" href="#3-配置环境变量"></a> 3. 配置环境变量。</h3>
<div class="tabs" id="tab-first-unique-01"><ul class="nav-tabs"><li class="tab active"><a class="#first-unique-01-1">macOS 10.15+（zsh）</a></li><li class="tab"><a class="#first-unique-01-2">macOS 10.15之前（bash）</a></li></ul><div class="tab-content"><div class="tab-pane active" id="first-unique-01-1"><ol>
<li>
<p>打开<i class="fa-solid fa-rectangle-terminal"></i><code>Terminal</code>（中文叫<code>终端</code>）应用程序。</p>
</li>
<li>
<p>在命令行输入以下命令，编辑<code>~/.zshrc</code>文件：</p>
<div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="code"><pre><span class="line">nano ~/.zshrc </span><br></pre></td></tr></table></figure></div>
</li>
<li>
<p>在文件的最后，加入如下信息</p>
<div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="code"><pre><span class="line">export PATH=&quot;/Library/Java/JavaVirtualMachines/jdk-17.jdk/Contents/Home/bin:$PATH&quot;</span><br></pre></td></tr></table></figure></div>
</li>
<li>
<p>按下“Ctrl+X”键，选择“Y”保存文件并按“Enter”键退出编辑。</p>
</li>
<li>
<p>执行以下命令让修改后的环境变量生效：</p>
<div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="code"><pre><span class="line">source ~/.zshrc</span><br></pre></td></tr></table></figure></div>
</li>
<li>
<p>验证Java 17是否配置成功。</p>
<div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="code"><pre><span class="line">java -version</span><br><span class="line"></span><br><span class="line">java version &quot;17.0.1&quot; 2021-01-17 LTS</span><br><span class="line">Java(TM) SE Runtime Environment (build 17.0.1+9-LTS-190)</span><br><span class="line">Java HotSpot(TM) 64-Bit Server VM (build 17.0.1+9-LTS-190, mixed mode, sharing)</span><br></pre></td></tr></table></figure></div>
</li>
</ol></div><div class="tab-pane" id="first-unique-01-2"><ol>
<li>
<p>打开<i class="fa-solid fa-rectangle-terminal"></i><code>Terminal</code>（中文叫<code>终端</code>）应用程序。</p>
</li>
<li>
<p>在命令行输入以下命令，编辑<code>~/.bash_profile</code>文件：</p>
<div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="code"><pre><span class="line">nano ~/.bash_profile</span><br></pre></td></tr></table></figure></div>
</li>
<li>
<p>在文件的最后，加入如下信息</p>
<div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="code"><pre><span class="line">export PATH=&quot;/Library/Java/JavaVirtualMachines/jdk-17.jdk/Contents/Home/bin:$PATH&quot;</span><br></pre></td></tr></table></figure></div>
</li>
<li>
<p>按下“Ctrl+X”键，选择“Y”保存文件并按“Enter”键退出编辑。</p>
</li>
<li>
<p>执行以下命令让修改后的环境变量生效：</p>
<div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="code"><pre><span class="line">source ~/.bash_profile</span><br></pre></td></tr></table></figure></div>
</li>
<li>
<p>验证Java 17是否配置成功。</p>
<div class="highlight-container" data-rel="Shell"><figure class="iseeu highlight shell"><table><tr><td class="code"><pre><span class="line">java -version</span><br><span class="line"></span><br><span class="line">java version &quot;17.0.1&quot; 2021-01-17 LTS</span><br><span class="line">Java(TM) SE Runtime Environment (build 17.0.1+9-LTS-190)</span><br><span class="line">Java HotSpot(TM) 64-Bit Server VM (build 17.0.1+9-LTS-190, mixed mode, sharing)</span><br></pre></td></tr></table></figure></div>
</li>
</ol></div></div></div>
<h3 id="4-配置完成"><a class="markdownIt-Anchor" href="#4-配置完成"></a> 4. 配置完成</h3>
<p>经过上诉步骤操作完成后，我们就可以子啊本地计算机进行Java程序的开发了。</p>
]]></content>
      <categories>
        <category>Java</category>
        <category>Java 环境</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Java 环境配置</tag>
      </tags>
  </entry>
  <entry>
    <title>Java8 - 日期时间API</title>
    <url>/posts/de0f09f0/</url>
    <content><![CDATA[<p><code>Java 8</code>新增了一套全新的时间API，这些API让我们能够更方便地进行日期和时间的处理。在Java 8之前，日期和时间的操作大多是基于<code>java.util.Date</code>和<code>java.util.Calendar</code>类，但这些类存在很多问题，比如线程不安全、可变性等，同时也缺乏一些常见的操作。</p>
<h2 id="优势"><a class="markdownIt-Anchor" href="#优势"></a> 优势</h2>
<p>Java 8时间操作类的设计理念是围绕着不可变性、线程安全性和清晰易用性来展开的。Java 8时间操作类的主要优势如下：</p>
<ol>
<li><code>不可变性</code>：Java 8时间操作类中的所有类都是不可变的，即它们的方法都不会改变原实例的状态，而是返回一个新的实例。这种不可变性使得Java 8时间操作类线程安全，可以在多线程环境下使用。</li>
<li><code>线程安全性</code>：Java 8时间操作类的所有类都是线程安全的，因为它们是不可变的。在多线程环境下，多个线程可以同时读取同一个实例，而不需要担心数据竞争等线程安全问题。</li>
<li><code>清晰易用性</code>：Java 8时间操作类提供了丰富的API，可以完成各种常见的日期和时间操作。它们的方法名和参数都非常易懂，使得编写代码更加简洁易读。</li>
</ol>
<h2 id="主要类"><a class="markdownIt-Anchor" href="#主要类"></a> 主要类</h2>
<p>Java 8时间操作类中主要包括如下几个类：</p>
<ol>
<li><code>LocalDate</code>：表示一个日期，例如2020-05-14。它提供了各种方法来操作日期，比如加减天数、月份和年份等。</li>
<li><code>LocalTime</code>：表示一个时间，例如23:59:59.999。它提供了各种方法来操作时间，比如加减小时、分钟和秒等。</li>
<li><code>LocalDateTime</code>：表示一个日期和时间，例如2019-11-03T23:59:59.999。它同时包含了日期和时间的信息，提供了各种方法来操作日期和时间。</li>
<li><code>Instant</code>：表示一个时间戳，即从1970年1月1日开始经过的秒数。它可以用来计算两个时间点之间的时间差，或者将时间戳转换为日期和时间格式。</li>
<li><code>Duration</code>：表示一个时间段，例如2小时30分钟。它提供了各种方法来操作时间段，比如加减时间、获取时间段的总秒数等。</li>
<li><code>Period</code>：表示一个日期段，例如3年2个月1天。它提供了各种方法来操作日期段，比如加减日期、获取日期段的总天数等。</li>
</ol>
<h2 id="使用示例"><a class="markdownIt-Anchor" href="#使用示例"></a> 使用示例</h2>
<h3 id="localdate"><a class="markdownIt-Anchor" href="#localdate"></a> LocalDate</h3>
<div class="note note-info icon-padding"><i class="note-icon fa-solid fa-info-circle"></i><p>日期操作</p>
</div>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LocalDateDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 使用now()方法创建当前日期实例</span></span><br><span class="line">        <span class="type">LocalDate</span> <span class="variable">today</span> <span class="operator">=</span> LocalDate.now();</span><br><span class="line">        <span class="comment">// 当前日期是: 2020-05-14</span></span><br><span class="line">        System.out.println(<span class="string">&quot;当前日期是: &quot;</span> + today); </span><br><span class="line"></span><br><span class="line">        <span class="comment">// 使用of()方法创建指定日期实例</span></span><br><span class="line">        <span class="type">LocalDate</span> <span class="variable">date1</span> <span class="operator">=</span> LocalDate.of(<span class="number">2019</span>, <span class="number">10</span>, <span class="number">1</span>);</span><br><span class="line">        <span class="comment">// 指定日期是: 2019-10-01</span></span><br><span class="line">        System.out.println(<span class="string">&quot;指定日期是: &quot;</span> + date1); </span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取年份、月份和天数</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">year</span> <span class="operator">=</span> today.getYear();</span><br><span class="line">        <span class="type">int</span> <span class="variable">month</span> <span class="operator">=</span> today.getMonthValue();</span><br><span class="line">        <span class="type">int</span> <span class="variable">day</span> <span class="operator">=</span> today.getDayOfMonth();</span><br><span class="line">        System.out.printf(<span class="string">&quot;今天是%d年%d月%d日%n&quot;</span>, year, month, day);  <span class="comment">// 今天是2020年5月14日</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 加减天数</span></span><br><span class="line">        <span class="type">LocalDate</span> <span class="variable">tomorrow</span> <span class="operator">=</span> today.plusDays(<span class="number">1</span>);</span><br><span class="line">        <span class="type">LocalDate</span> <span class="variable">yesterday</span> <span class="operator">=</span> today.minusDays(<span class="number">1</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;明天是：&quot;</span> + tomorrow);  <span class="comment">// 明天是：2020-05-15</span></span><br><span class="line">        System.out.println(<span class="string">&quot;昨天是：&quot;</span> + yesterday);  <span class="comment">// 昨天是：2020-05-13</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 判断是否为闰年</span></span><br><span class="line">        <span class="type">boolean</span> <span class="variable">isLeapYear</span> <span class="operator">=</span> today.isLeapYear();</span><br><span class="line">        <span class="comment">// 今年是否是闰年：true</span></span><br><span class="line">        System.out.println(<span class="string">&quot;今年是否是闰年：&quot;</span> + isLeapYear);  </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<h3 id="localtime"><a class="markdownIt-Anchor" href="#localtime"></a> LocalTime</h3>
<div class="note note-info icon-padding"><i class="note-icon fa-solid fa-info-circle"></i><p>时间操作</p>
</div>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LocalTimeDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 使用now()方法创建当前时间实例</span></span><br><span class="line">        <span class="type">LocalTime</span> <span class="variable">now</span> <span class="operator">=</span> LocalTime.now();</span><br><span class="line">        System.out.println(<span class="string">&quot;现在是: &quot;</span> + now);  <span class="comment">// 现在是: 20:07:25.797</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 使用of()方法创建指定时间实例</span></span><br><span class="line">        <span class="type">LocalTime</span> <span class="variable">time1</span> <span class="operator">=</span> LocalTime.of(<span class="number">8</span>, <span class="number">30</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;指定时间是: &quot;</span> + time1);  <span class="comment">// 指定时间是: 08:30</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取小时、分钟、秒以及毫秒数</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">hour</span> <span class="operator">=</span> now.getHour();</span><br><span class="line">        <span class="type">int</span> <span class="variable">minute</span> <span class="operator">=</span> now.getMinute();</span><br><span class="line">        <span class="type">int</span> <span class="variable">second</span> <span class="operator">=</span> now.getSecond();</span><br><span class="line">        <span class="type">int</span> <span class="variable">nano</span> <span class="operator">=</span> now.getNano();</span><br><span class="line">        <span class="comment">// 现在是20时07分25秒797纳秒</span></span><br><span class="line">        System.out.printf(<span class="string">&quot;现在是%d时%d分%d秒%d纳秒%n&quot;</span>, hour, minute, second, nano);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 加减小时、分钟、秒以及毫秒数</span></span><br><span class="line">        <span class="type">LocalTime</span> <span class="variable">newTime1</span> <span class="operator">=</span> now.plusHours(<span class="number">2</span>);</span><br><span class="line">        <span class="type">LocalTime</span> <span class="variable">newTime2</span> <span class="operator">=</span> now.minusMinutes(<span class="number">30</span>);</span><br><span class="line">        <span class="comment">// 两个小时后的时间是：22:07:25.797</span></span><br><span class="line">        System.out.println(<span class="string">&quot;两个小时后的时间是：&quot;</span> + newTime1);</span><br><span class="line">        <span class="comment">// 30分钟前的时间是：19:37:25.797</span></span><br><span class="line">        System.out.println(<span class="string">&quot;30分钟前的时间是：&quot;</span> + newTime2);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 使用parse()方法解析字符串为时间</span></span><br><span class="line">        <span class="type">LocalTime</span> <span class="variable">time2</span> <span class="operator">=</span> LocalTime.parse(<span class="string">&quot;20:15:30&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;解析后的时间是：&quot;</span> + time2);  <span class="comment">// 解析后的时间是：20:15:30</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<h3 id="localdatetime"><a class="markdownIt-Anchor" href="#localdatetime"></a> LocalDateTime</h3>
<div class="note note-info icon-padding"><i class="note-icon fa-solid fa-info-circle"></i><p>日期时间操作</p>
</div>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LocalDateTimeDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 使用now()方法创建当前日期时间实例</span></span><br><span class="line">        <span class="type">LocalDateTime</span> <span class="variable">now</span> <span class="operator">=</span> LocalDateTime.now();</span><br><span class="line">        <span class="comment">// 现在是: 2020-05-14T20:40:49.458</span></span><br><span class="line">        System.out.println(<span class="string">&quot;现在是: &quot;</span> + now);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 使用of()方法创建指定日期时间实例</span></span><br><span class="line">        <span class="type">LocalDateTime</span> <span class="variable">dateTime1</span> <span class="operator">=</span> LocalDateTime.of(<span class="number">2020</span>, <span class="number">10</span>, <span class="number">1</span>, <span class="number">8</span>, <span class="number">30</span>);</span><br><span class="line">        <span class="comment">// 指定日期时间是: 2020-10-01T08:30</span></span><br><span class="line">        System.out.println(<span class="string">&quot;指定日期时间是: &quot;</span> + dateTime1);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取年份、月份、日、小时、分钟和秒</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">year</span> <span class="operator">=</span> now.getYear();</span><br><span class="line">        <span class="type">int</span> <span class="variable">month</span> <span class="operator">=</span> now.getMonthValue();</span><br><span class="line">        <span class="type">int</span> <span class="variable">day</span> <span class="operator">=</span> now.getDayOfMonth();</span><br><span class="line">        <span class="type">int</span> <span class="variable">hour</span> <span class="operator">=</span> now.getHour();</span><br><span class="line">        <span class="type">int</span> <span class="variable">minute</span> <span class="operator">=</span> now.getMinute();</span><br><span class="line">        <span class="type">int</span> <span class="variable">second</span> <span class="operator">=</span> now.getSecond();</span><br><span class="line">        <span class="comment">// 现在是2020年5月14日20时40分49秒</span></span><br><span class="line">        System.out.printf(<span class="string">&quot;现在是%d年%d月%d日%d时%d分%d秒%n&quot;</span>, year, month, day, hour, minute, second);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 加减日期和时间</span></span><br><span class="line">        <span class="type">LocalDateTime</span> <span class="variable">newDateTime1</span> <span class="operator">=</span> now.plusDays(<span class="number">1</span>).minusHours(<span class="number">2</span>);</span><br><span class="line">       <span class="comment">// 1天后减2小时的日期时间是：2020-05-15T18:40:49.458</span></span><br><span class="line">        System.out.println(<span class="string">&quot;1天后减2小时的日期时间是：&quot;</span> + newDateTime1);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 使用parse()方法解析字符串为日期时间</span></span><br><span class="line">        <span class="type">LocalDateTime</span> <span class="variable">dateTime2</span> <span class="operator">=</span> LocalDateTime.parse(<span class="string">&quot;2020-05-10T20:15:30&quot;</span>);</span><br><span class="line">        <span class="comment">// 解析后的日期时间是：2020-05-10T20:15:30</span></span><br><span class="line">        System.out.println(<span class="string">&quot;解析后的日期时间是：&quot;</span> + dateTime2);  </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<h3 id="instant"><a class="markdownIt-Anchor" href="#instant"></a> Instant</h3>
<div class="note note-info icon-padding"><i class="note-icon fa-solid fa-info-circle"></i><p>时间戳操作</p>
</div>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">InstantDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 创建一个Instant实例</span></span><br><span class="line">        <span class="type">Instant</span> <span class="variable">now</span> <span class="operator">=</span> Instant.now();</span><br><span class="line">        <span class="comment">// 当前时间戳是：当前时间戳是：2020-05-14T20:32:00Z</span></span><br><span class="line">        System.out.println(<span class="string">&quot;当前时间戳是：&quot;</span> + now);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取时间戳的值</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">epochSecond</span> <span class="operator">=</span> now.getEpochSecond();</span><br><span class="line">        <span class="type">int</span> <span class="variable">nano</span> <span class="operator">=</span> now.getNano();</span><br><span class="line">        <span class="comment">// 时间戳的值为1589488320秒0纳秒</span></span><br><span class="line">        System.out.printf(<span class="string">&quot;时间戳的值为%d秒%d纳秒%n&quot;</span>, epochSecond, nano);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 使用ofEpochSecond()方法创建Instant实例</span></span><br><span class="line">        <span class="type">Instant</span> <span class="variable">instant1</span> <span class="operator">=</span> Instant.ofEpochSecond(<span class="number">1601510400</span>);</span><br><span class="line">        <span class="comment">// 指定时间戳是：2020-10-01T00:00:00Z</span></span><br><span class="line">        System.out.println(<span class="string">&quot;指定时间戳是：&quot;</span> + instant1);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 计算两个时间戳之间的时间差</span></span><br><span class="line">        <span class="type">Instant</span> <span class="variable">instant2</span> <span class="operator">=</span> Instant.ofEpochSecond(<span class="number">1651456800</span>);</span><br><span class="line">        <span class="type">long</span> <span class="variable">seconds</span> <span class="operator">=</span> Duration.between(instant1, instant2).getSeconds();</span><br><span class="line">        <span class="comment">// 两个时间戳之间相差49946400秒</span></span><br><span class="line">        System.out.printf(<span class="string">&quot;两个时间戳之间相差%d秒%n&quot;</span>, seconds);</span><br><span class="line">      </span><br><span class="line">        <span class="comment">//// 转换</span></span><br><span class="line">        / 创建一个 Instant 对象</span><br><span class="line">        <span class="type">Instant</span> <span class="variable">instant</span> <span class="operator">=</span> Instant.now();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将 Instant 转换为 LocalDateTime</span></span><br><span class="line">        <span class="type">LocalDateTime</span> <span class="variable">localDateTime</span> <span class="operator">=</span> LocalDateTime.ofInstant(instant, ZoneId.systemDefault());</span><br><span class="line">        System.out.println(<span class="string">&quot;LocalDateTime: &quot;</span> + localDateTime);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将 Instant 转换为 ZonedDateTime</span></span><br><span class="line">        <span class="type">ZonedDateTime</span> <span class="variable">zonedDateTime</span> <span class="operator">=</span> instant.atZone(ZoneId.systemDefault());</span><br><span class="line">        System.out.println(<span class="string">&quot;ZonedDateTime: &quot;</span> + zonedDateTime);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将 Instant 转换为 LocalDate</span></span><br><span class="line">        <span class="type">LocalDate</span> <span class="variable">localDate</span> <span class="operator">=</span> instant.atZone(ZoneId.systemDefault()).toLocalDate();</span><br><span class="line">        System.out.println(<span class="string">&quot;LocalDate: &quot;</span> + localDate);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将 Instant 转换为 LocalTime</span></span><br><span class="line">        <span class="type">LocalTime</span> <span class="variable">localTime</span> <span class="operator">=</span> instant.atZone(ZoneId.systemDefault()).toLocalTime();</span><br><span class="line">        System.out.println(<span class="string">&quot;LocalTime: &quot;</span> + localTime);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<h3 id="period"><a class="markdownIt-Anchor" href="#period"></a> Period</h3>
<div class="note note-info icon-padding"><i class="note-icon fa-solid fa-info-circle"></i><p>日期段操作</p>
</div>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PeriodDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 创建一个Period实例</span></span><br><span class="line">        <span class="type">Period</span> <span class="variable">period1</span> <span class="operator">=</span> Period.of(<span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;指定日期段是：&quot;</span> + period1);  <span class="comment">// 指定日期段是：P3Y2M1D</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取年份、月份和天数</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">year</span> <span class="operator">=</span> period1.getYears();</span><br><span class="line">        <span class="type">int</span> <span class="variable">month</span> <span class="operator">=</span> period1.getMonths();</span><br><span class="line">        <span class="type">int</span> <span class="variable">day</span> <span class="operator">=</span> period1.getDays();</span><br><span class="line">        System.out.printf(<span class="string">&quot;指定日期段为%d年%d个月%d天%n&quot;</span>, year, month, day);  <span class="comment">// 指定日期段为3年2个月1天</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 使用between()方法计算两个日期之间的日期段</span></span><br><span class="line">        <span class="type">LocalDate</span> <span class="variable">date1</span> <span class="operator">=</span> LocalDate.of(<span class="number">2021</span>, <span class="number">10</span>, <span class="number">1</span>);</span><br><span class="line">        <span class="type">LocalDate</span> <span class="variable">date2</span> <span class="operator">=</span> LocalDate.of(<span class="number">2022</span>, <span class="number">8</span>, <span class="number">25</span>);</span><br><span class="line">        <span class="type">Period</span> <span class="variable">period2</span> <span class="operator">=</span> Period.between(date1, date2);</span><br><span class="line">        System.out.println(<span class="string">&quot;两个日期之间的日期段是：&quot;</span> + period2);  <span class="comment">// 两个日期之间的日期段是：P10M24D</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 计算总天数</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">days</span> <span class="operator">=</span> period2.getDays() + period2.getMonths() * <span class="number">30</span> + period2.getYears() * <span class="number">365</span>;</span><br><span class="line">        System.out.printf(<span class="string">&quot;两个日期之间相差%d天%n&quot;</span>, days);  <span class="comment">// 两个日期之间相差328天</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<h3 id="duration"><a class="markdownIt-Anchor" href="#duration"></a> Duration</h3>
<div class="note note-info icon-padding"><i class="note-icon fa-solid fa-info-circle"></i><p>时间段操作</p>
</div>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DurationDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 创建一个Duration实例</span></span><br><span class="line">        <span class="type">LocalDateTime</span> <span class="variable">dateTime1</span> <span class="operator">=</span> LocalDateTime.of(<span class="number">2019</span>, <span class="number">10</span>, <span class="number">1</span>, <span class="number">8</span>, <span class="number">30</span>);</span><br><span class="line">        <span class="type">LocalDateTime</span> <span class="variable">dateTime2</span> <span class="operator">=</span> LocalDateTime.of(<span class="number">2020</span>, <span class="number">8</span>, <span class="number">25</span>, <span class="number">14</span>, <span class="number">0</span>);</span><br><span class="line">        <span class="type">Duration</span> <span class="variable">duration1</span> <span class="operator">=</span> Duration.between(dateTime1, dateTime2);</span><br><span class="line">        <span class="comment">// 两个日期时间之间的时间段是：PT7901H30M</span></span><br><span class="line">        System.out.println(<span class="string">&quot;两个日期时间之间的时间段是：&quot;</span> + duration1);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取时、分、秒和毫秒数</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">hours</span> <span class="operator">=</span> duration1.toHours();</span><br><span class="line">        <span class="type">long</span> <span class="variable">minutes</span> <span class="operator">=</span> duration1.toMinutes() % <span class="number">60</span>;</span><br><span class="line">        <span class="type">long</span> <span class="variable">seconds</span> <span class="operator">=</span> duration1.getSeconds() % <span class="number">60</span>;</span><br><span class="line">        <span class="type">long</span> <span class="variable">millis</span> <span class="operator">=</span> duration1.toMillis() % <span class="number">1000</span>;</span><br><span class="line">        System.out.printf(<span class="string">&quot;两个日期时间之间相差%d小时%d分钟%d秒%d毫秒%n&quot;</span>, hours, minutes, seconds, millis);  <span class="comment">// 两个日期时间之间相差7901小时30分钟0秒0毫秒</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 使用ofXXX()方法创建Duration实例</span></span><br><span class="line">        <span class="type">Duration</span> <span class="variable">duration2</span> <span class="operator">=</span> Duration.ofDays(<span class="number">3</span>).plusHours(<span class="number">5</span>).plusMinutes(<span class="number">20</span>).plusSeconds(<span class="number">10</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;指定时间段是：&quot;</span> + duration2);  <span class="comment">// 指定时间段是：PT77H20M10S</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<h3 id="datetimeformatter"><a class="markdownIt-Anchor" href="#datetimeformatter"></a> DateTimeFormatter</h3>
<div class="note note-info icon-padding"><i class="note-icon fa-solid fa-info-circle"></i><p>格式化</p>
</div>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DateTimeFormatterDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 创建一个DateTimeFormatter实例，并使用format()方法格式化日期时间</span></span><br><span class="line">        <span class="type">LocalDateTime</span> <span class="variable">now</span> <span class="operator">=</span> LocalDateTime.now();</span><br><span class="line">        <span class="type">DateTimeFormatter</span> <span class="variable">formatter1</span> <span class="operator">=</span> DateTimeFormatter.ofPattern(<span class="string">&quot;yyyy-MM-dd HH:mm:ss&quot;</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">formattedDateTime1</span> <span class="operator">=</span> now.format(formatter1);</span><br><span class="line">        <span class="comment">// 格式化后的日期时间是：2020-05-14 20:40:01</span></span><br><span class="line">        System.out.println(<span class="string">&quot;格式化后的日期时间是：&quot;</span> + formattedDateTime1);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 使用parse()方法解析字符串为日期时间</span></span><br><span class="line">        <span class="type">DateTimeFormatter</span> <span class="variable">formatter2</span> <span class="operator">=</span> DateTimeFormatter.ofPattern(<span class="string">&quot;yyyyMMddHHmmss&quot;</span>);</span><br><span class="line">        <span class="type">LocalDateTime</span> <span class="variable">dateTime2</span> <span class="operator">=</span> LocalDateTime.parse(<span class="string">&quot;20200828092915&quot;</span>, formatter2);</span><br><span class="line">        <span class="comment">// 解析后的日期时间是：2020-08-28T09:29:15</span></span><br><span class="line">        System.out.println(<span class="string">&quot;解析后的日期时间是：&quot;</span> + dateTime2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<h2 id="总结"><a class="markdownIt-Anchor" href="#总结"></a> 总结</h2>
<p>Java 8时间操作类的设计理念是围绕着不可变性、线程安全性和清晰易用性来展开的。它们提供了丰富的API，可以完成各种常见的日期和时间操作，并且具有很好的性能和稳定性。使用Java 8时间操作类可以让我们更加便捷地进行日期和时间的处理，避免了之前旧版API中存在的一些问题。</p>
]]></content>
      <categories>
        <category>Java</category>
        <category>Date Time API</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>日期时间API</tag>
      </tags>
  </entry>
  <entry>
    <title>HashMap - 基本原理</title>
    <url>/posts/fcb831a5/</url>
    <content><![CDATA[<p>HashMap是Java中最常用的数据结构之一，它将键映射到值，允许我们通过Key来快速检索和获取Value。在Java 8中，HashMap进行了一些优化和改进，以提高性能和减少冲突。本文将介绍Java8 HashMap的基本原理和实现方式。</p>
<div class="note note-yellow"><p>本文将介绍Java8 HashMap的基本原理，不会对 HashMap 中的方法进行解读，对于其核心的方法解读会单开炉灶</p>
</div>
<h2 id="基本原理"><a class="markdownIt-Anchor" href="#基本原理"></a> 基本原理</h2>
<p>在Java8中，HashMap使用数组和链表（或红黑树）实现。当一个元素被添加到HashMap中时，它首先根据Key的hashcode计算出一个桶号，并将其放入相应的桶中。如果该桶中已经存在其他元素，则需要比较它们的Key是否相等。如果Key相等，则直接替换Value；否则，将该元素添加到链表（或红黑树）的末尾。</p>
<p>当HashMap的大小超过某个阈值（load factor）时，它会自动扩容。扩容涉及将所有的元素重新散列到一个新的、更大的桶中。这个操作代价很高，因此应该尽可能地避免频繁地扩容HashMap。</p>
<h2 id="实现方式"><a class="markdownIt-Anchor" href="#实现方式"></a> 实现方式</h2>
<p>在Java8中，HashMap的内部实现有以下重要组件：</p>
<ul>
<li>数组：HashMap使用一个Node类型的数组来存储元素。</li>
<li>链表：当多个元素映射到同一个桶时，它们将被链接成一个链表。链表上的节点类型是Node。</li>
<li>红黑树：当一个桶中的元素数量超过8个时，HashMap会将链表转换为红黑树，以提高性能。此时链表上的节点类型是TreeNode。</li>
</ul>
<p>下面我们来看一下Java8 HashMap的核心代码：</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HashMap</span>&lt;K,V&gt; <span class="keyword">extends</span> <span class="title class_">AbstractMap</span>&lt;K,V&gt;</span><br><span class="line">    <span class="keyword">implements</span> <span class="title class_">Map</span>&lt;K,V&gt;, Cloneable, Serializable &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始大小 16</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">DEFAULT_INITIAL_CAPACITY</span> <span class="operator">=</span> <span class="number">1</span> &lt;&lt; <span class="number">4</span>; <span class="comment">// aka 16</span></span><br><span class="line">    <span class="comment">// 扩容的加载因子 0.75</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">float</span> <span class="variable">DEFAULT_LOAD_FACTOR</span> <span class="operator">=</span> <span class="number">0.75f</span>;</span><br><span class="line">    <span class="comment">// 转化为红黑树的阈值 8</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">TREEIFY_THRESHOLD</span> <span class="operator">=</span> <span class="number">8</span>;</span><br><span class="line">    <span class="comment">// 退化为链表的阈值 6</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">UNTREEIFY_THRESHOLD</span> <span class="operator">=</span> <span class="number">6</span>;</span><br><span class="line">    <span class="comment">// 转化为红黑树的另一个条件，Hash表的大小阈值 64</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">MIN_TREEIFY_CAPACITY</span> <span class="operator">=</span> <span class="number">64</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">transient</span> Node&lt;K,V&gt;[] table;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">transient</span> Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">transient</span> <span class="type">int</span> size;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> threshold;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> <span class="type">float</span> loadFactor;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">HashMap</span><span class="params">(<span class="type">int</span> initialCapacity, <span class="type">float</span> loadFactor)</span> &#123;</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> V <span class="title function_">put</span><span class="params">(K key, V value)</span> &#123;</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>在上面的代码中，我们可以看到几个重要的组件，包括数组 <code>table</code>、阈值 <code>threshold</code>、负载因子 <code>loadFactor</code>、链表和红黑树转换的阈值等。此外，还有一些常见的方法，例如put()、get()和resize()等方法。</p>
<h2 id="总结"><a class="markdownIt-Anchor" href="#总结"></a> 总结</h2>
<p>Java8的HashMap是一种高效的数据结构，它使用数组和链表（或红黑树）实现，并具有自动扩容和哈希冲突解决等功能。HashMap的内部实现涉及到许多细节和优化，需要理解其基本原理和实现方式才能更好地使用它。掌握Java8 HashMap的基本原理和使用方法，可以使我们更加高效和便捷地处理键值对数据。</p>
]]></content>
      <categories>
        <category>Java</category>
        <category>HashMap</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>HashMap</tag>
      </tags>
  </entry>
  <entry>
    <title>HashMap - resize()</title>
    <url>/posts/80dd519a/</url>
    <content><![CDATA[<p>在 Java 中，HashMap 是一个非常重要的集合类，它采用哈希表来存储键值对。当数据量变大时，需要调整哈希表的大小，以保证更好的性能和空间使用。resize() 方法就是 HashMap 进行扩容或缩减容量的方法。</p>
<h2 id="什么情况下需要-resize-方法"><a class="markdownIt-Anchor" href="#什么情况下需要-resize-方法"></a> 什么情况下需要 resize() 方法</h2>
<p>当 HashMap 存储的数据超过了负载因子乘以当前容量时（即元素个数 &gt; 负载因子 * 容量），就需要进行 resize 操作。负载因子通常为 0.75，在之前的 JDK 版本中是默认值为 0.75，JDK 1.8 开始可以自定义负载因子。</p>
<p>resize 操作的目的是为了让 HashMap 在扩容或缩减容量后仍然能保持较低的查找和插入成本。如果 HashMap 中的键值对数量过多，则会导致哈希冲突概率增加，从而影响 HashMap 的性能。如果数量太少，则会造成空间浪费。</p>
<h2 id="实现原理"><a class="markdownIt-Anchor" href="#实现原理"></a> 实现原理</h2>
<p>HashMap 的 resize() 方法的实现原理涉及到两个主要步骤：</p>
<ol>
<li>创建新的数组并重新分配元素：首先根据新的容量创建一个新的数组，然后遍历原来的数组，并将所有元素重新分配到新数组中。</li>
<li>调整哈希值：重新分配元素时，需要调整每个键值对的哈希值。这是因为在 Java 中，哈希值是由对象的 hashCode() 方法计算出来的。而当数组大小改变时，hashCode() 值需要重新计算。</li>
</ol>
<p>具体实现过程可以通过以下源码逐行解释：</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">final</span> Node&lt;K,V&gt;[] resize() &#123;</span><br><span class="line">    Node&lt;K,V&gt;[] oldTab = table; <span class="comment">// 保存原数组</span></span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> <span class="variable">oldCap</span> <span class="operator">=</span> (oldTab == <span class="literal">null</span>) ? <span class="number">0</span> : oldTab.length; <span class="comment">// 计算原数组长度</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">oldThr</span> <span class="operator">=</span> threshold; <span class="comment">// 计算原阈值</span></span><br><span class="line">    <span class="type">int</span> newCap, newThr = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (oldCap &gt; <span class="number">0</span>) &#123; <span class="comment">// 如果原数组不为空，则进行扩容操作</span></span><br><span class="line">        <span class="keyword">if</span> (oldCap &gt;= MAXIMUM_CAPACITY) &#123; <span class="comment">// 判断原数组是否达到最大容量</span></span><br><span class="line">            threshold = Integer.MAX_VALUE;</span><br><span class="line">            <span class="keyword">return</span> oldTab;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((newCap = oldCap &lt;&lt; <span class="number">1</span>) &lt; MAXIMUM_CAPACITY &amp;&amp; oldCap &gt;= DEFAULT_INITIAL_CAPACITY)</span><br><span class="line">            newThr = oldThr &lt;&lt; <span class="number">1</span>; <span class="comment">// 扩容后新的阈值</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (oldThr &gt; <span class="number">0</span>) <span class="comment">// 如果原阈值大于0，则使用该值作为初始容量</span></span><br><span class="line">        newCap = oldThr;</span><br><span class="line">    <span class="keyword">else</span> &#123; <span class="comment">// 如果没有指定初始容量或阈值，默认使用默认值</span></span><br><span class="line">        newCap = DEFAULT_INITIAL_CAPACITY;</span><br><span class="line">        newThr = (<span class="type">int</span>)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (newThr == <span class="number">0</span>) &#123; <span class="comment">// 如果 newThr 没有被初始化，则根据新的容量和负载因子计算新的阈值</span></span><br><span class="line">        <span class="type">float</span> <span class="variable">ft</span> <span class="operator">=</span> (<span class="type">float</span>)newCap * loadFactor;</span><br><span class="line">        newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (<span class="type">float</span>)MAXIMUM_CAPACITY ?</span><br><span class="line">                  (<span class="type">int</span>)ft : Integer.MAX_VALUE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    threshold = newThr; <span class="comment">// 更新 HashMap 的阈值</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@SuppressWarnings(&#123;&quot;rawtypes&quot;,&quot;unchecked&quot;&#125;)</span></span><br><span class="line">        Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])<span class="keyword">new</span> <span class="title class_">Node</span>[newCap]; <span class="comment">// 创建新数组</span></span><br><span class="line">    table = newTab; <span class="comment">// 将 table 指向新数组</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (oldTab != <span class="literal">null</span>) &#123; <span class="comment">// 如果原数组不为空，则遍历原数组并将所有元素重新分配到新数组中</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; oldCap; ++j) &#123;</span><br><span class="line">            Node&lt;K,V&gt; e;</span><br><span class="line">            <span class="keyword">if</span> ((e = oldTab[j]) != <span class="literal">null</span>) &#123;</span><br><span class="line">                oldTab[j] = <span class="literal">null</span>; <span class="comment">// 释放原有元素的引用</span></span><br><span class="line">                <span class="keyword">if</span> (e.next == <span class="literal">null</span>) <span class="comment">// 处理链表节点</span></span><br><span class="line">                    newTab[e.hash &amp; (newCap - <span class="number">1</span>)] = e;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (e <span class="keyword">instanceof</span> TreeNode) <span class="comment">// 处理红黑树节点</span></span><br><span class="line">                    ((TreeNode&lt;K,V&gt;)e).split(<span class="built_in">this</span>, newTab, j, oldCap);</span><br><span class="line">                <span class="keyword">else</span> &#123; <span class="comment">// 处理链表节点</span></span><br><span class="line">                    Node&lt;K,V&gt; loHead = <span class="literal">null</span>, loTail = <span class="literal">null</span>;</span><br><span class="line">                    Node&lt;K,V&gt; hiHead = <span class="literal">null</span>, hiTail = <span class="literal">null</span>;</span><br><span class="line">                    Node&lt;K,V&gt; next;</span><br><span class="line">                    <span class="keyword">do</span> &#123;</span><br><span class="line">                        next = e.next;</span><br><span class="line">                        <span class="keyword">if</span> ((e.hash &amp; oldCap) == <span class="number">0</span>) &#123; <span class="comment">// 判断元素是否需要放置到新数组的低位</span></span><br><span class="line">                            <span class="keyword">if</span> (loTail == <span class="literal">null</span>)</span><br><span class="line">                                loHead = e;</span><br><span class="line">                            <span class="keyword">else</span></span><br><span class="line">                                loTail.next = e;</span><br><span class="line">                            loTail = e;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">else</span> &#123; <span class="comment">// 放置到新数组的高位</span></span><br><span class="line">                            <span class="keyword">if</span> (hiTail == <span class="literal">null</span>)</span><br><span class="line">                                hiHead = e;</span><br><span class="line">                            <span class="keyword">else</span></span><br><span class="line">                                hiTail.next = e;</span><br><span class="line">                            hiTail = e;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125; <span class="keyword">while</span> ((e = next) != <span class="literal">null</span>);</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">if</span> (loTail != <span class="literal">null</span>) &#123; <span class="comment">// 将低位链表放到对应位置</span></span><br><span class="line">                        loTail.next = <span class="literal">null</span>;</span><br><span class="line">                        newTab[j] = loHead;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (hiTail != <span class="literal">null</span>) &#123; <span class="comment">// 将高位链表放到对应位置</span></span><br><span class="line">                        hiTail.next = <span class="literal">null</span>;</span><br><span class="line">                        newTab[j + oldCap] = hiHead;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> newTab; <span class="comment">// 返回新数组</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<h2 id="resize-方法的时间复杂度"><a class="markdownIt-Anchor" href="#resize-方法的时间复杂度"></a> resize() 方法的时间复杂度</h2>
<p>resize 操作需要遍历整个数组，并将元素重新分配到新数组中。因此，时间复杂度为 O(n)，其中 n 是 HashMap 中键值对的数量。</p>
<h2 id="总结"><a class="markdownIt-Anchor" href="#总结"></a> 总结</h2>
<p>HashMap 的 resize() 方法是用来扩容或者缩减 HashMap 容量的方法。它通过重新分配元素和调整哈希值来实现。当 HashMap 中的键值对数量超过负载因子乘以当前容量时，就需要进行 resize 操作。为了保证 HashMap 的性能和空间利用率，我们可以通过调整负载因子和初始容量来优化 HashMap 的 resize 操作。</p>
]]></content>
      <categories>
        <category>Java</category>
        <category>HashMap</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>HashMap</tag>
      </tags>
  </entry>
  <entry>
    <title>HashMap - get()</title>
    <url>/posts/e59e566/</url>
    <content><![CDATA[<p>在Java编程中，HashMap是一个重要的数据结构，它可以方便地存储和访问键值对。其中，get()方法是HashMap实现中的关键部分之一。在本篇博文中，我们将对Java8中的HashMap get()方法进行详细解析，并探讨其实现原理。</p>
<h2 id="实现原理"><a class="markdownIt-Anchor" href="#实现原理"></a> 实现原理</h2>
<p>在Java8中，HashMap的核心代码位于java.util.HashMap类中，其中get()方法被定义为：</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> V <span class="title function_">get</span><span class="params">(Object key)</span> &#123;</span><br><span class="line">    Node&lt;K,V&gt; e;</span><br><span class="line">    <span class="comment">// 计算键的哈希码，查找并返回与指定键关联的值。</span></span><br><span class="line">    <span class="keyword">return</span> (e = getNode(hash(key), key)) == <span class="literal">null</span> ? <span class="literal">null</span> : e.value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>从上面的代码可以看出，get()方法主要完成两个操作：</p>
<ol>
<li>计算键的哈希码（通过调用hash(key)方法）。</li>
<li>查找并返回与指定键关联的值。</li>
</ol>
<p>接下来，我们将逐个分析这些操作。</p>
<h3 id="哈希码的计算"><a class="markdownIt-Anchor" href="#哈希码的计算"></a> 哈希码的计算</h3>
<p>在Java中，Object类包含hashCode()方法，该方法返回对象的哈希码。因此，在HashMap中，我们可以轻松地使用key.hashCode()方法计算键的哈希码。<a href="https://blog.heer.love/posts/c0f9b6a9/">hash()</a>方法点击跳转到隔壁。</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 计算hash</span></span><br><span class="line"><span class="keyword">final</span> <span class="type">int</span> <span class="title function_">hash</span><span class="params">(Object key)</span> &#123;</span><br><span class="line">    <span class="type">int</span> h;</span><br><span class="line">    <span class="keyword">return</span> (key == <span class="literal">null</span>) ? <span class="number">0</span> : (h = key.hashCode()) ^ (h &gt;&gt;&gt; <span class="number">16</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<h3 id="查找并返回值"><a class="markdownIt-Anchor" href="#查找并返回值"></a> 查找并返回值</h3>
<p>在HashMap中，键值对存储在Node&lt;K,V&gt;类型的节点中。因此，查找指定键的值需要执行以下操作：</p>
<ol>
<li>根据键的哈希值找到对应的桶。</li>
<li>遍历桶中的链表，查找具有相同键的节点。</li>
<li>如果找到这样的节点，则返回其值。否则，返回null。</li>
</ol>
<p>具体而言，getNode()方法完成了上述操作：</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">final</span> Node&lt;K,V&gt; <span class="title function_">getNode</span><span class="params">(<span class="type">int</span> hash, Object key)</span> &#123;</span><br><span class="line">    <span class="comment">// 声明一个Node数组tab</span></span><br><span class="line">    Node&lt;K,V&gt;[] tab;</span><br><span class="line">    <span class="comment">// 声明两个Node节点first和e</span></span><br><span class="line">    Node&lt;K,V&gt; first, e; </span><br><span class="line">    <span class="comment">// 声明一个int类型变量n，代表桶的数量</span></span><br><span class="line">    <span class="type">int</span> n; </span><br><span class="line">    <span class="comment">// 声明一个泛型K类型变量k，代表key</span></span><br><span class="line">    K k; </span><br><span class="line"></span><br><span class="line">    <span class="comment">// 判断table不为空，n大于0，并且hash对应的桶不为空</span></span><br><span class="line">    <span class="keyword">if</span> ((tab = table) != <span class="literal">null</span> &amp;&amp; (n = tab.length) &gt; <span class="number">0</span> &amp;&amp;</span><br><span class="line">        (first = tab[(n - <span class="number">1</span>) &amp; hash]) != <span class="literal">null</span>) &#123; </span><br><span class="line">        <span class="keyword">if</span> (first.hash == hash &amp;&amp; <span class="comment">// 判断第一个节点的hash值是否等于指定hash值</span></span><br><span class="line">            ((k = first.key) == key || (key != <span class="literal">null</span> &amp;&amp; key.equals(k)))) <span class="comment">// 判断第一个节点的key是否等于指定key</span></span><br><span class="line">            <span class="comment">// 如果第一个节点就是要查找的节点，则直接返回该节点</span></span><br><span class="line">            <span class="keyword">return</span> first;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> ((e = first.next) != <span class="literal">null</span>) &#123; <span class="comment">// 如果第一个节点的下一个节点不为空</span></span><br><span class="line">            <span class="keyword">if</span> (first <span class="keyword">instanceof</span> TreeNode) <span class="comment">// 判断该链表是否已经树化</span></span><br><span class="line">                <span class="comment">// 如果已经树化，则调用getTreeNode方法继续查找</span></span><br><span class="line">                <span class="keyword">return</span> ((TreeNode&lt;K,V&gt;)first).getTreeNode(hash, key); </span><br><span class="line">            <span class="keyword">do</span> &#123; <span class="comment">// 否则遍历链表</span></span><br><span class="line">                <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                    ((k = e.key) == key || (key != <span class="literal">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                    <span class="comment">// 如果找到了指定的节点，则直接返回</span></span><br><span class="line">                    <span class="keyword">return</span> e; </span><br><span class="line">            &#125; <span class="keyword">while</span> ((e = e.next) != <span class="literal">null</span>); <span class="comment">// 遍历链表</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果没有找到对应的节点，则返回null</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></div>
<p>从上面的代码可以看出，getNode()方法首先通过哈希值找到对应的桶，然后遍历桶中的链表，查找与指定键关联的节点。如果找到了这样的节点，则返回其值；否则返回null。</p>
<h2 id="性能分析"><a class="markdownIt-Anchor" href="#性能分析"></a> 性能分析</h2>
<p>在HashMap中，get()方法是最常用的操作之一，它可以高效地访问键值对并提供快速的响应时间。具体而言，get()方法的时间复杂度为O(1)，即与HashMap中存储的元素数量无关。然而，在实际编程中，get()方法的性能可能会受到以下因素的影响：</p>
<h3 id="哈希冲突"><a class="markdownIt-Anchor" href="#哈希冲突"></a> 哈希冲突</h3>
<p>由于哈希表的大小是有限的，所以在不同的键上生成的哈希码可能会相同。这种情况称为哈希冲突（Hash Collision）。当发生哈希冲突时，HashMap将使用链表或红黑树等数据结构来存储具有相同哈希码的节点。因此，如果HashMap中存在大量哈希冲突，那么查找键值对的效率将会降低。</p>
<h3 id="初始容量和加载因子"><a class="markdownIt-Anchor" href="#初始容量和加载因子"></a> 初始容量和加载因子</h3>
<p>HashMap的初始容量和加载因子也会影响get()方法的性能。在创建HashMap对象时，我们需要指定其初始容量和加载因子。如果初始容量较小或加载因子较大，那么HashMap就需要频繁调整自身的大小，从而使get()方法的性能下降。</p>
<h2 id="总结"><a class="markdownIt-Anchor" href="#总结"></a> 总结</h2>
<p>get()方法是HashMap中最常用的方法之一。它通过计算键的哈希值和查找与指定键关联的节点来实现访问键值对。具体而言，get()方法首先调用hash(key)方法计算键的哈希码，然后使用getNode()方法在桶中查找相应的节点。如果找到了这样的节点，则返回其值；否则返回null。</p>
<p>在实际编程中，我们需要注意哈希冲突、初始容量和加载因子等因素，以提高get()方法的性能。同时，我们也可以考虑使用其他数据结构，例如TreeMap，来代替HashMap，从而满足不同的需求。</p>
]]></content>
      <categories>
        <category>Java</category>
        <category>HashMap</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>HashMap</tag>
      </tags>
  </entry>
  <entry>
    <title>HashMap - hash()</title>
    <url>/posts/c0f9b6a9/</url>
    <content><![CDATA[<p>在Java编程中，HashMap是一个重要的数据结构，它可以方便地存储和访问键值对。其中，hash()方法是HashMap实现中的关键部分之一。在本篇博文中，我们将对Java8中的HashMap hash()方法进行解析。</p>
<h2 id="hash方法概述"><a class="markdownIt-Anchor" href="#hash方法概述"></a> Hash()方法概述</h2>
<p>在Java8中，HashMap的核心代码位于java.util.HashMap类中，其中hash()方法被定义为：</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="type">int</span> <span class="title function_">hash</span><span class="params">(Object key)</span> &#123;</span><br><span class="line">    <span class="type">int</span> h;</span><br><span class="line">    <span class="keyword">return</span> (key == <span class="literal">null</span>) ? <span class="number">0</span> : (h = key.hashCode()) ^ (h &gt;&gt;&gt; <span class="number">16</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>从上面的代码可以看出，hash()方法主要完成两个操作：</p>
<ol>
<li>计算键的哈希码（通过调用key.hashCode()方法）。</li>
<li>对哈希码进行微调，以保证分布均匀。</li>
</ol>
<p>接下来，我们将逐个分析这些操作。</p>
<h3 id="计算键的哈希码"><a class="markdownIt-Anchor" href="#计算键的哈希码"></a> 计算键的哈希码</h3>
<p>在Java中，Object类包含hashCode()方法，该方法返回对象的哈希码。因此，在HashMap中，我们可以轻松地使用key.hashCode()方法计算键的哈希码。</p>
<p>然而，如果键是null，则需要特殊处理。在这种情况下，HashMap会将哈希码设置为0。</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line">(key == <span class="literal">null</span>) ? <span class="number">0</span> : (h = key.hashCode())</span><br></pre></td></tr></table></figure></div>
<h3 id="微调哈希码"><a class="markdownIt-Anchor" href="#微调哈希码"></a> 微调哈希码</h3>
<p>第二个操作是对哈希码进行微调。 虽然key.hashCode()方法产生的哈希值很好，但它可能不适合HashMap中的所有情况。例如，在哈希表中使用的桶数为2的幂时，最低位可能会被过于频繁地使用，这可能会导致性能问题。</p>
<p>因此，HashMap使用了以下技巧对哈希码进行微调：</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line">(h = key.hashCode()) ^ (h &gt;&gt;&gt; <span class="number">16</span>);</span><br></pre></td></tr></table></figure></div>
<p>其中，&quot;^&quot;运算符表示按位异或操作。这个操作将哈希码的高16位与低16位混合在一起。这有助于减少哈希码中的碰撞，并增加桶的数量。</p>
<div class="note-large notel-green"><div class="notel-title"><p>”^“相较于”&amp;“、”|“计算Hash值的优点</p>
</div><div class="notel-content"><ol>
<li>高效性：异或操作比位与或位或操作更快，因为它不需要检查每个位的值。</li>
<li>混淆性：通过将哈希码的高位和低位进行异或，可以使得哈希码的各个部分都对最终的哈希值产生影响。这有助于减少哈希冲突，提高HashMap的性能。</li>
<li>均匀性：异或操作可以保持哈希码的均匀性，这是在HashMap中实现高效散列的关键。</li>
</ol>
 </div></div>
<h2 id="总结"><a class="markdownIt-Anchor" href="#总结"></a> 总结</h2>
<p>HashMap是Java编程中重要的数据结构之一。其核心代码包括hash()方法，它通过计算键的哈希码并对其进行微调来保证分布均匀。具体而言，hash()方法首先调用key.hashCode()方法计算哈希码，然后使用异或运算符对其进行微调。使用这些技术，HashMap可以高效地存储和快速访问键值对。</p>
]]></content>
      <categories>
        <category>Java</category>
        <category>HashMap</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>HashMap</tag>
      </tags>
  </entry>
  <entry>
    <title>ThreadLocal 基础使用</title>
    <url>/posts/151f44ae/</url>
    <content><![CDATA[<p>在Java多线程编程中，<code>ThreadLocal</code>类是一个非常有用的工具，它能够帮助我们轻松地实现线程本地存储。在本文中，我们将深入探讨<code>ThreadLocal</code>的实现原理和如何正确使用它。</p>
<h2 id="threadlocal"><a class="markdownIt-Anchor" href="#threadlocal"></a> ThreadLocal</h2>
<p>首先，我们来了解一下什么是ThreadLocal。简单来说，<code>ThreadLocal</code>是一种线程本地存储机制，它为每个线程提供了一个独立的变量副本，使得每个线程都可以独立地改变自己的副本，而不会影响其他线程的副本。</p>
<h2 id="实现原理"><a class="markdownIt-Anchor" href="#实现原理"></a> 实现原理</h2>
<p>下面我们来看一下<code>ThreadLocal</code>的实现原理。<code>ThreadLocal</code>本质上是一个 Map，其中 Key 是当前线程的引用，Value 是要存储的对象。由于每个线程的引用都是唯一的，因此每个线程都可以通过自己的引用获取到对应的值，而不会与其他线程发生干扰。</p>
<p>具体实现方式是，在每个线程内部都有一个 ThreadLocalMap 对象，这个 Map 对象的 Key 就是 ThreadLocal 对象本身，而 Value 则是要存储的对象。当调用<code>ThreadLocal</code>的<code>get()</code>方法时，线程会先获取自己的 ThreadLocalMap 对象，然后以<code>ThreadLocal</code>对象为Key从Map中获取对应的值。</p>
<h2 id="正确使用方式"><a class="markdownIt-Anchor" href="#正确使用方式"></a> 正确使用方式</h2>
<p>虽然<code>ThreadLocal</code>是一个有用的工具，但也需要注意一些问题。下面是一些在使用<code>ThreadLocal</code>时需要遵循的最佳实践：</p>
<h3 id="避免内存泄漏"><a class="markdownIt-Anchor" href="#避免内存泄漏"></a> 避免内存泄漏</h3>
<p>由于Java中的线程是不会自动销毁的，如果我们在使用<code>ThreadLocal</code>时不注意清理，就可能导致内存泄漏。因此，在每个线程结束时都需要手动调用<code>ThreadLocal</code>的<code>remove()</code>方法，以便释放其占用的内存资源。</p>
<h3 id="谨慎使用inheritablethreadlocal"><a class="markdownIt-Anchor" href="#谨慎使用inheritablethreadlocal"></a> 谨慎使用InheritableThreadLocal</h3>
<p><code>InheritableThreadLocal</code>是<code>ThreadLocal</code>的一个子类，它允许子线程继承父线程的本地变量。但是，在使用<code>InheritableThreadLocal</code>时需要特别小心，因为它可能会导致父线程和子线程之间产生相互依赖的问题。因此，在使用<code>InheritableThreadLocal</code>时需要非常小心，并且需要充分了解它的实现原理和使用方式。</p>
<h3 id="不要滥用threadlocal"><a class="markdownIt-Anchor" href="#不要滥用threadlocal"></a> 不要滥用ThreadLocal</h3>
<p>尽管<code>ThreadLocal</code>是一个很方便的工具，但并不意味着可以滥用它。在多线程编程中，应该尽量避免使用全局变量和静态变量，而是尽可能地使用局部变量和方法参数。只有在确实有必要使用<code>ThreadLocal</code>时才应该这样做。</p>
<h2 id="总结"><a class="markdownIt-Anchor" href="#总结"></a> 总结</h2>
<p><code>ThreadLocal</code>是Java多线程编程中一个非常有用的工具，它可以轻松地实现线程本地存储。在正确使用<code>ThreadLocal</code>时，需要遵循一些最佳实践，以避免在项目中埋下坑。</p>
]]></content>
      <categories>
        <category>Java</category>
        <category>ThreadLocal</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>ThreadLocal</tag>
      </tags>
  </entry>
  <entry>
    <title>HashMap - put()</title>
    <url>/posts/80dd519a/</url>
    <content><![CDATA[<p>在 Java 8 中，HashMap 是一种常见的数据结构，用于存储键值对。put() 方法是其中最常用且最重要的方法之一。本文将详细介绍 Java 8 HashMap 的 put() 方法。</p>
<h2 id="hashmap-概述"><a class="markdownIt-Anchor" href="#hashmap-概述"></a> HashMap 概述</h2>
<p>HashMap 是一种基于哈希表实现的 Map 接口，使用键值对（key-value）的方式进行存储。HashMap 的 key 和 value 都可以为 null，但是同一个 key 只能映射到一个 value 上。HashMap 是非线程安全的，不支持并发访问，需要进行同步处理。</p>
<h2 id="put-方法"><a class="markdownIt-Anchor" href="#put-方法"></a> put() 方法</h2>
<p>put() 方法用于将指定的键值对添加到 HashMap 中。语法如下：</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line">V <span class="title function_">put</span><span class="params">(K key, V value)</span></span><br></pre></td></tr></table></figure></div>
<p>其中，K 表示 key 的类型，V 表示 value 的类型。</p>
<h3 id="实现原理"><a class="markdownIt-Anchor" href="#实现原理"></a> 实现原理</h3>
<p>Java 8 中的 HashMap 底层实现采用数组 + 链表/红黑树的方式实现。当向 HashMap 中添加元素时，会首先根据 key 的 hash 值确定该元素在数组中的位置，并将其添加到对应位置上。如果该位置已经有元素了，则会以链表或红黑树的形式将其连接起来。</p>
<p>在 HashMap 中，每个位置上存储的是一个 Node 对象，包含 key、value 和指向下一个 Node 对象的指针。如果某个位置上的元素过多，就会将其转化成红黑树，以提高查询效率。</p>
<h3 id="put-方法的实现"><a class="markdownIt-Anchor" href="#put-方法的实现"></a> put() 方法的实现</h3>
<p>下面是 HashMap 中 put() 方法的源代码：</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">final</span> V <span class="title function_">putVal</span><span class="params">(<span class="type">int</span> hash, K key, V value, <span class="type">boolean</span> onlyIfAbsent, <span class="type">boolean</span> evict)</span> &#123;</span><br><span class="line">    Node&lt;K,V&gt;[] tab;          <span class="comment">// 定义 Node 数组</span></span><br><span class="line">    Node&lt;K,V&gt; p;              <span class="comment">// 定义 Node 变量</span></span><br><span class="line">    <span class="type">int</span> n, i;                 <span class="comment">// 定义 table 长度变量及索引变量</span></span><br><span class="line">    <span class="comment">// 如果 table 数组为空，则调用 resize() 方法进行数组初始化</span></span><br><span class="line">    <span class="keyword">if</span> ((tab = table) == <span class="literal">null</span> || (n = tab.length) == <span class="number">0</span>)</span><br><span class="line">        n = (tab = resize()).length;</span><br><span class="line">    <span class="comment">// 计算当前键值对的哈希值在 table 数组中的索引位置</span></span><br><span class="line">    <span class="keyword">if</span> ((p = tab[i = (n - <span class="number">1</span>) &amp; hash]) == <span class="literal">null</span>)</span><br><span class="line">        <span class="comment">// 如果计算得到的索引位置为 null，则新建节点并插入该位置</span></span><br><span class="line">        tab[i] = newNode(hash, key, value, <span class="literal">null</span>);</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        Node&lt;K,V&gt; e; K k;</span><br><span class="line">        <span class="comment">// 如果当前索引位置存在元素，则判断元素类型是否为树节点类型</span></span><br><span class="line">        <span class="keyword">if</span> (p.hash == hash &amp;&amp;</span><br><span class="line">            ((k = p.key) == key || (key != <span class="literal">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">            e = p;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (p <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">            <span class="comment">// 如果当前节点类型为树节点，则在树节点上执行插入操作</span></span><br><span class="line">            e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(<span class="built_in">this</span>, tab, hash, key, value);</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 否则按链表方式进行插入操作</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">binCount</span> <span class="operator">=</span> <span class="number">0</span>; ; ++binCount) &#123;</span><br><span class="line">                <span class="keyword">if</span> ((e = p.next) == <span class="literal">null</span>) &#123;</span><br><span class="line">                    <span class="comment">// 如果当前节点的下一个节点为 null，则新建节点并插入到链表尾部</span></span><br><span class="line">                    p.next = newNode(hash, key, value, <span class="literal">null</span>);</span><br><span class="line">                    <span class="comment">// 如果链表长度大于等于树化阈值，则执行树化操作</span></span><br><span class="line">                    <span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD - <span class="number">1</span>)</span><br><span class="line">                        treeifyBin(tab, hash);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 否则继续遍历链表查找是否存在相同键的节点</span></span><br><span class="line">                <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                    ((k = e.key) == key || (key != <span class="literal">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                p = e;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果找到了相同键的节点，则更新该节点的值</span></span><br><span class="line">        <span class="keyword">if</span> (e != <span class="literal">null</span>) &#123; </span><br><span class="line">            <span class="type">V</span> <span class="variable">oldValue</span> <span class="operator">=</span> e.value;</span><br><span class="line">            <span class="keyword">if</span> (!onlyIfAbsent || oldValue == <span class="literal">null</span>)</span><br><span class="line">                e.value = value;</span><br><span class="line">            afterNodeAccess(e);</span><br><span class="line">            <span class="keyword">return</span> oldValue;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 更新 modCount 并检查是否需要扩容</span></span><br><span class="line">    ++modCount;</span><br><span class="line">    <span class="keyword">if</span> (++size &gt; threshold)</span><br><span class="line">        resize();</span><br><span class="line">    afterNodeInsertion(evict);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>该方法的实现非常复杂，但是可以大致分为三个步骤：</p>
<ol>
<li>首先根据 key 的 hash 值确定该元素在数组中的位置。</li>
<li>如果该位置为空，则直接将其添加到对应位置上；如果该位置已经有元素了，则需要进行链表或红黑树的操作。</li>
<li>最后更新 HashMap 的 size 和 modCount 属性，并调用 afterNodeInsertion() 方法完成插入操作。</li>
</ol>
<h2 id="总结"><a class="markdownIt-Anchor" href="#总结"></a> 总结</h2>
<p>总体来说，Java 8 中 HashMap 的 <code>put()</code> 方法依然采用了 拉链法 解决哈希冲突的问题，但是通过提高阈值和优化树化过程，它有着更好的性能表现。</p>
]]></content>
      <categories>
        <category>Java</category>
        <category>HashMap</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>HashMap</tag>
      </tags>
  </entry>
  <entry>
    <title>高并发-缓存</title>
    <url>/posts/692db510/</url>
    <content><![CDATA[<blockquote>
<p><strong>高并发实现的三板斧：缓存，限流和降级</strong>。缓存在高并发系统中有者极其广阔的应用，需要重点掌握，本文重点介绍下缓存及其实现。</p>
</blockquote>
<h2 id="缓存简介"><a class="markdownIt-Anchor" href="#缓存简介"></a> 缓存简介</h2>
<p>随着互联网的普及，内容信息越来越复杂，用户数和访问量越来越大，我们的应用需要支撑更多的并发量，同时我们的应用服务器和数据库服务器所做的计算也越来越多。但是往往我们的应用服务器资源是有限的，且技术变革是缓慢的，数据库每秒能接受的请求次数也是有限的（或者文件的读写也是有限的），如何能够有效利用有限的资源来提供尽可能大的吞吐量? 一个有效的办法就是引入缓存，打破标准流程，每个环节中请求可以从缓存中直接获取目标数据并返回，从而减少计算量，有效提升响应速度，让有限的资源服务更多的用户。</p>
<p>如图1所示，缓存的使用可以出现在1～4的各个环节中，每个环节的缓存方案与使用各有特点。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://pdai.tech/images/arch/arch-x-cache-1.png"
                      alt="img" 
                ></p>
<p>图1 互联网应用一般流程</p>
<h3 id="关键词-命中率"><a class="markdownIt-Anchor" href="#关键词-命中率"></a> 关键词-命中率</h3>
<ul>
<li><strong>命中率 = 命中数 / (命中数 + 没有命中数)</strong></li>
</ul>
<p>影响缓存命中率的因素：</p>
<p>1.业务场景和业务需求</p>
<p>缓存通常适合读多写少的业务场景，反之的使用意义并不多，命中率会很低。业务需求也决定了实时性的要求，直接影响到过期时间和更新策略，实时性要求越低越适合缓存。</p>
<p>2.缓存的设计（策略和粒度）</p>
<p>通常情况下缓存的粒度越小，命中率越高。比如说缓存一个用户信息的对象，只有当这个用户的信息发生变化的时候才更新缓存，而如果是缓存一个集合的话，集合中任何一个对象发生变化都要重新更新缓存。</p>
<p>当数据发生变化时，直接更新缓存的值比移除缓存或者让缓存过期它的命中率更高，不过这个时候系统的复杂度过高。</p>
<p>3.缓存的容量和基础设施</p>
<p>缓存的容量有限就会容易引起缓存的失效和被淘汰。目前多数的缓存框架和中间件都采用LRU这个算法。同时采用缓存的技术选型也是至关重要的，比如采用本地内置的应用缓存，就比较容易出现单机瓶颈。而采用分布式缓存就更加容易扩展。所以需要做好系统容量规划，系统是否可扩展。</p>
<ul>
<li><strong>最大空间</strong></li>
</ul>
<p>缓存最大空间一旦缓存中元素数量超过这个值（或者缓存数据所占空间超过其最大支持空间），那么将会触发缓存启动清空策略根据不同的场景合理的设置最大元素值往往可以一定程度上提高缓存的命中率，从而更有效的利用缓存。</p>
<h3 id="缓存介质"><a class="markdownIt-Anchor" href="#缓存介质"></a> 缓存介质</h3>
<p>虽然从硬件介质上来看，无非就是内存和硬盘两种，但从技术上，可以分成内存、硬盘文件、数据库。</p>
<ul>
<li>内存：将缓存存储于内存中是最快的选择，无需额外的I/O开销，但是内存的缺点是没有持久化落地物理磁盘，一旦应用异常break down而重新启动，数据很难或者无法复原。</li>
<li>硬盘：一般来说，很多缓存框架会结合使用内存和硬盘，在内存分配空间满了或是在异常的情况下，可以被动或主动的将内存空间数据持久化到硬盘中，达到释放空间或备份数据的目的。</li>
<li>数据库：前面有提到，增加缓存的策略的目的之一就是为了减少数据库的I/O压力。现在使用数据库做缓存介质是不是又回到了老问题上了? 其实，数据库也有很多种类型，像那些不支持SQL，只是简单的key-value存储结构的特殊数据库（如BerkeleyDB和Redis），响应速度和吞吐量都远远高于我们常用的关系型数据库等。</li>
</ul>
<h3 id="缓存淘汰算法"><a class="markdownIt-Anchor" href="#缓存淘汰算法"></a> 缓存淘汰算法</h3>
<p>FIFO/LFU/LRU/过期时间/随机</p>
<ul>
<li>FIFO：最先进入缓存的数据，在缓存空间不足时被清除，为了保证最新数据可用，保证实时性</li>
<li>LFU(Least Frequently Used)：最近最不常用，基于访问次数，去除命中次数最少的元素，保证高频数据有效性</li>
<li>LRU(Least Recently Used)：最近最少使用，基于访问时间，在被访问过的元素中去除最久未使用的元素，保证热点数据的有效性</li>
</ul>
<h3 id="哪里用了缓存"><a class="markdownIt-Anchor" href="#哪里用了缓存"></a> 哪里用了缓存</h3>
<p>一切地方。例如：</p>
<ul>
<li>我们从硬盘读数据的时候，其实操作系统还额外把附近的数据都读到了内存里</li>
<li>例如，CPU在从内存里读数据的时候，也额外读了许多数据到各级cache里</li>
<li>各个输入输出之间用buffer保存一批数据统一发送和接受，而不是一个byte一个byte的处理</li>
</ul>
<p>上面这是系统层面，在软件系统设计层面，很多地方也用了缓存：</p>
<ul>
<li>浏览器会缓存页面的元素，这样在重复访问网页时，就避开了要从互联网上下载数据（例如大图片）</li>
<li>web服务会把静态的东西提前部署在CDN上，这也是一种缓存</li>
<li>数据库会缓存查询，所以同一条查询第二次就是要比第一次快</li>
<li>内存数据库（如redis）选择把大量数据存在内存而非硬盘里，这可以看作是一个大型缓存，只是把整个数据库缓存了起来</li>
<li>应用程序把最近几次计算的结果放在本地内存里，如果下次到来的请求还是原请求，就跳过计算直接返回结果 …</li>
</ul>
<h2 id="缓存应用和实现"><a class="markdownIt-Anchor" href="#缓存应用和实现"></a> 缓存应用和实现</h2>
<p>缓存有各类特征，而且有不同介质的区别，那么实际工程中我们怎么去对缓存分类呢? 在目前的应用服务框架中，比较常见的是根据缓存与应用的藕合度，分为local cache（本地缓存）和remote cache（分布式缓存）：</p>
<ul>
<li><strong>本地缓存</strong>：指的是在应用中的缓存组件，其最大的优点是应用和cache是在同一个进程内部，请求缓存非常快速，没有过多的网络开销等，在单应用不需要集群支持或者集群情况下各节点无需互相通知的场景下使用本地缓存较合适；同时，它的缺点也是应为缓存跟应用程序耦合，多个应用程序无法直接的共享缓存，各应用或集群的各节点都需要维护自己的单独缓存，对内存是一种浪费。</li>
<li><strong>分布式缓存</strong>：指的是与应用分离的缓存组件或服务，其最大的优点是自身就是一个独立的应用，与本地应用隔离，多个应用可直接的共享缓存。</li>
</ul>
<p>目前各种类型的缓存都活跃在成千上万的应用服务中，还没有一种缓存方案可以解决一切的业务场景或数据类型，我们需要根据自身的特殊场景和背景，选择最适合的缓存方案。缓存的使用是程序员、架构师的必备技能，好的程序员能根据数据类型、业务场景来准确判断使用何种类型的缓存，如何使用这种缓存，以最小的成本最快的效率达到最优的目的。</p>
<h3 id="缓存实现-本地缓存"><a class="markdownIt-Anchor" href="#缓存实现-本地缓存"></a> 缓存实现-本地缓存</h3>
<p>编程直接实现缓存 个别场景下，我们只需要简单的缓存数据的功能，而无需关注更多存取、清空策略等深入的特性时，直接编程实现缓存则是最便捷和高效的。</p>
<h4 id="成员变量或局部变量实现"><a class="markdownIt-Anchor" href="#成员变量或局部变量实现"></a> 成员变量或局部变量实现</h4>
<p>简单代码示例如下：</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">UseLocalCache</span><span class="params">()</span>&#123;</span><br><span class="line">     <span class="comment">//一个本地的缓存变量</span></span><br><span class="line">     Map&lt;String, Object&gt; localCacheStoreMap = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;String, Object&gt;();</span><br><span class="line"></span><br><span class="line">    List&lt;Object&gt; infosList = <span class="built_in">this</span>.getInfoList();</span><br><span class="line">    <span class="keyword">for</span>(Object item:infosList)&#123;</span><br><span class="line">        <span class="keyword">if</span>(localCacheStoreMap.containsKey(item))&#123; <span class="comment">//缓存命中 使用缓存数据</span></span><br><span class="line">            <span class="comment">// todo</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123; <span class="comment">// 缓存未命中  IO获取数据，结果存入缓存</span></span><br><span class="line">            <span class="type">Object</span> <span class="variable">valueObject</span> <span class="operator">=</span> <span class="built_in">this</span>.getInfoFromDB();</span><br><span class="line">            localCacheStoreMap.put(valueObject.toString(), valueObject);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//示例</span></span><br><span class="line"><span class="keyword">private</span> List&lt;Object&gt; <span class="title function_">getInfoList</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Object&gt;();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//示例数据库IO获取</span></span><br><span class="line"><span class="keyword">private</span> Object <span class="title function_">getInfoFromDB</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>以局部变量map结构缓存部分业务数据，减少频繁的重复数据库I/O操作。缺点仅限于类的自身作用域内，类间无法共享缓存。</p>
<h4 id="静态变量实现"><a class="markdownIt-Anchor" href="#静态变量实现"></a> 静态变量实现</h4>
<p>最常用的单例实现静态资源缓存，代码示例如下：</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CityUtils</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">HttpClient</span> <span class="variable">httpClient</span> <span class="operator">=</span> ServerHolder.createClientWithPool(); </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Map&lt;Integer, String&gt; cityIdNameMap = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;Integer, String&gt;();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Map&lt;Integer, String&gt; districtIdNameMap = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;Integer, String&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="type">HttpGet</span> <span class="variable">get</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HttpGet</span>(<span class="string">&quot;http://gis-in.sankuai.com/api/location/city/all&quot;</span>);</span><br><span class="line">        BaseAuthorizationUtils.generateAuthAndDateHeader(get,</span><br><span class="line">                BaseAuthorizationUtils.CLIENT_TO_REQUEST_MDC,</span><br><span class="line">                BaseAuthorizationUtils.SECRET_TO_REQUEST_MDC);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">resultStr</span> <span class="operator">=</span> httpClient.execute(get, <span class="keyword">new</span> <span class="title class_">BasicResponseHandler</span>());</span><br><span class="line">            <span class="type">JSONObject</span> <span class="variable">resultJo</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">JSONObject</span>(resultStr);</span><br><span class="line">            <span class="type">JSONArray</span> <span class="variable">dataJa</span> <span class="operator">=</span> resultJo.getJSONArray(<span class="string">&quot;data&quot;</span>);</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; dataJa.length(); i++) &#123;</span><br><span class="line">                <span class="type">JSONObject</span> <span class="variable">itemJo</span> <span class="operator">=</span> dataJa.getJSONObject(i);</span><br><span class="line">                cityIdNameMap.put(itemJo.getInt(<span class="string">&quot;id&quot;</span>), itemJo.getString(<span class="string">&quot;name&quot;</span>));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;Init City List Error!&quot;</span>, e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="type">HttpGet</span> <span class="variable">get</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HttpGet</span>(<span class="string">&quot;http://gis-in.sankuai.com/api/location/district/all&quot;</span>);</span><br><span class="line">        BaseAuthorizationUtils.generateAuthAndDateHeader(get,</span><br><span class="line">                BaseAuthorizationUtils.CLIENT_TO_REQUEST_MDC,</span><br><span class="line">                BaseAuthorizationUtils.SECRET_TO_REQUEST_MDC);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">resultStr</span> <span class="operator">=</span> httpClient.execute(get, <span class="keyword">new</span> <span class="title class_">BasicResponseHandler</span>());</span><br><span class="line">            <span class="type">JSONObject</span> <span class="variable">resultJo</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">JSONObject</span>(resultStr);</span><br><span class="line">            <span class="type">JSONArray</span> <span class="variable">dataJa</span> <span class="operator">=</span> resultJo.getJSONArray(<span class="string">&quot;data&quot;</span>);</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; dataJa.length(); i++) &#123;</span><br><span class="line">                <span class="type">JSONObject</span> <span class="variable">itemJo</span> <span class="operator">=</span> dataJa.getJSONObject(i);</span><br><span class="line">                districtIdNameMap.put(itemJo.getInt(<span class="string">&quot;id&quot;</span>), itemJo.getString(<span class="string">&quot;name&quot;</span>));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;Init District List Error!&quot;</span>, e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">getCityName</span><span class="params">(<span class="type">int</span> cityId)</span> &#123;</span><br><span class="line">      <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> cityIdNameMap.get(cityId);</span><br><span class="line">      <span class="keyword">if</span> (name == <span class="literal">null</span>) &#123;</span><br><span class="line">        name = <span class="string">&quot;未知&quot;</span>;</span><br><span class="line">      &#125;</span><br><span class="line">       <span class="keyword">return</span> name;</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">getDistrictName</span><span class="params">(<span class="type">int</span> districtId)</span> &#123;</span><br><span class="line">      <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> districtIdNameMap.get(districtId);</span><br><span class="line">       <span class="keyword">if</span> (name == <span class="literal">null</span>) &#123;</span><br><span class="line">         name = <span class="string">&quot;未知&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">       <span class="keyword">return</span> name;</span><br><span class="line">     &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>O2O业务中常用的城市基础基本信息判断，通过静态变量一次获取缓存内存中，减少频繁的I/O读取，静态变量实现类间可共享，进程内可共享，缓存的实时性稍差。</p>
<p>为了解决本地缓存数据的实时性问题，目前大量使用的是结合ZooKeeper的自动发现机制，实时变更本地静态变量缓存：</p>
<p>美团内部的基础配置组件MtConfig，采用的就是类似原理，使用静态变量缓存，结合ZooKeeper的统一管理，做到自动动态更新缓存，如图2所示。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://pdai.tech/images/arch/arch-x-cache-2.png"
                      alt="img" 
                ></p>
<p>图2 Mtconfig实现图</p>
<p>这类缓存实现，优点是能直接在heap区内读写，最快也最方便；缺点同样是受heap区域影响，缓存的数据量非常有限，同时缓存时间受GC影响。主要满足单机场景下的小数据量缓存需求，同时对缓存数据的变更无需太敏感感知，如上一般配置管理、基础静态数据等场景。</p>
<h3 id="ehcache"><a class="markdownIt-Anchor" href="#ehcache"></a> Ehcache</h3>
<p>Ehcache是现在最流行的纯Java开源缓存框架，配置简单、结构清晰、功能强大，是一个非常轻量级的缓存实现，我们常用的Hibernate里面就集成了相关缓存功能。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://awps-assets.meituan.net/mit-x/blog-images-bundle-2017/b810d158.png"
                      alt="img" 
                ></p>
<p>图3 Ehcache框架图</p>
<p>从图3中我们可以了解到，Ehcache的核心定义主要包括：</p>
<ul>
<li>cache manager：缓存管理器，以前是只允许单例的，不过现在也可以多实例了。</li>
<li>cache：缓存管理器内可以放置若干cache，存放数据的实质，所有cache都实现了Ehcache接口，这是一个真正使用的缓存实例；通过缓存管理器的模式，可以在单个应用中轻松隔离多个缓存实例，独立服务于不同业务场景需求，缓存数据物理隔离，同时需要时又可共享使用。</li>
<li>element：单条缓存数据的组成单位。</li>
<li>system of record（SOR）：可以取到真实数据的组件，可以是真正的业务逻辑、外部接口调用、存放真实数据的数据库等，缓存就是从SOR中读取或者写入到SOR中去的。</li>
</ul>
<p>在上层可以看到，整个Ehcache提供了对JSR、JMX等的标准支持，能够较好的兼容和移植，同时对各类对象有较完善的监控管理机制。它的缓存介质涵盖堆内存（heap）、堆外内存（BigMemory商用版本支持）和磁盘，各介质可独立设置属性和策略。Ehcache最初是独立的本地缓存框架组件，在后期的发展中，结合Terracotta服务阵列模型，可以支持分布式缓存集群，主要有RMI、JGroups、JMS和Cache Server等传播方式进行节点间通信，如图3的左侧部分描述。</p>
<p>整体数据流转包括这样几类行为:</p>
<ul>
<li>Flush：缓存条目向低层次移动。</li>
<li>Fault：从低层拷贝一个对象到高层。在获取缓存的过程中，某一层发现自己的该缓存条目已经失效，就触发了Fault行为。</li>
<li>Eviction：把缓存条目除去。</li>
<li>Expiration：失效状态。</li>
<li>Pinning：强制缓存条目保持在某一层。</li>
</ul>
<p>图4反映了数据在各个层之间的流转，同时也体现了各层数据的一个生命周期。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://pdai.tech/images/arch/arch-x-cache-4.png"
                      alt="img" 
                ></p>
<p>图4 缓存数据流转图（L1:本地内存层；L2:Terracotta服务节点层)</p>
<p>Ehcache的配置使用如下：</p>
<div class="highlight-container" data-rel="Xml"><figure class="iseeu highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ehcache</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 指定一个文件目录，当Ehcache把数据写到硬盘上时，将把数据写到这个文件目录下 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">diskStore</span> <span class="attr">path</span>=<span class="string">&quot;java.io.tmpdir&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 设定缓存的默认数据过期策略 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">defaultCache</span></span></span><br><span class="line"><span class="tag">        <span class="attr">maxElementsInMemory</span>=<span class="string">&quot;10000&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">eternal</span>=<span class="string">&quot;false&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">overflowToDisk</span>=<span class="string">&quot;true&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">timeToIdleSeconds</span>=<span class="string">&quot;0&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">timeToLiveSeconds</span>=<span class="string">&quot;0&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">diskPersistent</span>=<span class="string">&quot;false&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">diskExpiryThreadIntervalSeconds</span>=<span class="string">&quot;120&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--  </span></span><br><span class="line"><span class="comment">    设定具体的命名缓存的数据过期策略</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    cache元素的属性：</span></span><br><span class="line"><span class="comment">        name：缓存名称</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        maxElementsInMemory：内存中最大缓存对象数</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        maxElementsOnDisk：硬盘中最大缓存对象数，若是0表示无穷大</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        eternal：true表示对象永不过期，此时会忽略timeToIdleSeconds和timeToLiveSeconds属性，默认为false</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        overflowToDisk：true表示当内存缓存的对象数目达到了maxElementsInMemory界限后，会把溢出的对象写到硬盘缓存中。注意：如果缓存的对象要写入到硬盘中的话，则该对象必须实现了Serializable接口才行。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        diskSpoolBufferSizeMB：磁盘缓存区大小，默认为30MB。每个Cache都应该有自己的一个缓存区。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        diskPersistent：是否缓存虚拟机重启期数据</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        diskExpiryThreadIntervalSeconds：磁盘失效线程运行时间间隔，默认为120秒</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        timeToIdleSeconds： 设定允许对象处于空闲状态的最长时间，以秒为单位。当对象自从最近一次被访问后，如果处于空闲状态的时间超过了timeToIdleSeconds属性值，这个对象就会过期，EHCache将把它从缓存中清空。只有当eternal属性为false，该属性才有效。如果该属性值为0，则表示对象可以无限期地处于空闲状态</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        timeToLiveSeconds：设定对象允许存在于缓存中的最长时间，以秒为单位。当对象自从被存放到缓存中后，如果处于缓存中的时间超过了 timeToLiveSeconds属性值，这个对象就会过期，Ehcache将把它从缓存中清除。只有当eternal属性为false，该属性才有效。如果该属性值为0，则表示对象可以无限期地存在于缓存中。timeToLiveSeconds必须大于timeToIdleSeconds属性，才有意义</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        memoryStoreEvictionPolicy：当达到maxElementsInMemory限制时，Ehcache将会根据指定的策略去清理内存。可选策略有：LRU（最近最少使用，默认策略）、FIFO（先进先出）、LFU（最少访问次数）。</span></span><br><span class="line"><span class="comment">--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">cache</span> <span class="attr">name</span>=<span class="string">&quot;CACHE1&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">maxElementsInMemory</span>=<span class="string">&quot;1000&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">eternal</span>=<span class="string">&quot;true&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">overflowToDisk</span>=<span class="string">&quot;true&quot;</span>/&gt;</span>  </span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">cache</span> <span class="attr">name</span>=<span class="string">&quot;CACHE2&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">maxElementsInMemory</span>=<span class="string">&quot;1000&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">eternal</span>=<span class="string">&quot;false&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">timeToIdleSeconds</span>=<span class="string">&quot;200&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">timeToLiveSeconds</span>=<span class="string">&quot;4000&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">overflowToDisk</span>=<span class="string">&quot;true&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ehcache</span>&gt;</span></span><br></pre></td></tr></table></figure></div>
<p>整体上看，Ehcache的使用还是相对简单便捷的，提供了完整的各类API接口。需要注意的是，虽然Ehcache支持磁盘的持久化，但是由于存在两级缓存介质，在一级内存中的缓存，如果没有主动的刷入磁盘持久化的话，在应用异常down机等情形下，依然会出现缓存数据丢失，为此可以根据需要将缓存刷到磁盘，将缓存条目刷到磁盘的操作可以通过cache.flush()方法来执行，需要注意的是，对于对象的磁盘写入，前提是要将对象进行序列化。</p>
<p>主要特性：</p>
<ul>
<li>快速，针对大型高并发系统场景，Ehcache的多线程机制有相应的优化改善。</li>
<li>简单，很小的jar包，简单配置就可直接使用，单机场景下无需过多的其他服务依赖。</li>
<li>支持多种的缓存策略，灵活。</li>
<li>缓存数据有两级：内存和磁盘，与一般的本地内存缓存相比，有了磁盘的存储空间，将可以支持更大量的数据缓存需求。</li>
<li>具有缓存和缓存管理器的侦听接口，能更简单方便的进行缓存实例的监控管理。</li>
<li>支持多缓存管理器实例，以及一个实例的多个缓存区域。</li>
</ul>
<p>注意：Ehcache的超时设置主要是针对整个cache实例设置整体的超时策略，而没有较好的处理针对单独的key的个性的超时设置（有策略设置，但是比较复杂，就不描述了），因此，在使用中要注意过期失效的缓存元素无法被GC回收，时间越长缓存越多，内存占用也就越大，内存泄露的概率也越大。</p>
<h4 id="guava-cache"><a class="markdownIt-Anchor" href="#guava-cache"></a> Guava Cache</h4>
<p>Guava Cache是Google开源的Java重用工具集库Guava里的一款缓存工具，其主要实现的缓存功能有：</p>
<ul>
<li>自动将entry节点加载进缓存结构中；</li>
<li>当缓存的数据超过设置的最大值时，使用LRU算法移除；</li>
<li>具备根据entry节点上次被访问或者写入时间计算它的过期机制；</li>
<li>缓存的key被封装在WeakReference引用内；</li>
<li>缓存的Value被封装在WeakReference或SoftReference引用内；</li>
<li>统计缓存使用过程中命中率、异常率、未命中率等统计数据。</li>
</ul>
<p>Guava Cache的架构设计灵感来源于ConcurrentHashMap，我们前面也提到过，简单场景下可以自行编码通过hashmap来做少量数据的缓存，但是，如果结果可能随时间改变或者是希望存储的数据空间可控的话，自己实现这种数据结构还是有必要的。</p>
<p>Guava Cache继承了ConcurrentHashMap的思路，使用多个segments方式的细粒度锁，在保证线程安全的同时，支持高并发场景需求。Cache类似于Map，它是存储键值对的集合，不同的是它还需要处理evict、expire、dynamic load等算法逻辑，需要一些额外信息来实现这些操作。对此，根据面向对象思想，需要做方法与数据的关联封装。如图5所示cache的内存数据模型，可以看到，使用ReferenceEntry接口来封装一个键值对，而用ValueReference来封装Value值，之所以用Reference命令，是因为Cache要支持WeakReference Key和SoftReference、WeakReference value。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://pdai.tech/images/arch/arch-x-cache-5.png"
                      alt="img" 
                ></p>
<p>图5 Guava Cache数据结构图</p>
<p><strong>ReferenceEntry</strong>是对一个键值对节点的抽象，它包含了key和值的ValueReference抽象类，Cache由多个Segment组成，而每个Segment包含一个ReferenceEntry数组，每个ReferenceEntry数组项都是一条ReferenceEntry链，且一个ReferenceEntry包含key、hash、valueReference、next字段。除了在ReferenceEntry数组项中组成的链，在一个Segment中，所有ReferenceEntry还组成access链（accessQueue）和write链（writeQueue）（后面会介绍链的作用）。ReferenceEntry可以是强引用类型的key，也可以WeakReference类型的key，为了减少内存使用量，还可以根据是否配置了expireAfterWrite、expireAfterAccess、maximumSize来决定是否需要write链和access链确定要创建的具体Reference：StrongEntry、StrongWriteEntry、StrongAccessEntry、StrongWriteAccessEntry等。</p>
<p><strong>对于ValueReference</strong>，因为Cache支持强引用的Value、SoftReference Value以及WeakReference Value，因而它对应三个实现类：StrongValueReference、SoftValueReference、WeakValueReference。为了支持动态加载机制，它还有一个LoadingValueReference，在需要动态加载一个key的值时，先把该值封装在LoadingValueReference中，以表达该key对应的值已经在加载了，如果其他线程也要查询该key对应的值，就能得到该引用，并且等待改值加载完成，从而保证该值只被加载一次，在该值加载完成后，将LoadingValueReference替换成其他ValueReference类型。ValueReference对象中会保留对ReferenceEntry的引用，这是因为在Value因为WeakReference、SoftReference被回收时，需要使用其key将对应的项从Segment的table中移除。</p>
<p><strong>WriteQueue和AccessQueue</strong> ：为了实现最近最少使用算法，Guava Cache在Segment中添加了两条链：write链（writeQueue）和access链（accessQueue），这两条链都是一个双向链表，通过ReferenceEntry中的previousInWriteQueue、nextInWriteQueue和previousInAccessQueue、nextInAccessQueue链接而成，但是以Queue的形式表达。WriteQueue和AccessQueue都是自定义了offer、add（直接调用offer）、remove、poll等操作的逻辑，对offer（add）操作，如果是新加的节点，则直接加入到该链的结尾，如果是已存在的节点，则将该节点链接的链尾；对remove操作，直接从该链中移除该节点；对poll操作，将头节点的下一个节点移除，并返回。</p>
<p>了解了cache的整体数据结构后，再来看下针对缓存的相关操作就简单多了：</p>
<ul>
<li><strong>Segment中的evict清除策略操作</strong>，是在每一次调用操作的开始和结束时触发清理工作，这样比一般的缓存另起线程监控清理相比，可以减少开销，但如果长时间没有调用方法的话，会导致不能及时的清理释放内存空间的问题。evict主要处理四个Queue：1. keyReferenceQueue；2. valueReferenceQueue；3. writeQueue；4. accessQueue。前两个queue是因为WeakReference、SoftReference被垃圾回收时加入的，清理时只需要遍历整个queue，将对应的项从LocalCache中移除即可，这里keyReferenceQueue存放ReferenceEntry，而valueReferenceQueue存放的是ValueReference，要从Cache中移除需要有key，因而ValueReference需要有对ReferenceEntry的引用，这个前面也提到过了。而对后面两个Queue，只需要检查是否配置了相应的expire时间，然后从头开始查找已经expire的Entry，将它们移除即可。</li>
<li><strong>Segment中的put操作</strong>：put操作相对比较简单，首先它需要获得锁，然后尝试做一些清理工作，接下来的逻辑类似ConcurrentHashMap中的rehash，查找位置并注入数据。需要说明的是当找到一个已存在的Entry时，需要先判断当前的ValueRefernece中的值事实上已经被回收了，因为它们可以是WeakReference、SoftReference类型，如果已经被回收了，则将新值写入。并且在每次更新时注册当前操作引起的移除事件，指定相应的原因：COLLECTED、REPLACED等，这些注册的事件在退出的时候统一调用Cache注册的RemovalListener，由于事件处理可能会有很长时间，因而这里将事件处理的逻辑在退出锁以后才做。最后，在更新已存在的Entry结束后都尝试着将那些已经expire的Entry移除。另外put操作中还需要更新writeQueue和accessQueue的语义正确性。</li>
<li><strong>Segment带CacheLoader的get操作</strong>：1. 先查找table中是否已存在没有被回收、也没有expire的entry，如果找到，并在CacheBuilder中配置了refreshAfterWrite，并且当前时间间隔已经操作这个事件，则重新加载值，否则，直接返回原有的值；2. 如果查找到的ValueReference是LoadingValueReference，则等待该LoadingValueReference加载结束，并返回加载的值；3. 如果没有找到entry，或者找到的entry的值为null，则加锁后，继续在table中查找已存在key对应的entry，如果找到并且对应的entry.isLoading()为true，则表示有另一个线程正在加载，因而等待那个线程加载完成，如果找到一个非null值，返回该值，否则创建一个LoadingValueReference，并调用loadSync加载相应的值，在加载完成后，将新加载的值更新到table中，即大部分情况下替换原来的LoadingValueReference。</li>
</ul>
<p>Guava Cache提供Builder模式的CacheBuilder生成器来创建缓存的方式，十分方便，并且各个缓存参数的配置设置，类似于函数式编程的写法，可自行设置各类参数选型。它提供三种方式加载到缓存中。分别是：</p>
<ul>
<li>在构建缓存的时候，使用build方法内部调用CacheLoader方法加载数据；</li>
<li>callable 、callback方式加载数据；</li>
<li>使用粗暴直接的方式，直接Cache.put 加载数据，但自动加载是首选的，因为它可以更容易的推断所有缓存内容的一致性。</li>
</ul>
<p>build生成器的两种方式都实现了一种逻辑：从缓存中取key的值，如果该值已经缓存过了则返回缓存中的值，如果没有缓存过可以通过某个方法来获取这个值，不同的地方在于cacheloader的定义比较宽泛，是针对整个cache定义的，可以认为是统一的根据key值load value的方法，而callable的方式较为灵活，允许你在get的时候指定load方法。使用示例如下：</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * CacheLoader</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">loadingCache</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  LoadingCache&lt;String, String&gt; graphs =CacheBuilder.newBuilder()</span><br><span class="line">     .maximumSize(<span class="number">1000</span>).build(<span class="keyword">new</span> <span class="title class_">CacheLoader</span>&lt;String, String&gt;()</span><br><span class="line">     &#123;</span><br><span class="line">         <span class="meta">@Override</span></span><br><span class="line">         <span class="keyword">public</span> String <span class="title function_">load</span><span class="params">(String key)</span> <span class="keyword">throws</span> Exception</span><br><span class="line">         &#123;</span><br><span class="line">             System.out.println(<span class="string">&quot;key:&quot;</span>+key);</span><br><span class="line">             <span class="keyword">if</span>(<span class="string">&quot;key&quot;</span>.equals(key))&#123;</span><br><span class="line">                 <span class="keyword">return</span> <span class="string">&quot;key return result&quot;</span>;</span><br><span class="line">             &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                 <span class="keyword">return</span> <span class="string">&quot;get-if-absent-compute&quot;</span>;</span><br><span class="line">             &#125;                   </span><br><span class="line">         &#125;</span><br><span class="line">     &#125;);</span><br><span class="line"><span class="type">String</span> <span class="variable">resultVal</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    resultVal = graphs.get(<span class="string">&quot;key&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (ExecutionException e) &#123;</span><br><span class="line">      e.printStackTrace();</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line"> System.out.println(resultVal);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Callable</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">callablex</span><span class="params">()</span> <span class="keyword">throws</span> ExecutionException</span><br><span class="line"> &#123;</span><br><span class="line">   Cache&lt;String, String&gt; cache = CacheBuilder.newBuilder()</span><br><span class="line">     .maximumSize(<span class="number">1000</span>).build();</span><br><span class="line">   <span class="type">String</span> <span class="variable">result</span> <span class="operator">=</span> cache.get(<span class="string">&quot;key&quot;</span>, <span class="keyword">new</span> <span class="title class_">Callable</span>&lt;String&gt;()</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">public</span> String <span class="title function_">call</span><span class="params">()</span></span><br><span class="line">      &#123;</span><br><span class="line">       <span class="keyword">return</span> <span class="string">&quot;result&quot;</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">  System.out.println(result);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></div>
<p>总体来看，Guava Cache基于ConcurrentHashMap的优秀设计借鉴，在高并发场景支持和线程安全上都有相应的改进策略，使用Reference引用命令，提升高并发下的数据……访问速度并保持了GC的可回收，有效节省空间；同时，write链和access链的设计，能更灵活、高效的实现多种类型的缓存清理策略，包括基于容量的清理、基于时间的清理、基于引用的清理等；编程式的build生成器管理，让使用者有更多的自由度，能够根据不同场景设置合适的模式。</p>
<h3 id="缓存实现方式-注解方式"><a class="markdownIt-Anchor" href="#缓存实现方式-注解方式"></a> 缓存实现方式 - 注解方式</h3>
<h4 id="spring注解缓存"><a class="markdownIt-Anchor" href="#spring注解缓存"></a> Spring注解缓存</h4>
<p>Spring 3.1之后，引入了注解缓存技术，其本质上不是一个具体的缓存实现方案，而是一个对缓存使用的抽象，通过在既有代码中添加少量自定义的各种annotation，即能够达到使用缓存对象和缓存方法的返回对象的效果。Spring的缓存技术具备相当的灵活性，不仅能够使用SpEL（Spring Expression Language）来定义缓存的key和各种condition，还提供开箱即用的缓存临时存储方案，也支持和主流的专业缓存集成。其特点总结如下：</p>
<ul>
<li>少量的配置annotation注释即可使得既有代码支持缓存；</li>
<li>支持开箱即用，不用安装和部署额外的第三方组件即可使用缓存；</li>
<li>支持Spring Express Language（SpEL），能使用对象的任何属性或者方法来定义缓存的key和使用规则条件；</li>
<li>支持自定义key和自定义缓存管理者，具有相当的灵活性和可扩展性。</li>
</ul>
<p>和Spring的事务管理类似，Spring Cache的关键原理就是Spring AOP，通过Spring AOP实现了在方法调用前、调用后获取方法的入参和返回值，进而实现了缓存的逻辑。而Spring Cache利用了Spring AOP的动态代理技术，即当客户端尝试调用pojo的foo()方法的时候，给它的不是pojo自身的引用，而是一个动态生成的代理类。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://pdai.tech/images/arch/arch-x-cache-12.png"
                      alt="img" 
                ></p>
<p>图12 Spring动态代理调用图</p>
<p>如图12所示，实际客户端获取的是一个代理的引用，在调用foo()方法的时候，会首先调用proxy的foo()方法，这个时候proxy可以整体控制实际的pojo.foo()方法的入参和返回值，比如缓存结果，比如直接略过执行实际的foo()方法等，都是可以轻松做到的。Spring Cache主要使用三个注释标签，即@Cacheable、@CachePut和@CacheEvict，主要针对方法上注解使用，部分场景也可以直接类上注解使用，当在类上使用时，该类所有方法都将受影响。我们总结一下其作用和配置方法，如下表所示。</p>
<table>
<thead>
<tr>
<th>标签类型</th>
<th>作用</th>
<th>主要配置参数说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>@Cacheable</td>
<td>主要针对方法配置，能够根据方法的请求参数对其结果进行缓存</td>
<td>value：缓存的名称，在 Spring 配置文件中定义，必须指定至少一个； key：缓存的 key，可以为空，如果指定要按照 SpEL 表达式编写，如果不指定，则默认按照方法的所有参数进行组合； condition：缓存的条件，可以为空，使用 SpEL 编写，返回 true 或者 false，只有为 true 才进行缓存</td>
</tr>
<tr>
<td>@CachePut</td>
<td>主要针对方法配置，能够根据方法的请求参数对其结果进行缓存，和 @Cacheable 不同的是，它每次都会触发真实方法的调用</td>
<td>value：缓存的名称，在 spring 配置文件中定义，必须指定至少一个; key：缓存的 key，可以为空，如果指定要按照 SpEL 表达式编写，如果不指定，则默认按照方法的所有参数进行组合； condition：缓存的条件，可以为空，使用 SpEL 编写，返回 true 或者 false，只有为 true 才进行缓存</td>
</tr>
<tr>
<td>@CacheEvict</td>
<td>主要针对方法配置，能够根据一定的条件对缓存进行清空</td>
<td>value：缓存的名称，在 Spring 配置文件中定义，必须指定至少一个； key：缓存的 key，可以为空，如果指定要按照 SpEL 表达式编写，如果不指定，则默认按照方法的所有参数进行组合； condition：缓存的条件，可以为空，使用 SpEL 编写，返回 true 或者 false，只有为 true 才进行缓存； allEntries：是否清空所有缓存内容，默认为 false，如果指定为 true，则方法调用后将立即清空所有缓存； beforeInvocation：是否在方法执行前就清空，默认为 false，如果指定为 true，则在方法还没有执行的时候就清空缓存，默认情况下，如果方法执行抛出异常，则不会清空缓存</td>
</tr>
</tbody>
</table>
<p><strong>可扩展支持</strong>：Spring注解cache能够满足一般应用对缓存的需求，但随着应用服务的复杂化，大并发高可用性能要求下，需要进行一定的扩展，这时对其自身集成的缓存方案可能不太适用，该怎么办? Spring预先有考虑到这点，那么怎样利用Spring提供的扩展点实现我们自己的缓存，且在不改变原来已有代码的情况下进行扩展? 是否在方法执行前就清空，默认为false，如果指定为true，则在方法还没有执行的时候就清空缓存，默认情况下，如果方法执行抛出异常，则不会清空缓存。</p>
<blockquote>
<p>这基本能够满足一般应用对缓存的需求，但现实总是很复杂，当你的用户量上去或者性能跟不上，总需要进行扩展，这个时候你或许对其提供的内存缓存不满意了，因为其不支持高可用性，也不具备持久化数据能力，这个时候，你就需要自定义你的缓存方案了，还好，Spring也想到了这一点。</p>
</blockquote>
<p>我们先不考虑如何持久化缓存，毕竟这种第三方的实现方案很多，我们要考虑的是，怎么利用Spring提供的扩展点实现我们自己的缓存，且在不改原来已有代码的情况下进行扩展。这需要简单的三步骤，首先需要提供一个CacheManager接口的实现（继承至AbstractCacheManager），管理自身的cache实例；其次，实现自己的cache实例MyCache(继承至Cache)，在这里面引入我们需要的第三方cache或自定义cache；最后就是对配置项进行声明，将MyCache实例注入CacheManager进行统一管理。</p>
<h4 id="用户自定义注解缓存基于spring注解"><a class="markdownIt-Anchor" href="#用户自定义注解缓存基于spring注解"></a> 用户自定义注解缓存(基于Spring注解)</h4>
<blockquote>
<p>以下是美团酒店商家端使用自定义的缓存注解的方案</p>
</blockquote>
<p>注解缓存的使用，可以有效增强应用代码的可读性，同时统一管理缓存，提供较好的可扩展性，为此，酒店商家端在Spring注解缓存基础上，自定义了适合自身业务特性的注解缓存。</p>
<p>主要使用两个标签，即@HotelCacheable、@HotelCacheEvict，其作用和配置方法见下表。</p>
<table>
<thead>
<tr>
<th>标签类型</th>
<th>作用</th>
<th>主要配置参数说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>@HotelCacheable</td>
<td>主要针对方法配置，能够根据方法的请求参数对其结果进行缓存</td>
<td>domain：作用域，针对集合场景，解决批量更新问题； domainKey：作用域对应的缓存key； key：缓存对象key 前缀； fieldKey：缓存对象key，与前缀合并生成对象key； condition：缓存获取前置条件，支持spel语法； cacheCondition：缓存刷入前置条件，支持spel语法； expireTime：超时时间设置</td>
</tr>
<tr>
<td>@HotelCacheEvict</td>
<td>主要针对方法配置，能够根据一定的条件对缓存进行清空</td>
<td>同上</td>
</tr>
</tbody>
</table>
<p>增加作用域的概念，解决商家信息变更下，多重重要信息实时更新的问题。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://pdai.tech/images/arch/arch-x-cache-13.png"
                      alt="img" 
                ></p>
<p>图13 域缓存处理图</p>
<p>如图13，按旧的方案，当cache0发送变化时，为了保持信息的实时更新，需要手动删除cache1、cache2、cache3等相关处的缓存数据。增加域缓存概念，cache0、cache1、cache2、cache3是以账号ID为基础，相互存在影响约束的集合体，我们作为一个域集合，增加域缓存处理，当cache0发送变化时，整体的账号ID domain域已发生更新，自动影响cache1、cache2、cache3等处的缓存数据。将相关联逻辑缓存统一化，有效提升代码可读性，同时更好服务业务，账号重点信息能够实时变更刷新，相关服务响应速度提升。</p>
<p>另外，增加了cacheCondition缓存刷入前置判断，有效解决商家业务多重外部依赖场景下，业务降级有损服务下，业务数据一致性保证，不因为缓存的增加影响业务的准确性；自定义CacheManager缓存管理器，可以有效兼容公共基础组件Medis、Cellar相关服务，在对应用程序不做改动的情况下，有效切换缓存方式；同时，统一的缓存服务AOP入口，结合接入Mtconfig统一配置管理，对应用内缓存做好降级准备，一键关闭缓存。几点建议：</p>
<ul>
<li>上面介绍过Spring Cache的原理是基于动态生成的proxy代理机制来进行切面处理，关键点是对象的引用问题，如果对象的方法是类里面的内部调用（this引用）而不是外部引用的场景下，会导致proxy失败，那么我们所做的缓存切面处理也就失效了。因此，应避免已注解缓存的方法在类里面的内部调用。</li>
<li>使用的key约束，缓存的key应尽量使用简单的可区别的元素，如ID、名称等，不能使用list等容器的值，或者使用整体model对象的值。非public方法无法使用注解缓存实现。</li>
</ul>
<blockquote>
<p>总之，注释驱动的Spring Cache能够极大的减少我们编写常见缓存的代码量，通过少量的注释标签和配置文件，即可达到使代码具备缓存的能力，且具备很好的灵活性和扩展性。但是我们也应该看到，Spring Cache由于基于Spring AOP技术，尤其是动态的proxy技术，导致其不能很好的支持方法的内部调用或者非public方法的缓存设置，当然这些都是可以解决的问题。</p>
</blockquote>
<h2 id="高并发缓存问题"><a class="markdownIt-Anchor" href="#高并发缓存问题"></a> 高并发缓存问题</h2>
<h3 id="缓存一致性问题"><a class="markdownIt-Anchor" href="#缓存一致性问题"></a> 缓存一致性问题</h3>
<p>当数据时效性要求很高时，需要保证缓存中的数据与数据库中的保持一致，而且需要保证缓存节点和副本中的数据也保持一致，不能出现差异现象。这就比较依赖缓存的过期和更新策略。一般会在数据发生更改的时，主动更新缓存中的数据或者移除对应的缓存。</p>
<h3 id="缓存并发问题"><a class="markdownIt-Anchor" href="#缓存并发问题"></a> 缓存并发问题</h3>
<p>缓存过期后将尝试从后端数据库获取数据，这是一个看似合理的流程。但是，在高并发场景下，有可能多个请求并发的去从数据库获取数据，对后端数据库造成极大的冲击，甚至导致 “雪崩”现象。此外，当某个缓存key在被更新时，同时也可能被大量请求在获取，这也会导致一致性的问题。那如何避免类似问题呢? 我们会想到类似“锁”的机制，在缓存更新或者过期的情况下，先尝试获取到锁，当更新或者从数据库获取完成后再释放锁，其他的请求只需要牺牲一定的等待时间，即可直接从缓存中继续获取数据。</p>
<h3 id="缓存穿透问题"><a class="markdownIt-Anchor" href="#缓存穿透问题"></a> 缓存穿透问题</h3>
<p>缓存穿透在有些地方也称为“击穿”。很多朋友对缓存穿透的理解是：由于缓存故障或者缓存过期导致大量请求穿透到后端数据库服务器，从而对数据库造成巨大冲击。</p>
<p>这其实是一种误解。真正的缓存穿透应该是这样的：</p>
<p>在高并发场景下，如果某一个key被高并发访问，没有被命中，出于对容错性考虑，会尝试去从后端数据库中获取，从而导致了大量请求达到数据库，而当该key对应的数据本身就是空的情况下，这就导致数据库中并发的去执行了很多不必要的查询操作，从而导致巨大冲击和压力。</p>
<p>可以通过下面的几种常用方式来避免缓存传统问题：</p>
<ul>
<li>缓存空对象</li>
</ul>
<p>对查询结果为空的对象也进行缓存，如果是集合，可以缓存一个空的集合（非null），如果是缓存单个对象，可以通过字段标识来区分。这样避免请求穿透到后端数据库。同时，也需要保证缓存数据的时效性。这种方式实现起来成本较低，比较适合命中不高，但可能被频繁更新的数据。</p>
<ul>
<li>单独过滤处理</li>
</ul>
<p>对所有可能对应数据为空的key进行统一的存放，并在请求前做拦截，这样避免请求穿透到后端数据库。这种方式实现起来相对复杂，比较适合命中不高，但是更新不频繁的数据。</p>
<h3 id="缓存抖动问题"><a class="markdownIt-Anchor" href="#缓存抖动问题"></a> 缓存抖动问题</h3>
<p>缓存抖动可以看做是一种比“雪崩”更轻微的故障，但是也会在一段时间内对系统造成冲击和性能影响。一般是由于缓存节点故障导致。业内推荐的做法是通过一致性Hash算法来解决。这里不做过多阐述。</p>
<h3 id="缓存雪崩问题"><a class="markdownIt-Anchor" href="#缓存雪崩问题"></a> 缓存雪崩问题</h3>
<p>缓存雪崩就是指由于缓存的原因，导致大量请求到达后端数据库，从而导致数据库崩溃，整个系统崩溃，发生灾难。导致这种现象的原因有很多种，上面提到的“缓存并发”，“缓存穿透”，“缓存颠簸”等问题，其实都可能会导致缓存雪崩现象发生。这些问题也可能会被恶意攻击者所利用。还有一种情况，例如某个时间点内，系统预加载的缓存周期性集中失效了，也可能会导致雪崩。为了避免这种周期性失效，可以通过设置不同的过期时间，来错开缓存过期，从而避免缓存集中失效。</p>
<p>从应用架构角度，我们可以通过限流、降级、熔断等手段来降低影响，也可以通过多级缓存来避免这种灾难。</p>
<p>此外，从整个研发体系流程的角度，应该加强压力测试，尽量模拟真实场景，尽早的暴露问题从而防范。</p>
<h2 id="合理利用缓存"><a class="markdownIt-Anchor" href="#合理利用缓存"></a> 合理利用缓存</h2>
<p>不合理使用缓存非但不能提高系统的性能，还会成为系统的累赘，甚至风险。</p>
<h3 id="频繁修改的数据"><a class="markdownIt-Anchor" href="#频繁修改的数据"></a> 频繁修改的数据</h3>
<p>如果缓存中保存的是频繁修改的数据，就会出现数据写入缓存后，应用还来不及读取缓存，数据就已经失效，徒增系统负担。一般来说，数据的读写比在2：1（写入一次缓存，在数据更新前至少读取两次）以上，缓存才有意义。</p>
<h3 id="没有热点的访问"><a class="markdownIt-Anchor" href="#没有热点的访问"></a> 没有热点的访问</h3>
<p>如果应用系统访问数据没有热点，不遵循二八定律，那么缓存就没有意义。</p>
<h3 id="数据不一致与脏读"><a class="markdownIt-Anchor" href="#数据不一致与脏读"></a> 数据不一致与脏读</h3>
<p>一般会对缓存的数据设置失效时间，一旦超过失效时间，就要从数据库中重新加载。因此要容忍一定时间的数据不一致，如卖家已经编辑了商品属性，但是需要过一段时间才能被买家看到。还有一种策略是数据更新立即更新缓存，不过这也会带来更多系统开销和事务一致性问题。</p>
<h3 id="缓存可用性"><a class="markdownIt-Anchor" href="#缓存可用性"></a> 缓存可用性</h3>
<p>缓存会承担大部分数据库访问压力，数据库已经习惯了有缓存的日子，所以当缓存服务崩溃时，数据库会因为完全不能承受如此大压力而宕机，导致网站不可用。这种情况被称作缓存雪崩，发生这种故障，甚至不能简单地重启缓存服务器和数据库服务器来恢复。</p>
<p>实践中，有的网站通过缓存热备份等手段提高缓存可用性：当某台缓存服务器宕机时，将缓存访问切换到热备服务器上。但这种设计有违缓存的初衷，缓存根本就不应该当做一个可靠的数据源来使用。</p>
<p>通过分布式缓存服务器集群，将缓存数据分布到集群多台服务器上可在一定程度上改善缓存的可用性。当一台缓存服务器宕机时，只有部分缓存数据丢失，重新从数据库加载这部分数据不会产生很大的影响。</p>
<h3 id="缓存预热warm-up"><a class="markdownIt-Anchor" href="#缓存预热warm-up"></a> 缓存预热（warm up）</h3>
<p>缓存中存放的是热点数据，热点数据又是缓存系统利用LRU（最近最久未用算法）对不断访问的数据筛选淘汰出来，这个过程需要花费较长的时间。新系统的缓存系统如果没有任何数据，在重建缓存数据的过程中，系统的性能和数据库负载都不太好，那么最好在缓存系统启动时就把热点数据加载好，这个缓存预加载手段叫缓存预热。对于一些元数据如城市地名列表、类目信息，可以在启动时加载数据库中全部数据到缓存进行预热。</p>
<h3 id="避免缓存穿透"><a class="markdownIt-Anchor" href="#避免缓存穿透"></a> 避免缓存穿透</h3>
<p>如果因为不恰当的业务、或者恶意攻击持续高并发地请求某个不存在的数据，由于缓存没有保存该数据，所有的请求都会落到数据库上，会对数据库造成压力，甚至崩溃。一个简单的对策是将不存在的数据也缓存起来(其value为null)。</p>
]]></content>
      <categories>
        <category>架构</category>
        <category>高并发</category>
      </categories>
      <tags>
        <tag>架构</tag>
        <tag>高并发</tag>
      </tags>
  </entry>
  <entry>
    <title>Stream API</title>
    <url>/posts/edc6b1e1/</url>
    <content><![CDATA[<p>在Java 8中，引入了一组全新的API，称为Stream API，用于操作集合。这个功能非常强大，而且相当容易学习和使用。</p>
<h2 id="什么是stream"><a class="markdownIt-Anchor" href="#什么是stream"></a> 什么是Stream？</h2>
<p>Stream可以将一个数据源（如List、Set等）转换成一个流，然后通过一系列的中间操作（如filter、map等）来进行处理，最终获取想要的结果。还可以对结果进行聚合操作（如sum、average等）。</p>
<p>与传统的集合处理方式不同，Stream API提供了延迟计算的特性。它会尽可能地推迟计算，直到我们需要结果为止。这种方法让我们能够更加灵活地处理大规模的数据集合，避免了不必要的内存占用和计算时间。</p>
<h2 id="stream的优点"><a class="markdownIt-Anchor" href="#stream的优点"></a> Stream的优点</h2>
<p>Stream API有以下几个优点：</p>
<ul>
<li>简化代码：Stream API采用链式调用方式，使得代码更加简洁易懂，降低了代码的复杂度。</li>
<li>延迟计算：Stream API支持延迟计算，只有在需要结果时才会执行真正的计算，避免了不必要的内存占用和计算时间。</li>
<li>并行处理：Stream API内部支持并行处理，可以充分利用多核CPU的优势，提高程序的运行效率。</li>
</ul>
<h2 id="stream的基本操作"><a class="markdownIt-Anchor" href="#stream的基本操作"></a> Stream的基本操作</h2>
<p>Stream API主要有三个基本操作：</p>
<ul>
<li>创建流：可以通过集合、数组、文件等来创建一个流。</li>
<li>中间操作：可以对流进行一系列的操作，如过滤、映射、排序等。</li>
<li>终止操作：最终获取想要的结果，如收集到List、Set、Map等中。</li>
</ul>
<h3 id="创建流"><a class="markdownIt-Anchor" href="#创建流"></a> 创建流</h3>
<p>创建一个Stream对象最常见的方法就是使用集合的stream()方法。例如：</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;Integer&gt; list = Arrays.asList(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>);</span><br><span class="line">Stream&lt;Integer&gt; stream = list.stream();</span><br></pre></td></tr></table></figure></div>
<p>还可以使用of()方法来创建流：</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line">Stream&lt;String&gt; stream = Stream.of(<span class="string">&quot;Hello&quot;</span>, <span class="string">&quot;World&quot;</span>);</span><br></pre></td></tr></table></figure></div>
<h3 id="中间操作"><a class="markdownIt-Anchor" href="#中间操作"></a> 中间操作</h3>
<p>Stream API中间操作可以实现链式调用，常用的中间操作如下：</p>
<ul>
<li>filter：根据指定条件过滤出符合条件的元素。</li>
<li>map：将原始类型的元素转换成其他类型。</li>
<li>sorted：对元素进行排序。</li>
<li>distinct：去除重复的元素。</li>
<li>limit：限制返回元素的数量。</li>
<li>skip：跳过前n个元素。</li>
<li>peek：在处理每个元素时执行一些操作。</li>
</ul>
<p>例如，使用filter和map操作对数字列表进行处理：</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;Integer&gt; list = Arrays.asList(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>);</span><br><span class="line">list.stream()</span><br><span class="line">        .filter(i -&gt; i &gt; <span class="number">2</span>)</span><br><span class="line">        .map(i -&gt; i * i)</span><br><span class="line">        .forEach(System.out::println);</span><br></pre></td></tr></table></figure></div>
<h3 id="终止操作"><a class="markdownIt-Anchor" href="#终止操作"></a> 终止操作</h3>
<p>Stream API中的终止操作会执行一些操作，返回一个结果。常用的终止操作如下：</p>
<ul>
<li>count：返回元素的数量。</li>
<li>collect：将流转换成集合、Map等。</li>
<li>reduce：根据指定规则对元素进行计算。</li>
</ul>
<p>例如，使用collect对数字列表进行处理：</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;Integer&gt; list = Arrays.asList(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>);</span><br><span class="line">List&lt;Integer&gt; result = list.stream()</span><br><span class="line">        .filter(i -&gt; i &gt; <span class="number">2</span>)</span><br><span class="line">        .map(i -&gt; i * i)</span><br><span class="line">        .collect(Collectors.toList());</span><br></pre></td></tr></table></figure></div>
<p>这段代码会返回一个新的List对象，其中包含所有大于2的数字的平方值。</p>
<h2 id="stream并行处理"><a class="markdownIt-Anchor" href="#stream并行处理"></a> Stream并行处理</h2>
<p>由于Stream API内部支持并行处理，因此可以通过parallel()方法将串行流转换为并行流，让程序充分利用多核CPU的优势。例如：</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;Integer&gt; list = Arrays.asList(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>);</span><br><span class="line"><span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> list.parallelStream()</span><br><span class="line">    .filter(i -&gt; i &gt; <span class="number">2</span>)</span><br><span class="line">    .mapToInt(i -&gt; i * i)</span><br><span class="line">    .sum();</span><br></pre></td></tr></table></figure></div>
<p>这段代码会对数字列表进行并行处理，返回大于2的数字的平方和。</p>
<h2 id="总结"><a class="markdownIt-Anchor" href="#总结"></a> 总结</h2>
<p>Java 8 Stream API提供了一种简单、易用、高效的方式来操作集合，利用它可以更加轻松地处理大规模数据集。Stream API的优势在于代码简洁易懂、支持延迟计算和并行处理。开发者可以根据自己的需求选择适合自己的中间操作和终止操作，从而达到快速实现功能的目的。</p>
]]></content>
      <categories>
        <category>Java</category>
        <category>StreamAPI</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Java 8</tag>
        <tag>Stream</tag>
      </tags>
  </entry>
  <entry>
    <title>JVM - 运行时数据区</title>
    <url>/posts/243280dc/</url>
    <content><![CDATA[<p>JVM（Java Virtual Machine）是一个虚拟机，它是 Java 语言能够运行的关键所在。JVM 的结构包含了多个不同的组件，其中最重要的就是它的运行时数据区。</p>
<h2 id="jvm-运行时数据区的概述"><a class="markdownIt-Anchor" href="#jvm-运行时数据区的概述"></a> JVM 运行时数据区的概述</h2>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://mydlq-club.oss-cn-beijing.aliyuncs.com/images/my-jvm-constitute-concept.svg"
                      alt="jvm 运行时数据区" 
                ></p>
<div class="note-large notel-green"><div class="notel-title"><p>运行时数据区可以分为以下几个部分</p>
</div><div class="notel-content"><ol>
<li><code>程序计数器：</code>程序计数器是一块较小的内存空间，它保存了当前线程正在执行的字节码指令的地址。当执行方法时，程序计数器会记录下一条将要执行的指令。由于每个线程都需要有自己的程序计数器，因此它是线程私有的。</li>
<li><code>Java 虚拟机栈：</code>每个线程在运行时都会有一个对应的虚拟机栈，它用于存储方法调用的信息，包括局部变量、操作数栈、返回值等。每次方法调用时，JVM 都会创建一个对应的栈帧，并把它压入栈顶。当方法返回时，对应的栈帧会被弹出。由于每个线程都需要有自己的虚拟机栈，因此它也是线程私有的。</li>
<li><code>堆：</code>堆是 JVM 中最大的一块内存空间，它用于存储对象实例。当使用 new 关键字创建一个对象时，JVM 会在堆上分配一块内存来存储该对象的实例。由于所有线程都需要共享堆空间，因此堆是线程共享的。</li>
<li><code>方法区：</code>方法区也被称为永久代（PermGen），它用于存储类信息、常量、静态变量等数据。与堆一样，方法区也是线程共享的。</li>
</ol>
 </div></div>
<h2 id="jvm-运行时数据区的特点"><a class="markdownIt-Anchor" href="#jvm-运行时数据区的特点"></a> JVM 运行时数据区的特点</h2>
<ol>
<li><code>线程私有和线程共享：</code>如上所述，程序计数器和虚拟机栈是线程私有的，而堆和方法区是线程共享的。</li>
<li><code>自动内存管理：</code>JVM 的运行时数据区采用了自动内存管理的方式，即 Java 垃圾回收机制。当对象不再被引用时，JVM 会将其标记为垃圾，并进行回收。</li>
<li><code>动态扩展和收缩：</code>JVM 的运行时数据区可以根据应用程序的需求动态地进行扩展或收缩。当内存不足时，JVM 会自动触发垃圾回收机制，清理掉无用的对象释放内存。当内存达到一定阈值时，JVM 可以通过调整堆大小来扩展内存空间。</li>
</ol>
<h2 id="总结"><a class="markdownIt-Anchor" href="#总结"></a> 总结</h2>
<p>JVM 运行时数据区是 Java 虚拟机中最重要的组成部分之一，它用于存储程序执行时所需的数据。JVM 运行时数据区分为程序计数器、虚拟机栈、堆和方法区四个部分，其中程序计数器和虚拟机栈是线程私有的，堆和方法区是线程共享的。JVM 的运行时数据区采用了自动内存管理的方式，并且可以根据应用程序的需求动态地进行扩展或收缩。</p>
]]></content>
      <categories>
        <category>JVM</category>
        <category>数据区</category>
      </categories>
      <tags>
        <tag>JVM</tag>
        <tag>运行时数据区</tag>
      </tags>
  </entry>
  <entry>
    <title>JVM - 类加载器</title>
    <url>/posts/4f318695/</url>
    <content><![CDATA[<p>JVM（Java Virtual Machine）是Java程序的运行环境，它能够将Java代码转换成可执行的字节码，并在不同平台上运行。在JVM中，类加载器（Class Loader）负责将Java字节码加载到JVM中。</p>
<h2 id="类加载器概述"><a class="markdownIt-Anchor" href="#类加载器概述"></a> 类加载器概述</h2>
<p>类加载器是JVM中的一个重要组件，它主要用于加载Java类和资源文件。在JVM中，类加载器会按照一定的顺序查找需要加载的类，如果类没有被加载，则会通过类加载器将其加载到内存中。</p>
<div class="note-large notel-green"><div class="notel-title"><p>JVM中存在三种类加载器</p>
</div><div class="notel-content"><ol>
<li><strong>启动类加载器（Bootstrap ClassLoader）</strong>：负责加载Java的核心类库，如java.lang包中的类。</li>
<li><strong>扩展类加载器（Extension ClassLoader）</strong>：负责加载Java扩展库，如javax.*包中的类。</li>
<li><strong>应用程序类加载器（Application ClassLoader）</strong>：负责加载应用程序的类，即我们自己编写的类。</li>
<li><strong>自定义类加载器</strong>：开发者可以通过继承ClassLoader类来创建自定义的类加载器，以满足特定的需求。</li>
</ol>
 </div></div>
<h2 id="java-9之前的类加载器"><a class="markdownIt-Anchor" href="#java-9之前的类加载器"></a> Java 9之前的类加载器</h2>
<p>在Java 9之前，JVM中的类加载器存在两个问题：</p>
<ol>
<li><strong>命名空间污染</strong>：由于每个类加载器都有自己的命名空间，因此可能会导致多个类加载器加载同一个类，从而引发命名空间污染问题。</li>
<li><strong>无法卸载类</strong>：由于JVM中的类加载器不支持卸载已经加载的类，因此可能会导致内存泄漏问题。</li>
</ol>
<p>为了解决这些问题，Java 9引入了一种新的类加载器架构。</p>
<h2 id="java-9之后的类加载器"><a class="markdownIt-Anchor" href="#java-9之后的类加载器"></a> Java 9之后的类加载器</h2>
<p>在Java 9中，JVM中的类加载器被重新设计为：</p>
<div class="note-large notel-green"><div class="notel-title"><p>Java9类加载器</p>
</div><div class="notel-content"><ol>
<li><strong>启动类加载器</strong>：负责加载Java的核心类库，如java.lang包中的类。</li>
<li><strong>平台类加载器</strong>：负责加载Java扩展库，如javax.*包中的类。</li>
<li><strong>应用程序类加载器</strong>：负责加载应用程序的类，即我们自己编写的类。</li>
<li><strong>模块类加载器</strong>：负责加载模块中的类。</li>
</ol>
 </div></div>
<p>Java 9中的模块化系统为JVM类加载器带来了一些重大变化，可以解决Java 9之前存在的问题。</p>
<h3 id="模块化类加载器"><a class="markdownIt-Anchor" href="#模块化类加载器"></a> 模块化类加载器</h3>
<p>在Java 9中，每个模块都有自己的类加载器，这些类加载器由模块路径（Module Path）上的模块描述符（Module Descriptor）指定。模块描述符是一个文件，它描述了模块的依赖关系和导出的包。模块加载器会按照模块描述符中指定的依赖关系来加载模块，并将其放置在自己的命名空间中。</p>
<p>模块化类加载器具有以下特点：</p>
<ol>
<li><strong>命名空间隔离</strong>：每个模块都有自己的命名空间，避免了命名空间污染问题。</li>
<li><strong>可卸载性</strong>：由于每个模块都有自己的类加载器，因此可以卸载整个模块，避免了内存泄漏问题。</li>
</ol>
<h3 id="模块路径和类路径"><a class="markdownIt-Anchor" href="#模块路径和类路径"></a> 模块路径和类路径</h3>
<p>在Java 9中，存在两种类路径：</p>
<ol>
<li><strong>模块路径（Module Path）</strong>：它用于指定模块所在的路径，其中包括了每个模块的描述符和类文件。模块路径是Java 9中新增的概念，它是实现模块化的关键。</li>
<li><strong>类路径（Class Path）</strong>：它用于指定非模块化代码所在的路径，其中包括了每个类文件和JAR文件。类路径是Java早期就存在的概念，在Java 9中仍然保留。</li>
</ol>
<h2 id="总结"><a class="markdownIt-Anchor" href="#总结"></a> 总结</h2>
<p>Java 9引入了模块化系统，它将Java代码分解为更小、更简单的组件，并将其打包成模块。每个模块都有自己的依赖关系和导出的API。这种模块化系统使得Java应用程序更加易于开发、维护和部署。</p>
<p>在Java 9中，类加载器被重新设计为启动类加载器、平台类加载器、应用程序类加载器和模块类加载器。其中，模块类加载器具有命名空间隔离和可卸载性的特点，这些特点可以避免命名空间污染和内存泄漏问题。</p>
<p>总之，Java 9的类加载器架构是一个重大的变化，它提供了更好的模块化支持，并且解决了Java 9之前存在的一些问题。</p>
]]></content>
      <categories>
        <category>JVM</category>
        <category>类加载</category>
      </categories>
      <tags>
        <tag>JVM</tag>
        <tag>类加载器</tag>
      </tags>
  </entry>
  <entry>
    <title>JVM - 自定义类加载器</title>
    <url>/posts/f5831f17/</url>
    <content><![CDATA[<p>在Java中，每个类都被分配一个唯一的类加载器来加载它们。默认情况下，Java使用三个类加载器：引导类加载器、扩展类加载器和系统类加载器。这些类加载器可以处理大多数情况，但有时需要自定义类加载器来加载某些特定的类或资源。本文将介绍如何使用自定义类加载器在运行时加载类。</p>
<h2 id="获取class对象"><a class="markdownIt-Anchor" href="#获取class对象"></a> 获取Class对象</h2>
<p>首先，我们需要获取要加载的类的Class对象。这可以通过调用ClassLoader的<code>defineClass</code>方法来完成。以下是一个简单的获取Class对象的示例代码：</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyClassLoader</span> <span class="keyword">extends</span> <span class="title class_">ClassLoader</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> Class&lt;?&gt; getClass(String name, <span class="type">byte</span>[] bytes) &#123;</span><br><span class="line">        <span class="keyword">return</span> defineClass(name, bytes, <span class="number">0</span>, bytes.length);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>上述代码中的<code>getClass</code>方法接收两个参数：要加载的类的名称和类字节码数组。然后，该方法调用<code>defineClass</code>方法来创建并返回与给定字节数组相关联的Class对象。</p>
<h2 id="自定义类加载器"><a class="markdownIt-Anchor" href="#自定义类加载器"></a> 自定义类加载器</h2>
<h3 id="实现自己的类加载器"><a class="markdownIt-Anchor" href="#实现自己的类加载器"></a> 实现自己的类加载器</h3>
<p>接下来，我们需要实现自定义类加载器。以下是一个简单的自定义类加载器的实现：</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyClassLoader</span> <span class="keyword">extends</span> <span class="title class_">ClassLoader</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String path;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MyClassLoader</span><span class="params">(String path)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.path = path;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> Class&lt;?&gt; findClass(String name) <span class="keyword">throws</span> ClassNotFoundException &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">byte</span>[] bytes = loadClassData(name);</span><br><span class="line">            <span class="keyword">return</span> defineClass(name, bytes, <span class="number">0</span>, bytes.length);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ClassNotFoundException</span>(<span class="string">&quot;Class &quot;</span> + name + <span class="string">&quot; not found.&quot;</span>, e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">byte</span>[] loadClassData(String name) <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="type">InputStream</span> <span class="variable">stream</span> <span class="operator">=</span> getClass().getClassLoader().getResourceAsStream(path + name.replace(<span class="string">&quot;.&quot;</span>, <span class="string">&quot;/&quot;</span>) + <span class="string">&quot;.class&quot;</span>);</span><br><span class="line">        <span class="type">ByteArrayOutputStream</span> <span class="variable">buffer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ByteArrayOutputStream</span>();</span><br><span class="line">        <span class="type">int</span> <span class="variable">data</span> <span class="operator">=</span> stream.read();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (data != -<span class="number">1</span>) &#123;</span><br><span class="line">            buffer.write(data);</span><br><span class="line">            data = stream.read();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        stream.close();</span><br><span class="line">        <span class="keyword">return</span> buffer.toByteArray();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>上述代码中的自定义类加载器使用了一个路径来指定要加载的类的位置。在<code>findClass</code>方法中，它首先调用<code>loadClassData</code>方法来从文件系统中读取类字节码。然后，它将该字节数组传递给<code>defineClass</code>方法来创建并返回与给定字节数组相关联的Class对象。</p>
<h3 id="使用自定义的类加载器"><a class="markdownIt-Anchor" href="#使用自定义的类加载器"></a> 使用自定义的类加载器</h3>
<p>以下是使用我们自定义的类加载器的示例代码：</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">MyClassLoader</span> <span class="variable">loader</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyClassLoader</span>(<span class="string">&quot;/path/to/classes/&quot;</span>);</span><br><span class="line">        Class&lt;?&gt; clazz = loader.loadClass(<span class="string">&quot;com.example.MyClass&quot;</span>);</span><br><span class="line">        <span class="type">Object</span> <span class="variable">object</span> <span class="operator">=</span> clazz.getDeclaredConstructor().newInstance();</span><br><span class="line">        <span class="type">Method</span> <span class="variable">method</span> <span class="operator">=</span> clazz.getMethod(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">        method.invoke(object);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">hello</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Hello, world!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>上述代码中的<code>Main</code>类演示了如何使用自定义类加载器在运行时加载类。首先，它创建一个MyClassLoader对象，并使用该对象来加载名为<code>com.example.MyClass</code>的类。然后，它使用反射机制调用<code>hello</code>方法，从而在控制台上输出一条消息。</p>
<h2 id="总结"><a class="markdownIt-Anchor" href="#总结"></a> 总结</h2>
<p>通过自定义类加载器，我们可以在运行时加载特定的类或资源。在这个过程中，自定义类加载器会从指定的位置加载字节码，并使用<code>defineClass</code>方法创建Class对象。这种能力可以被用于实现动态加载、模块化和插件系统等高级功能。但是，需要注意的是，自定义类加载器可能会对Java程序的安全性和稳定性产生影响，因此需要谨慎使用。</p>
]]></content>
      <categories>
        <category>JVM</category>
        <category>类加载</category>
      </categories>
      <tags>
        <tag>JVM</tag>
        <tag>类加载器</tag>
      </tags>
  </entry>
  <entry>
    <title>JVM - 类加载过程</title>
    <url>/posts/82c940cf/</url>
    <content><![CDATA[<p>在Java中，类的加载是一个非常重要的过程，其负责将类文件从磁盘读取到内存中，并对其进行解析和初始化。JVM类加载过程一共分为以下<span style="border-bottom:2px solid green">三个步骤：加载、连接、初始化。</span></p>
<pre class="mermaid">graph LR;
    User[用户] --> Application(应用)
    
    subgraph JVM类加载流程 
    Application -- 执行Java代码 --> ClassLoader(类加载器) 
    
    ClassLoader -- 加载类 --> BootstrapClassLoader(启动类加载器) 
    ClassLoader -- 加载类 --> ExtensionClassLoader(扩展类加载器) 
    ClassLoader -- 加载类 --> AppClassLoader(应用类加载器) 
    
    subgraph 类初始化 
    AppClassLoader -- 类加载完成 --> Linking(连接阶段) 
    Linking -- 初始化类变量 --> Init(初始化阶段) 
    
    Init -- 执行static块 --> Done(初始化完成) 
    end
    
    Done -- 创建对象 --> Object(对象) 
    Object -- 调用方法 --> Application
    end</pre>
<h2 id="加载"><a class="markdownIt-Anchor" href="#加载"></a> 加载</h2>
<p><span style="border-bottom:2px solid green"><code>加载</code>是指将类文件从文件系统或者网络中读取到内存当中</span>（<a href="/posts/4f318695/"><code>类加载器</code></a>的功劳），并为之创建一个Class对象。在JVM中，Class对象是用来描述类的，其中包含了类的成员变量、方法等信息。当我们使用new关键字创建对象时，JVM会根据Class对象来实例化该类的对象并返回它。</p>
<p>在类加载时，JVM采用了<span style="border-bottom:2px solid green"><code>双亲委派模型</code>，即将类的加载任务委派给父类加载器，如果父类加载器无法完成加载任务，才由子类加载器去尝试加载。</span>这种机制可以保证类的唯一性，避免了类的重复加载。</p>
<h2 id="连接"><a class="markdownIt-Anchor" href="#连接"></a> 连接</h2>
<p><span style="border-bottom:2px solid green"><code>连接</code>是指将已经读取到内存中的类文件进行校验、准备和解析的过程。</span></p>
<ol>
<li><strong>校验（Verification）</strong>：对类文件进行格式的校验，以确保它们符合JVM规范。如果校验失败，则会抛出ClassFormatError异常。</li>
<li><strong>准备（Preparation）</strong>：为类变量分配内存，并设置默认值。在这个阶段，类变量并没有被初始化，只是分配了内存空间。</li>
<li><strong>解析（Resolution）</strong>：将符号引用转化为直接引用的过程。在Java中，使用类名来访问一个类时，实际上是使用了符号引用。而在解析阶段，JVM会将其转化为直接引用，即具体的内存地址或偏移量。</li>
</ol>
<h2 id="初始化"><a class="markdownIt-Anchor" href="#初始化"></a> 初始化</h2>
<p><span style="border-bottom:2px solid green"><code>初始化</code>是指执行类构造器方法()的过程。该方法由编译器生成，主要负责将类变量赋初值，以及执行静态代码块等操作。</span></p>
<p>在执行()方法前，JVM会先执行父类的()方法，保证父类的静态成员变量和静态代码块也得到正确的初始化。</p>
<p>在实例化对象时，JVM会首先调用父类的构造器方法，然后再调用子类的构造器方法。在执行构造器方法前，JVM会先执行实例变量初始化和非静态代码块。</p>
<h2 id="双亲委派"><a class="markdownIt-Anchor" href="#双亲委派"></a> 双亲委派</h2>
<p>双亲委派模型是Java类加载机制的核心。该模型是指当一个类加载器收到类加载请求时，它首先将这个请求转发给它的父类加载器，如果父类加载器无法完成类加载任务，才由自己去尝试加载。如下图：</p>
<pre class="mermaid">graph LR;
    User[用户] --> Application(应用)
    
    subgraph JVM类加载双亲委派流程 
    Application -- 加载类 --> AppClassLoader(应用类加载器) 
    
    AppClassLoader -- 向上委派 --> ExtensionClassLoader(扩展类加载器) 
    
    ExtensionClassLoader -- 向上委派 --> BootstrapClassLoader(启动类加载器) 

    BootstrapClassLoader -- 尝试加载类 --> Class(类) 
    
    Class -- 返回类实例 --> BootstrapClassLoader 
    
    BootstrapClassLoader -- 返回类实例 --> ExtensionClassLoader
    
    ExtensionClassLoader -- 返回类实例 --> AppClassLoader
    
    AppClassLoader -- 类加载完成 --> Linking(连接阶段) 
    
    Linking -- 初始化类变量 --> Done(初始化阶段) 
    
    Done -- 创建对象 --> Object(对象) 
    Object -- 调用方法 --> Application
    end</pre>
<p>这种机制可以保证类的唯一性，避免了类的重复加载。例如，我们在JVM中使用String类时，它的加载过程如下所示：</p>
<ol>
<li>如果应用程序类加载器在它的类路径中找到了String类，那么它直接返回该Class对象。</li>
<li>如果应用程序类加载器没有找到String类，那么它将请求转发给扩展类加载器。</li>
<li>如果扩展类加载器在它的类路径中找到了String类，那么它直接返回该Class对象。</li>
<li>如果扩展类加载器没有找到String类，那么它将请求转发给启动类加载器。</li>
<li>启动类加载器在JVM核心类库中找到了String类，并将其返回给扩展类加载器。</li>
<li>扩展类加载器将String类返回给应用程序类加载器。</li>
<li>应用程序类加载器将String类返回给JVM。</li>
</ol>
<p>由于双亲委派模型的存在，当我们使用自定义类加载器时，可以避免类的重复加载。例如，我们如果想在同一个JVM中加载两个版本的com.example.MyClass类，则可以分别使用两个不同的类加载器来加载这两个版本的类，这样就不会出现类的冲突和覆盖问题。</p>
<h2 id="总结"><a class="markdownIt-Anchor" href="#总结"></a> 总结</h2>
<p>JVM的类加载过程是一个非常重要的过程，它负责将类文件从磁盘读取到内存中，并对其进行解析和初始化。在加载时，JVM采用了双亲委派模型，保证了类的唯一性和避免了类的重复加载。在实际开发中，我们可以通过自定义类加载器来实现特定的需求，例如在同一个JVM中加载多个版本的类。</p>
]]></content>
      <categories>
        <category>JVM</category>
        <category>类加载</category>
      </categories>
      <tags>
        <tag>JVM</tag>
        <tag>类加载器</tag>
      </tags>
  </entry>
  <entry>
    <title>Java 对象是否存活</title>
    <url>/posts/6a10d920/</url>
    <content><![CDATA[<p>在JVM中，垃圾回收器会对内存中的对象进行生死判定，将无用的对象回收以释放内存空间。本篇博客将介绍JVM对象生死判定的过程。</p>
<h2 id="算法"><a class="markdownIt-Anchor" href="#算法"></a> 算法</h2>
<div class="note note-green"><p>用来判定对象存亡的常用算法有两种：引用计数法、可达性分析算法。</p>
</div>
<h3 id="引用计数法"><a class="markdownIt-Anchor" href="#引用计数法"></a> 引用计数法</h3>
<p>引用计数法是最简单也是最基础的垃圾回收算法之一。该算法通过跟踪每个对象被引用的次数来判断对象是否已经成为垃圾。</p>
<p>当一个新对象被创建时，其引用计数为1。当其他对象引用该对象时，其对应的引用计数加1。当某个对象的引用计数变为0时，说明该对象已经成为垃圾，可以被回收。</p>
<p>然而，引用计数法有一个明显的问题：<span style="border-bottom:2px dashed red;">循环引用。如果两个或多个对象之间互相引用，它们的引用计数永远不会变成0，导致垃圾回收器无法将它们回收。</span>因此，引用计数法并不适用于实际的垃圾回收。</p>
<h3 id="可达性分析算法"><a class="markdownIt-Anchor" href="#可达性分析算法"></a> 可达性分析算法</h3>
<div class="note note-green"><p>JVM 使用此算法</p>
</div>
<p>可达性分析算法是目前主流的垃圾回收算法之一。它基于“GC Roots”的概念来判断对象是否可达。</p>
<p>在JVM中，GC Roots包括以下几类：</p>
<ul>
<li>虚拟机栈（栈帧中的本地变量表）中引用的对象。</li>
<li>方法区中静态属性引用的对象。</li>
<li>方法区中常量引用的对象。</li>
<li>本地方法栈中JNI（Java Native Interface）引用的对象。</li>
</ul>
<p>可达性分析算法从GC Roots开始遍历内存中的所有对象，将可以到达的对象标记为“存活”，而未被标记的对象则被视为垃圾。</p>
<p>可达性分析算法可以有效地处理循环引用问题，并且能够精确地识别出无用对象。</p>
<h2 id="对象生死判定流程"><a class="markdownIt-Anchor" href="#对象生死判定流程"></a> 对象生死判定流程</h2>
<p>JVM中的垃圾回收器会周期性地对内存中的对象进行生死判定，以便将无用对象回收。其具体流程如下：</p>
<ol>
<li>根据GC Roots开始遍历内存中的所有对象。</li>
<li>将所有可以到达的对象标记为“存活”。</li>
<li>将未被标记的对象视为垃圾，进行回收。</li>
</ol>
<p>需要注意的是，在进行垃圾回收时，可能会造成一些短暂的系统停顿。这是因为垃圾回收器需要暂停正在执行的程序，并锁定整个堆空间，以便安全地对内存中的对象进行回收。为了减少这种停顿时间，JVM引入了一些优化措施，如并发标记和整理、增量式收集等。</p>
<h2 id="总结"><a class="markdownIt-Anchor" href="#总结"></a> 总结</h2>
<p>JVM对象生死判定是垃圾回收机制的重要组成部分。可达性分析算法是目前主流的垃圾回收算法之一，它可以精确地识别出无用对象，并解决循环引用问题。程序员需要了解JVM对象生死判定的过程，以便更好地管理内存资源，提高程序性能。</p>
]]></content>
      <categories>
        <category>JVM</category>
        <category>Java 对象</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>JVM</tag>
        <tag>Java 对象</tag>
      </tags>
  </entry>
  <entry>
    <title>Java 对象的生命周期</title>
    <url>/posts/dcb2c325/</url>
    <content><![CDATA[<p>Java虚拟机（JVM）是一种能够在不同平台上运行Java程序的虚拟机。在JVM中，每个对象都有其自己的生命周期。本篇博客将介绍JVM对象的生命周期。</p>
<h2 id="生命周期阶段"><a class="markdownIt-Anchor" href="#生命周期阶段"></a> 生命周期阶段</h2>
<div class="note note-green"><p>Java 对象的生命周期的几个阶段，分别为：对象的创建、使用、回收、销毁，下边逐个来进行介绍；</p>
</div>
<h3 id="对象的创建"><a class="markdownIt-Anchor" href="#对象的创建"></a> 对象的创建</h3>
<p>当使用<code>new</code>关键字创建一个对象时，JVM会先检查类是否已经被加载和链接过。如果没有加载，则先进行类的加载和连接操作。然后为该对象分配内存空间，并对分配到的内存空间进行清零赋值，即初始化对象的所有实例变量为默认值。</p>
<p>接着，JVM会调用对象的构造函数（Constructor），初始化对象的实例变量。如果该类没有显式地定义构造函数，则JVM会提供一个默认的无参构造函数。</p>
<p>最后，JVM会把对象的引用返回给程序员，以便程序员可以通过该引用来操作该对象。</p>
<h3 id="对象的使用"><a class="markdownIt-Anchor" href="#对象的使用"></a> 对象的使用</h3>
<p>在对象创建后，程序员可以通过对象的引用对它进行操作。对象在内存中的位置由对象的引用来确定。当一个对象被使用时，它可能会被传递给其他方法或者被保存在某些数据结构中。</p>
<h3 id="对象的回收"><a class="markdownIt-Anchor" href="#对象的回收"></a> 对象的回收</h3>
<p>当一个对象不再被程序员所引用时，该对象就成了垃圾（Garbage）。JVM需要将这些无用的对象从内存中清除，以便后面的内存分配可以使用这些空间。</p>
<p>JVM中的垃圾回收（Garbage Collection）机制负责回收这些无用对象。当JVM检测到一个对象已经成为垃圾时，它就会自动地将该对象所占用的内存空间释放出来，以便程序后续的内存分配可以使用这些空间。</p>
<p>在JVM中，垃圾回收是由垃圾回收器（Garbage Collector）来完成的。不同的垃圾回收器采用不同的算法来实现垃圾回收。常见的垃圾回收算法包括标记-清除算法、复制算法、标记-整理算法和分代收集算法等。</p>
<h3 id="对象的销毁"><a class="markdownIt-Anchor" href="#对象的销毁"></a> 对象的销毁</h3>
<p>当一个对象被回收后，JVM并不会立即销毁它。相反，JVM会等待垃圾回收器对内存进行整理后，再对垃圾对象进行销毁。销毁一个对象的最终步骤是调用其<code>finalize()</code>方法。该方法是Object类中定义的一个方法，在GC进行回收之前会先调用该方法。</p>
<p>在Java 9之后，<code>finalize()</code>方法已经被废弃，取而代之的是使用Cleaner API进行资源管理。</p>
<h2 id="总结"><a class="markdownIt-Anchor" href="#总结"></a> 总结</h2>
<p>JVM对象的生命周期包括对象的创建、使用、回收和销毁等阶段。理解JVM对象的生命周期对于Java程序开发人员来说是非常重要的，可以帮助他们更好地管理内存资源，提高程序性能。</p>
]]></content>
      <categories>
        <category>JVM</category>
        <category>Java 对象</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>JVM</tag>
        <tag>Java 对象</tag>
      </tags>
  </entry>
  <entry>
    <title>JVM 垃圾回收算法</title>
    <url>/posts/94863c7b/</url>
    <content><![CDATA[<p>与其他语言相比，Java有着自动内存管理的优势，即由JVM自动进行内存分配和垃圾回收处理。本篇博客将介绍JVM中的垃圾回收算法。</p>
<h2 id="垃圾回收的基本概念"><a class="markdownIt-Anchor" href="#垃圾回收的基本概念"></a> 垃圾回收的基本概念</h2>
<p>垃圾回收的目的是释放无用的内存空间以供后续的内存分配使用。JVM中使用垃圾回收器（Garbage Collector）来自动实现这个过程。垃圾回收器会在发现内存中存在无用的对象时，将其所占用的内存空间回收。</p>
<p>为了实现垃圾回收，需要定义什么是“无用对象”。在JVM中，一个对象被判定为无用对象，当且仅当它满足下列条件：</p>
<ul>
<li>该对象没有被引用</li>
<li>该对象的所有引用均已断开</li>
</ul>
<p>垃圾回收算法的目标是尽可能快地识别和回收无用对象，同时保持系统性能的稳定。</p>
<h2 id="常见垃圾回收算法"><a class="markdownIt-Anchor" href="#常见垃圾回收算法"></a> 常见垃圾回收算法</h2>
<h3 id="标记-清除算法"><a class="markdownIt-Anchor" href="#标记-清除算法"></a> 标记-清除算法</h3>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://luolanmeet.github.io/jvm-note/content/part2/%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8/%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E7%AE%97%E6%B3%95/img/%E6%A0%87%E8%AE%B0-%E6%B8%85%E9%99%A4%E7%AE%97%E6%B3%95.png"
                      alt="标记清楚" 
                ></p>
<p><code>标记-清除算法</code>是最基本的垃圾回收算法。它分为两个阶段：标记和清除。</p>
<p>在标记阶段，垃圾回收器遍历堆中的所有对象，并标记出所有被引用的对象。在清除阶段，垃圾回收器将未被标记的对象所占用的内存空间全部回收。</p>
<p>这个算法的缺点是会产生碎片，因为回收后的内存空间是不连续的。如果始终使用标记-清除算法，那么随着时间的推移，内存空间中的空洞（即碎片）将越来越多，导致内存分配效率降低。</p>
<h3 id="复制算法"><a class="markdownIt-Anchor" href="#复制算法"></a> 复制算法</h3>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://luolanmeet.github.io/jvm-note/content/part2/%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8/%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E7%AE%97%E6%B3%95/img/%E6%A0%87%E8%AE%B0-%E5%A4%8D%E5%88%B6%E7%AE%97%E6%B3%95.png"
                      alt="复制算法" 
                ></p>
<p><code>复制算法</code>是一种高效的垃圾回收算法。它将堆空间划分为大小相等的两块，每次只使用其中一块。当这一块内存空间用完时，垃圾回收器将已经标记了的存活对象复制到另一块未使用的空间中，然后清除已使用的那一块空间并交换它们的角色。</p>
<p>复制算法的缺点是需要消耗一半的空间。同时，如果存活对象很多，每次都要进行复制操作，也会带来不小的性能开销。</p>
<h3 id="标记-整理算法"><a class="markdownIt-Anchor" href="#标记-整理算法"></a> 标记-整理算法</h3>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://luolanmeet.github.io/jvm-note/content/part2/%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8/%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E7%AE%97%E6%B3%95/img/%E6%A0%87%E8%AE%B0-%E6%95%B4%E7%90%86%E7%AE%97%E6%B3%95.png"
                      alt="整理算法" 
                ></p>
<p><code>标记-整理算法</code>是对标记-清除算法的改进。它同样分为两个阶段：标记和整理。</p>
<p>在标记阶段，垃圾回收器遍历堆中的所有对象，并标记出所有被引用的对象。在整理阶段，垃圾回收器将所有存活对象移到堆的一端，然后清除堆的另外一端上的所有无用对象。</p>
<p>标记-整理算法通过整理过程来解决标记-清除算法产生的碎片问题，使得内存空间变得连续起来。</p>
<h3 id="三色标记"><a class="markdownIt-Anchor" href="#三色标记"></a> 三色标记</h3>
<p><code>三色标记</code>是一种用于 Java 虚拟机（JVM）垃圾回收算法的技术，配合<a href="/posts/6a10d920">可达性分析算法</a>实现垃圾的高效、准确的收集。</p>
<p>在三色标记中，JVM将内存对象分为三个不同的颜色：白色、灰色和黑色。</p>
<ul>
<li><code>白色</code>：表示对象尚未被扫描和标记。</li>
<li><code>灰色</code>：表示对象已经被扫描，但是它引用的其他对象尚未被扫描和标记。</li>
<li><code>黑色</code>：表示对象已经被扫描和标记，并且它引用的其他对象也已经被扫描和标记。</li>
</ul>
<p>JVM 使用三色标记来跟踪哪些对象可以被安全地回收。当 JVM 进行垃圾回收时，它会从根对象开始遍历所有对象，并将它们标记为灰色或黑色。然后，JVM 会清除所有白色对象，因为这些对象没有任何引用。</p>
<p>在三色标记算法中，灰色的对象表示悬挂的对象，即其引用的对象尚未被处理。如果某个对象的所有引用都已经被扫描和标记，那么它就会被标记为黑色。</p>
<p>通过使用三色标记算法，JVM 可以更快地确定哪些对象可以被安全地回收，从而提高了应用程序的性能和可靠性。</p>
<h3 id="分代收集算法"><a class="markdownIt-Anchor" href="#分代收集算法"></a> 分代收集算法</h3>
<p><code>分代收集算法</code>是目前主流的垃圾回收算法。它根据对象的存活周期把堆区域分为新生代和老年代两个区域。新生代中的对象通常存活时间较短，而老年代中的对象则存活时间较长。不同区域采用不同的垃圾回收算法。</p>
<p>新生代通常使用复制算法。它把新生代分为Eden区和两个Survivor区，每次只使用Eden区和其中一个Survivor区，将已经标记了的存活对象复制到另一块未使用的Survivor区中，然后清除Eden区和已使用的Survivor区中的无用对象。</p>
<p>老年代通常使用标记-整理算法。因为老年代中的对象存活时间较长，所以会产生大量的内存碎片。标记-整理算法通过整理过程来解决这个问题。</p>
<h2 id="总结"><a class="markdownIt-Anchor" href="#总结"></a> 总结</h2>
<p>JVM垃圾回收算法包括标记-清除算法、复制算法、标记-整理算法和分代收集算法等。不同的垃圾回收算法适用于不同的场景，需要根据具体情况进行选择。对于Java程序开发人员来说，理解JVM垃圾回收算法对于优化程序性能至关重要。</p>
]]></content>
      <categories>
        <category>JVM</category>
        <category>GC</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>JVM</tag>
        <tag>GC</tag>
      </tags>
  </entry>
  <entry>
    <title>CMS 垃圾回收器</title>
    <url>/posts/d20aa128/</url>
    <content><![CDATA[<p>CMS 的全称为 Concurrent Mark Sweep（并发标记清除），是 <code>JDK1.5</code> 版本之后内置的一种垃圾回收器。与其他垃圾回收器不同，CMS 的目标是实现最短的GC停顿时间，即使在大型堆内存的情况下也能保证应用的响应速度和性能。</p>
<div class="note-large notel-yellow"><div class="notel-title"><p>注意</p>
</div><div class="notel-content"><p>随着JDK版本的不断升级，从JDK 9开始，CMS收集器已经被标记为“即将被弃用”（Deprecated），而在JDK 14中彻底被删除。原因是CMS收集器存在以下问题：</p>
<ol>
<li>空间碎片：由于CMS收集器只能对老年代进行回收，所以会产生大量的空间碎片。这会导致后续的内存分配操作变得困难，甚至可能出现 OutOfMemoryError 错误。</li>
<li>CPU占用：由于CMS收集器需要与应用程序线程并发工作，所以会占用一些CPU资源，影响应用程序的性能。</li>
<li>内存泄漏：如果CMS收集器无法回收所有的垃圾，就会导致内存泄漏。</li>
</ol>
<p>因此，<a href="/posts/bc8ac7bc/"><code>G1收集器</code></a>逐渐成为了JDK的默认垃圾收集器。G1收集器采用分代回收的思想，可以更好地处理大量对象的分配和释放，避免了CMS收集器的一些缺点。</p>
 </div></div>
<h2 id="区域划分"><a class="markdownIt-Anchor" href="#区域划分"></a> 区域划分</h2>
<p>在进行垃圾回收时，它将<span style="border-bottom:2px solid yellow">堆内存</span>划分为多个区域，在不影响应用程序执行的情况下进行垃圾回收。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="cmsmemory.webp"
                      alt="cms memory" 
                ></p>
<div class="note-large notel-green"><div class="notel-title"><p>堆内存的区域划分</p>
</div><div class="notel-content"><ul>
<li><code>新生代</code>：包括Eden区和两个Survivor区（From Space和To Space）。当新对象被创建时，它们会首先被分配到Eden区。当Eden区满时，会触发Minor GC。在Minor GC过程中，Eden区和Survivor区中的存活对象会被复制到另一个Survivor区中，并经过一系列复制和清理操作后，存活的对象会被复制到另一个Survivor区中。每次Minor GC后，From Space和To Space会互换角色。（Eden 区 和 两个 Survivor区的大小比例：8:1:1，可以使用 <code>-XX:SurvivorRatio</code> 惊醒调整，默认值为 8）</li>
<li><code>老年代</code>：存放长时间存活的对象。当Old区满时，会触发Full GC。Full GC会暂停整个JVM，对全局进行垃圾回收。由于Full GC需要暂停整个JVM，因此CMS垃圾回收器总是尽可能地减少Full GC的发生次数。</li>
</ul>
 </div></div>
<h2 id="工作原理"><a class="markdownIt-Anchor" href="#工作原理"></a> 工作原理</h2>
<p>CMS垃圾回收器采用了“标记-清除”算法，其主要过程如下：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://icefrozen.github.io/article/java-cms-gc/1552636737931java-cms-gc_.png"
                      alt="cms" 
                ></p>
<ol>
<li><code>初始标记</code>：暂停所有应用线程，必须短暂暂停以达到<a href="/posts/5a9ba959/">安全点</a>；标记出所有根对象以及直接与其相关的对象；</li>
<li><code>并发标记</code>：恢复所有应用线程，同时并发地遍历老年代中的所有对象进行标记；</li>
<li><code>重新标记</code>：暂停所有应用线程，必须短暂暂停以达到<a href="/posts/5a9ba959/">安全点</a>；处理并发标记期间因用户程序继续执行而被遗漏的新生代对象；</li>
<li><code>并发清除</code>：同时清除标记完成的所有不再使用的对象。</li>
</ol>
<h2 id="优缺点"><a class="markdownIt-Anchor" href="#优缺点"></a> 优缺点</h2>
<div class="note-large notel-green"><div class="notel-title"><p>优点</p>
</div><div class="notel-content"><ol>
<li>垃圾回收期间最大程度上减少了应用程序的停顿时间；</li>
<li>适用于大型堆内存的JVM，CMS在回收大对象时非常高效；</li>
<li>消耗的CPU资源较少；</li>
</ol>
 </div></div>
<div class="note-large notel-red"><div class="notel-title"><p>缺点</p>
</div><div class="notel-content"><ol>
<li>运作过程中需要占用一定的内存空间以记录清除信息；</li>
<li>在进行并发标记和清除的过程中，由于用户线程和垃圾回收线程交错执行，所以会对CPU产生一定压力；</li>
<li>整个运作过程相对复杂，实现难度较大。</li>
</ol>
 </div></div>
<h2 id="使用建议"><a class="markdownIt-Anchor" href="#使用建议"></a> 使用建议</h2>
<ol>
<li>应用程序必须运行在64位的JVM上；</li>
<li>不推荐将老年代的内存分配过小，否则可能频繁触发Full GC；</li>
<li>避免在快照时间段内生成大量的对象，否则可能导致CMS无法顺利完成垃圾回收操作。</li>
</ol>
]]></content>
      <categories>
        <category>JVM</category>
        <category>GC</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>JVM</tag>
        <tag>GC</tag>
      </tags>
  </entry>
  <entry>
    <title>Java 对象的组成</title>
    <url>/posts/581a85f5/</url>
    <content><![CDATA[<p>在JVM中，每个对象都由三个部分组成：对象头、实例变量和对齐填充。</p>
<h2 id="组成部分"><a class="markdownIt-Anchor" href="#组成部分"></a> 组成部分</h2>
<div class="note note-green"><p>在JVM中，每个对象都由三个部分组成：对象头、实例变量和对齐填充。</p>
</div>
<h3 id="对象头"><a class="markdownIt-Anchor" href="#对象头"></a> 对象头</h3>
<p>对象头是存储在每个Java对象之前的一段内存空间，用于存储对象的元数据信息，包括以下内容：</p>
<ul>
<li>Mark Word：标记字，用于存储锁相关信息、GC状态信息等。</li>
<li>Class pointer：指向该对象所属类的指针，用于确定对象类型。</li>
<li>数组长度：如果该对象是数组，则用于存储数组长度。</li>
</ul>
<p>对象头的大小取决于平台的位数以及压缩指针技术的使用情况等因素。</p>
<h3 id="实例变量"><a class="markdownIt-Anchor" href="#实例变量"></a> 实例变量</h3>
<p>实例变量是对象的成员变量，定义了该对象的属性。它们被存储在紧随对象头之后的内存空间中。实例变量的大小和类型取决于对象所属类中定义的成员变量。</p>
<h3 id="对齐填充"><a class="markdownIt-Anchor" href="#对齐填充"></a> 对齐填充</h3>
<p>为了保证对象的大小是8字节的倍数，JVM会在实例变量之后添加一些额外的字节，即对齐填充。这些额外的字节没有任何实际作用，只是为了满足内存对齐的要求。</p>
<p>对齐填充的大小取决于对象头和实例变量所占用的内存空间。</p>
<h3 id="实际大小"><a class="markdownIt-Anchor" href="#实际大小"></a> 实际大小</h3>
<p>总体来说，一个Java对象的实际大小有以下三个部分组成：</p>
<ol>
<li>对象头的大小：在不同的JVM实现中，对象头的大小可能会有所不同。</li>
<li>实例变量的大小：该对象中定义的所有实例变量的大小。</li>
<li>对齐填充的大小：为了满足内存对齐的要求而添加的额外字节。</li>
</ol>
<p>具体的实际大小取决于平台的位数、操作系统的类型以及JVM实现的不同等因素。</p>
<h2 id="总结"><a class="markdownIt-Anchor" href="#总结"></a> 总结</h2>
<p>JVM对象由对象头、实例变量和对齐填充三个部分组成。对象头用于存储对象的元数据信息；实例变量定义了该对象的属性；对齐填充用于保证对象大小是8字节的倍数。理解JVM对象的组成对于Java程序开发人员来说是非常重要的，可以帮助他们更好地管理内存资源，提高程序性能。</p>
]]></content>
      <categories>
        <category>JVM</category>
        <category>Java 对象</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>JVM</tag>
        <tag>Java 对象</tag>
      </tags>
  </entry>
  <entry>
    <title>G1 垃圾收集器</title>
    <url>/posts/bc8ac7bc/</url>
    <content><![CDATA[<p>G1 垃圾收集器是一种新型的垃圾收集器，专门针对大堆内存的应用程序进行优化，可以更好地处理大量对象的分配和释放，减少停顿时间，并帮助应用程序提高性能。G1 收集器是在 JDK 7 update 4 版本中首次推出的，在 Java 9 中正式成为默认的垃圾收集器。通过启动参数&quot;<code>-XX:+UseG1GC</code>&quot;来使用 G1 垃圾收集器。</p>
<h2 id="区域划分"><a class="markdownIt-Anchor" href="#区域划分"></a> 区域划分</h2>
<p><code>G1（Garbage-First）</code>垃圾收集器，将 Java 堆内存划分为多个大小相等的区域（Region），并对这些区域进行垃圾回收。每个区域的大小通常是1MB到32MB之间，并且可以通过JVM参数 <code>-XX:G1HeapRegionSize</code> 进行调整，默认为 1M。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy82MjcxMzc2LWNkMDIwOWM0YTNiZWRiNzUucG5n?x-oss-process=image/format,png"
                      alt="" 
                ></p>
<div class="note-large notel-green"><div class="notel-title"><p>堆内存的区域划分</p>
</div><div class="notel-content"><ul>
<li>Eden 区：当新对象被创建时，它们会首先被分配到Eden区。Eden区是G1垃圾收集器的年轻代区域。默认情况下，Eden区的大小占整个Java堆内存的5%到10%。</li>
<li>存活区（Survivor区）：与 CMS 垃圾收集器类似，G1 垃圾收集器还使用了两个 Survivor 区，并且 Survivor 区的大小与 Eden 区的大小相等。当执行年轻代垃圾回收时，存活的对象会被移动到 Survivor 区。默认情况下，Survivo r区的大小占整个 Java 堆内存的5%到10%。</li>
<li>Old 区：存放长时间存活的对象。G1 垃圾收集器采用了“增量式整理”算法来避免 Full GC 带来的停顿时间过长。默认情况下，Old 区的大小占整个 Java 堆内存的60%到80%。</li>
<li>Humongous 区：专门用来存储大对象，如果一个对象的大小超过了一个区域的 50%，那么这个对象将直接被分配到 Humongous 区，而不是被分配到 Eden区或 Old 区。对于 Humongous 对象，G1 垃圾收集器将使用“复制”算法进行垃圾回收。</li>
</ul>
 </div></div>
<h2 id="工作原理"><a class="markdownIt-Anchor" href="#工作原理"></a> 工作原理</h2>
<p>G1 垃圾收集器采用“复制和标记整理”两种算法来回收内存，主要工作流程：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://imgconvert.csdnimg.cn/aHR0cDovL3BpY3R1cmUudGp0dWxvbmcudG9wL0NNUyVFNiU5NCVCNiVFOSU5QiU4NiVFNSU5OSVBOC5qcGc?x-oss-process=image/format,png"
                      alt="G1" 
                ></p>
<ol>
<li>初始标记阶段：在此阶段中，G1收集器会标记所有被根对象直接关联的对象，并记录它们的位置和状态。</li>
<li>并发标记阶段：在此阶段中，G1收集器会并发地处理堆中的对象，找出所有与标记对象直接或间接关联的对象，并标记它们。</li>
<li>最终标记阶段：在此阶段中，G1收集器会重新暂停应用程序，完成对并发标记过程中可能遗漏的标记的补充，以确保所有存活的对象都已被标记。</li>
<li>筛选阶段：在此阶段中，G1收集器会基于可回收的内存大小和回收时间预算来确定哪些区域需要被回收，并将这些区域加入回收集。</li>
<li>清理阶段：在此阶段中，G1收集器会清理回收集中的区域，并将其中的内存返回给Java虚拟机，使其可以再次使用。</li>
</ol>
<p>总的来说，G1垃圾收集器通过将堆内存分成多个大小相等的区域，将大型堆的垃圾收集任务分成多个小的垃圾收集任务，从而避免了全局暂停，具有更高的可预测性和可控性。同时，G1垃圾收集器也可以根据应用程序产生的垃圾量自适应调整阶段时间，提高了垃圾回收的效率。</p>
<h2 id="优缺点"><a class="markdownIt-Anchor" href="#优缺点"></a> 优缺点</h2>
<div class="note-large notel-green"><div class="notel-title"><p>优点</p>
</div><div class="notel-content"><ol>
<li>分代收集：G1垃圾收集器将堆内存分为多个大小相等的区域，并根据它们的特征来进行垃圾回收。这样可以避免全局暂停，提高了响应时间和吞吐量。（<span style="border-bottom: 2px solid green">G1 收集器也引入了&quot;<code>混合模式</code>&quot;的回收策略，将Young GC和部分Full GC结合起来，从而达到更好的性能。</span>）</li>
<li>并发收集：在并发标记阶段，G1垃圾收集器可以与应用程序并发执行。这意味着应用程序可以在垃圾回收期间继续运行，减少了暂停时间，提高了系统的可用性。</li>
<li>可预测性：G1垃圾收集器会自动调整垃圾回收策略，以满足应用程序需要的响应时间和吞吐量。这使得应用程序的性能更加稳定和可预测。</li>
<li>空间利用率：G1垃圾收集器可以更好地利用堆空间，减少了碎片化问题，从而可以更有效地使用可用内存。</li>
</ol>
 </div></div>
<div class="note-large notel-red"><div class="notel-title"><p>缺点</p>
</div><div class="notel-content"><ol>
<li>初始标记和最终标记仍需STW: 尽管 G1 收集器的大部分工作都是并发的，但在 JVM 执行初始标记和最终标记时仍需要暂停应用程序。这一点可能会导致应用程序在某些情况下出现停顿。</li>
<li>物理内存占用：G1收集器需要维护大量的数据结构来跟踪堆内存的使用情况，这会对物理内存造成一定的负担。</li>
<li>相比CMS，在GC过程中会占用更多的CPU时间。</li>
<li>长时间运行的应用可能会出现某些性能问题，因为G1垃圾收集器不能保证我们的操作不会访问已经被回收的对象（也就是说，它不能保证与CMS相同的延迟）。</li>
</ol>
 </div></div>
<h2 id="使用建议"><a class="markdownIt-Anchor" href="#使用建议"></a> 使用建议</h2>
<ol>
<li>长期运行的应用程序：对于需要长时间运行的应用程序，使用G1垃圾收集器可以减少暂停时间并提高吞吐量。这是因为G1收集器可以将大型堆分成多个大小相等的区域，并且只回收那些空间最多的区域。</li>
<li>大型内存项目：由于G1收集器具有更好的内存利用率和更低的碎片化，因此适用于需要大量内存的项目。</li>
<li>多核处理器：G1收集器在多核处理器上的性能表现更佳。因为它可以以并发方式执行垃圾回收操作，从而使每个核处理器都可以同时处理GC操作和应用程序代码。</li>
<li>稳定的堆大小：G1收集器的优化需要稳定的堆大小才能发挥最大效益，建议将Xmx值设置为整个堆的90%到95%。</li>
<li>谨慎使用-XX:MaxGCPauseMillis参数：G1的目标是进行可控制、可预测的垃圾回收，而不是无限制地降低停顿时间。设置过低的 MaxGCPauseMillis 值会导致过多的垃圾回收操作和资源消耗，从而降低垃圾回收的效率和性能。</li>
<li>监控和调整：使用G1垃圾收集器需要监控应用程序的性能，并根据实际情况进行调整。可以通过JVM参数和工具来调整G1收集器的行为，以达到最佳性能。</li>
</ol>
<h2 id="结论"><a class="markdownIt-Anchor" href="#结论"></a> 结论</h2>
<p>G1 垃圾收集器是一种新型的垃圾收集器，专门针对大堆内存的应用程序进行优化，可以更好地处理大量对象的分配和释放，减少停顿时间，并帮助应用程序提高性能。</p>
]]></content>
      <categories>
        <category>JVM</category>
        <category>GC</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>JVM</tag>
        <tag>GC</tag>
      </tags>
  </entry>
  <entry>
    <title>JVM 安全点</title>
    <url>/posts/5a9ba959/</url>
    <content><![CDATA[<p>JVM的安全点（Safepoint）是JVM执行垃圾回收时的一个重要概念。<span style="border-bottom:2px solid green;">在JVM进行垃圾回收操作时，需要保证堆的一致性，因此需要挂起所有运行Java代码的线程并记录它们的状态。这些特定位置就被称为 <em><strong><code>安全点</code></strong></em>。</span>&gt;</p>
<h2 id="安全点的作用"><a class="markdownIt-Anchor" href="#安全点的作用"></a> 安全点的作用</h2>
<p>当一个线程处于安全点时，JVM可以确保该线程不会同时访问堆内存中的对象。如果不挂起所有线程，那么这些线程可能正在访问堆内存中的对象。如果同时执行垃圾回收，则这些线程可能同时修改这些对象，导致数据错误或不一致。因此，在进行垃圾回收操作时，必须等待所有线程到达安全点，并将它们挂起，然后才能继续执行垃圾回收操作。</p>
<h2 id="安全点的触发条件"><a class="markdownIt-Anchor" href="#安全点的触发条件"></a> 安全点的触发条件</h2>
<div class="note-large notel-yellow"><div class="notel-title"><p>当一个线程处于安全点时，它必须满足以下条件之一</p>
</div><div class="notel-content"><ol>
<li>执行Java方法的字节码指令结束或异常抛出；</li>
<li>执行JNI（Java Native Interface）方法的字节码指令结束或异常抛出；</li>
<li>执行VM操作（如Thread.sleep）的字节码指令结束或异常抛出。</li>
</ol>
 </div></div>
<p>这意味着当一个线程处于安全点时，它一定是上述情况之一。只有在这些情况下，线程才被挂起进行垃圾回收操作。</p>
<h2 id="安全点的影响"><a class="markdownIt-Anchor" href="#安全点的影响"></a> 安全点的影响</h2>
<p>当JVM进行垃圾回收操作时，必须等待所有线程到达安全点，并将它们挂起，然后才能继续执行垃圾回收操作。这种等待时间可能会导致一些线程长时间等待，从而导致应用程序响应时间变慢。</p>
<p>为了减少这种情况的发生，JVM提供了多种垃圾回收算法和垃圾回收器，以便在特定的场景中选择最佳的垃圾回收策略。例如CMS（Concurrent Mark Sweep）垃圾回收器就是在并发标记阶段尽可能减少安全点的数量的一种垃圾回收器。</p>
<p>此外，我们也可以通过调整线程数、线程优先级、堆内存大小等措施来减少安全点的影响。</p>
<h2 id="总结"><a class="markdownIt-Anchor" href="#总结"></a> 总结</h2>
<p>安全点是一个重要的概念，在JVM进行垃圾回收操作时扮演着至关重要的角色。了解安全点的作用、触发条件和影响，对于Java开发者来说是非常重要的。在实际开发中，我们需要根据应用场景选择合适的垃圾回收算法和垃圾回收器，并采取相应的措施来减少安全点的影响，以使应用程序能够达到更好的性能和响应速度。</p>
]]></content>
      <categories>
        <category>JVM</category>
        <category>GC</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>JVM</tag>
        <tag>GC</tag>
      </tags>
  </entry>
  <entry>
    <title>AQS</title>
    <url>/posts/dfdb52be/</url>
    <content><![CDATA[<blockquote>
<p>队列同步器 <code>AbstractQueuedSynchronizer</code>（以下简称同步器），是用来构建锁或者其他同步组件的基础框架，<span style="border-bottom: 2px solid green">它使用了一个int成员变量表示同步状态，通过内置的 FIFO队列 来完成资源获取线程的排队工作，</span>并发包的作者（<code>Doug Lea</code>）期望它能够成为实现大部分同步需求的基础。</p>
</blockquote>
<p>同步器的主要使用方式是__继承__，子类通过继承同步器并实现它的抽象方法来管理同步状态，在抽象方法的实现过程中免不了要对同步状态进行更改，这时就需要使用同步器提供的3个方法（getState()、setState(int newState)和compareAndSetState(int expect,int update)）来进行操作，因为它们能够保证状态的改变是安全的。子类推荐被定义为自定义同步组件的静态内部类，同步器自身没有实现任何同步接口，它仅仅是定义了若干同步状态获取和释放的方法来供自定义同步组件使用，同步器既可以支持独占式地获取同步状态，也可以支持共享式地获取同步状态，这样就可以方便实现不同类型的同步组件（ReentrantLock、ReentrantReadWriteLock和CountDownLatch等）。</p>
<h2 id="aqs-接口与示例"><a class="markdownIt-Anchor" href="#aqs-接口与示例"></a> AQS 接口与示例</h2>
<p>同步器的设计是基于模板方法模式的，也就是说，使用者需要继承同步器并重写指定的方法，随后将同步器组合在自定义同步组件的实现中，并调用同步器提供的模板方法，而这些模板方法将会调用使用者重写的方法。</p>
<p>重写同步器指定的方法时，需要使用同步器提供的如下3个方法来访问或修改同步状态。</p>
<ul>
<li><code>getState()</code>：获取当前同步状态。</li>
<li><code>setState(int newState)</code>：设置当前同步状态。</li>
<li><code>compareAndSetState(int expect,int update)</code>：使用CAS设置当前状态，该方法能够保证状态设置的原子性。</li>
</ul>
<p><strong>同步器可重写的方法与描述</strong></p>
<table>
<thead>
<tr>
<th>方法名称</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>protected boolean tryAcquire(int arg)</td>
<td>独占式回去同步状态，实现该方法需要查询当前状态并判断同步状态是否符合预期，然后再进行CAS设置同步状态</td>
</tr>
<tr>
<td>protected boolean tryRelease(int arg)</td>
<td>独占式释放同步状态，等待获取同步状态的线程将有机会获取同步状态</td>
</tr>
<tr>
<td>protected int tryAcquireShared(int arg)</td>
<td>共享式获取同步状态，反悔哦大于等于0的值，标识获取成功，反之，获取失败</td>
</tr>
<tr>
<td>protected boolean tryReleaseShared(int arg)</td>
<td>共享式释放同步状态</td>
</tr>
<tr>
<td>protected boolean isHeldExclusive()</td>
<td>当前同步器是否在独占模式下被线程占用，一般该方法表示是否被当前线程所独占</td>
</tr>
</tbody>
</table>
<p>实现自定义同步组件时，将会调用同步器提供的模板方法。同步器提供的模板方法基本上分为3类：独占式获取与释放同步状态、共享式获取与释放同步状态和查询同步队列中的等待线程情况。自定义同步组件将使用同步器提供的模板方法来实现自己的同步语义。</p>
<p><strong>使用示例</strong></p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Mutex</span> <span class="keyword">implements</span> <span class="title class_">Lock</span> &#123;</span><br><span class="line">    <span class="comment">// 静态内部类，自定义同步器</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Sync</span> <span class="keyword">extends</span> <span class="title class_">AbstractQueuedSynchronizer</span> &#123;</span><br><span class="line">            <span class="comment">// 是否处于占用状态</span></span><br><span class="line">            <span class="keyword">protected</span> <span class="type">boolean</span> <span class="title function_">isHeldExclusively</span><span class="params">()</span> &#123;</span><br><span class="line">                    <span class="keyword">return</span> getState() == <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 当状态为0的时候获取锁</span></span><br><span class="line">            <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">tryAcquire</span><span class="params">(<span class="type">int</span> acquires)</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>, <span class="number">1</span>)) &#123;</span><br><span class="line">    setExclusiveOwnerThread(Thread.currentThread());</span><br><span class="line">                            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 释放锁，将状态设置为0</span></span><br><span class="line">            <span class="keyword">protected</span> <span class="type">boolean</span> <span class="title function_">tryRelease</span><span class="params">(<span class="type">int</span> releases)</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> (getState() == <span class="number">0</span>) <span class="keyword">throw</span> <span class="keyword">new</span> </span><br><span class="line">                    <span class="title class_">IllegalMonitorStateException</span>();</span><br><span class="line">                    setExclusiveOwnerThread(<span class="literal">null</span>);</span><br><span class="line">                    setState(<span class="number">0</span>);</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 返回一个Condition，每个condition都包含了一个condition队列</span></span><br><span class="line">            Condition <span class="title function_">newCondition</span><span class="params">()</span> &#123; <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ConditionObject</span>(); &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 仅需要将操作代理到Sync上即可</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">Sync</span> <span class="variable">sync</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Sync</span>();</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">lock</span><span class="params">()</span> &#123; sync.acquire(<span class="number">1</span>); &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">tryLock</span><span class="params">()</span> &#123; <span class="keyword">return</span> sync.tryAcquire(<span class="number">1</span>); &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">unlock</span><span class="params">()</span> &#123; sync.release(<span class="number">1</span>); &#125;</span><br><span class="line">    <span class="keyword">public</span> Condition <span class="title function_">newCondition</span><span class="params">()</span> &#123; <span class="keyword">return</span> sync.newCondition(); &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isLocked</span><span class="params">()</span> &#123; <span class="keyword">return</span> sync.isHeldExclusively(); &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">hasQueuedThreads</span><span class="params">()</span> &#123; <span class="keyword">return</span> sync.hasQueuedThreads(); &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">lockInterruptibly</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">            sync.acquireInterruptibly(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">tryLock</span><span class="params">(<span class="type">long</span> timeout, TimeUnit unit)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">            <span class="keyword">return</span> sync.tryAcquireNanos(<span class="number">1</span>, unit.toNanos(timeout));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>上述示例中，独占锁Mutex是一个自定义同步组件，它在同一时刻只允许一个线程占有锁。Mutex中定义了一个静态内部类，该内部类继承了同步器并实现了独占式获取和释放同步状态。在tryAcquire(int acquires)方法中，如果经过CAS设置成功（同步状态设置为1），则代表获取了同步状态，而在tryRelease(int releases)方法中只是将同步状态重置为0。用户使用Mutex时并不会直接和内部同步器的实现打交道，而是调用Mutex提供的方法，在Mutex的实现中，以获取锁的lock()方法为例，只需要在方法实现中调用同步器的模板方法acquire(int args)即可，当前线程调用该方法获取同步状态失败后会被加入到同步队列中等待，这样就大大降低了实现一个可靠自定义同步组件的门槛。</p>
<h2 id="总结"><a class="markdownIt-Anchor" href="#总结"></a> 总结</h2>
<p>AQS是Java并发包中提供的一种基础框架，可以帮助我们实现自定义的同步器。内部采用双向阻塞队列的方式，可以避免大量线程同时竞争锁所带来的性能问题。AQS支持可重入锁机制，可以避免死锁等问题。通过掌握AQS的设计思想和使用方法，我们可以更好地理解Java并发编程的核心概念和实践原则。</p>
]]></content>
      <categories>
        <category>并发编程</category>
        <category>AQS</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>并发编程</tag>
      </tags>
  </entry>
  <entry>
    <title>CAS</title>
    <url>/posts/969d9481/</url>
    <content><![CDATA[<blockquote>
<p><span style="border-bottom:2px solid green">CAS 全称为Compare And Swap，中文名为比较与交换。CAS包含三个操作数：内存位置V、旧的预期值A和新值B。当且仅当预期值A和内存位置V的值相同时，才将内存位置V的值更新为B。</span></p>
</blockquote>
<p>在 Java 中，CAS 是通过 Unsafe 类中的 compareAndSwapXXX() 方法来实现的，其中 XXX 表示数据类型。例如，compareAndSwapInt() 用于比较和交换整型数据。</p>
<p>CAS 操作是一种乐观锁，它认为在多线程访问同一资源时，大部分情况下不会出现竞争，因此不采用传统的悲观锁机制（如synchronized关键字）进行加锁，从而避免了加锁和释放锁所带来的系统开销。</p>
<h2 id="应用"><a class="markdownIt-Anchor" href="#应用"></a> 应用</h2>
<p>CAS 在Java中被广泛用于实现原子操作，例如 AtomicInteger、AtomicBoolean 等类就是基于 CAS 实现的。此外，在多线程编程中也常常使用CAS来保证数据的一致性和并发性，例如实现无锁队列、非阻塞算法等。</p>
<p>以下是一个使用CAS实现的线程安全的计数器示例代码：</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Counter</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">AtomicInteger</span> <span class="variable">count</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AtomicInteger</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getCount</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> count.get();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">increment</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">int</span> oldValue, newValue;</span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            oldValue = count.get();</span><br><span class="line">            newValue = oldValue + <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">while</span> (!count.compareAndSet(oldValue, newValue));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>在 increment() 方法中，使用了 do-while 循环和 compareAndSet() 方法来实现对计数器的原子更新操作。如果当前值与预期值相同，则更新为新值；否则继续循环尝试更新，直到成功为止。</p>
<h2 id="优缺点"><a class="markdownIt-Anchor" href="#优缺点"></a> 优缺点</h2>
<p>CAS的优点包括：</p>
<ul>
<li>不需要加锁，避免了锁的开销和可能带来的死锁等问题。</li>
<li>可以支持多个线程同时访问同一资源。</li>
<li>具有高性能和可伸缩性，适用于高并发场景。</li>
</ul>
<p>CAS的缺点包括：</p>
<ul>
<li>在高并发场景下，会出现 ABA 问题，即一个值被修改两次后又变回原值。为了解决这个问题，Java 中提供了 AtomicStampedReference 类，可以通过版本号的方式来避免 ABA 问题。</li>
<li>如果 CAS 操作失败，需要进行重试，也会带来额外的系统开销。</li>
<li>CAS 不能保证公平性，容易导致饥饿等问题。因此，在某些情况下还是需要采用传统的锁机制。</li>
<li>只能保证一个共享变量的原子操作。当对一个共享变量执行操作时，我们可以使用循环CAS的方式来保证原子操作，但是对多个共享变量操作时，循环CAS就无法保证操作的原子性，这个时候就可以用锁。</li>
</ul>
<h2 id="总结"><a class="markdownIt-Anchor" href="#总结"></a> 总结</h2>
<p>CAS是一种基于乐观锁的并发控制方式，具有高性能和可伸缩性，在Java中被广泛应用于实现原子操作和保证数据的一致性和并发性。但CAS也存在着一些缺点，需要根据具体情况进行权衡和选择。</p>
]]></content>
      <categories>
        <category>并发编程</category>
        <category>CAS</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>并发编程</tag>
      </tags>
  </entry>
  <entry>
    <title>CompletableFuture</title>
    <url>/posts/227b7dd1/</url>
    <content><![CDATA[<blockquote>
<p>在Java 8中，引入了一种新的线程并发处理框架 - CompletableFuture，它可以用于执行异步计算，并处理计算结果。CompletableFuture类提供了许多方法来创建、组合和转换异步任务以及处理异常。</p>
</blockquote>
<h2 id="基本用法"><a class="markdownIt-Anchor" href="#基本用法"></a> 基本用法</h2>
<p>下面是一个使用CompletableFuture的示例代码：</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">   CompletableFuture&lt;Integer&gt; future = CompletableFuture.supplyAsync(() -&gt; &#123;</span><br><span class="line">      <span class="comment">// 在这里编写需要计算的任务</span></span><br><span class="line">      <span class="keyword">return</span> <span class="number">42</span>;</span><br><span class="line">   &#125;);</span><br><span class="line">   </span><br><span class="line">   <span class="type">Integer</span> <span class="variable">result</span> <span class="operator">=</span> future.get();</span><br><span class="line">   System.out.println(<span class="string">&quot;计算结果：&quot;</span> + result);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>在这个示例代码中，我们创建了一个名为future的CompletableFuture对象，并使用supplyAsync方法传入一个Supplier对象作为参数来创建该对象。在Supplier的get方法中，我们编写实际的计算任务并返回结果（这里简单地返回了数字42）。然后，我们调用get方法来获取结果。如果计算尚未完成，则该方法会被阻塞，直到计算完成。</p>
<h2 id="高级用法"><a class="markdownIt-Anchor" href="#高级用法"></a> 高级用法</h2>
<p>除了基础用法外，CompletableFuture还提供了许多高级用法，可以适应不同的需求：</p>
<h3 id="组合多个completablefuture对象"><a class="markdownIt-Anchor" href="#组合多个completablefuture对象"></a> 组合多个CompletableFuture对象</h3>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line">CompletableFuture&lt;Integer&gt; future1 = CompletableFuture.supplyAsync(() -&gt; <span class="number">1</span>);</span><br><span class="line">CompletableFuture&lt;Integer&gt; future2 = CompletableFuture.supplyAsync(() -&gt; <span class="number">2</span>);</span><br><span class="line">CompletableFuture&lt;Integer&gt; future3 = CompletableFuture.supplyAsync(() -&gt; <span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">CompletableFuture&lt;Integer&gt; combinedFuture = future1.thenCombine(future2, (result1, result2) -&gt; result1 + result2)</span><br><span class="line">                                                   .thenCombine(future3, (result12, result3) -&gt; result12 + result3);</span><br><span class="line"></span><br><span class="line">System.out.println(combinedFuture.get());</span><br></pre></td></tr></table></figure></div>
<p>如果需要对多个CompletableFuture对象进行组合操作，可以使用thenCombine、thenAcceptBoth和runAfterBoth等方法。这些方法接受一个或多个CompletableFuture对象作为参数，并在计算完成后执行相应的操作。</p>
<h3 id="处理任意一个任务完成"><a class="markdownIt-Anchor" href="#处理任意一个任务完成"></a> 处理任意一个任务完成</h3>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line">CompletableFuture&lt;Integer&gt; future1 = CompletableFuture.supplyAsync(() -&gt; &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">CompletableFuture&lt;Integer&gt; future2 = CompletableFuture.supplyAsync(() -&gt; &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">CompletableFuture&lt;Object&gt; anyFuture = CompletableFuture.anyOf(future1, future2);</span><br><span class="line"></span><br><span class="line">System.out.println(anyFuture.get());</span><br></pre></td></tr></table></figure></div>
<p>如果有多个CompletableFuture对象，并且只需要处理其中任意一个任务完成的情况，可以使用anyOf方法。该方法接受一个CompletableFuture对象数组作为参数，并返回一个新的CompletableFuture对象，该对象在其中任意一个任务完成时就会完成。</p>
<h3 id="当前任务执行完后执行"><a class="markdownIt-Anchor" href="#当前任务执行完后执行"></a> 当前任务执行完后执行</h3>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line">CompletableFuture&lt;Integer&gt; future1 = CompletableFuture.supplyAsync(() -&gt; <span class="number">1</span>);</span><br><span class="line">future1.thenRun(() -&gt; System.out.println(<span class="string">&quot;任务完成&quot;</span>));</span><br></pre></td></tr></table></figure></div>
<p>如果需要在当前任务计算完成后执行操作，可以使用thenRun方法。该方法接受一个Runnable对象作为参数，并在当前任务完成后执行相应的操作。</p>
<h3 id="处理异常情况"><a class="markdownIt-Anchor" href="#处理异常情况"></a> 处理异常情况</h3>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line">CompletableFuture&lt;Integer&gt; future = CompletableFuture.supplyAsync(() -&gt; &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;计算异常&quot;</span>);</span><br><span class="line">&#125;).exceptionally(e -&gt; -<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">System.out.println(future.get());</span><br></pre></td></tr></table></figure></div>
<p>如果在异步计算中出现异常，可以使用exceptionally方法来捕获异常并返回默认结果。</p>
<h3 id="串行执行多个任务"><a class="markdownIt-Anchor" href="#串行执行多个任务"></a> 串行执行多个任务</h3>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line">CompletableFuture.supplyAsync(() -&gt; <span class="string">&quot;Hello&quot;</span>)</span><br><span class="line">.thenApply(s -&gt; s + <span class="string">&quot; World&quot;</span>)</span><br><span class="line">.thenApply(String::toUpperCase)</span><br><span class="line">.thenAccept(System.out::println);</span><br></pre></td></tr></table></figure></div>
<p>如果有多个任务需要按照顺序串行执行，可以使用thenApply、thenAccept和thenRun等方法。这些方法的返回值都是新的CompletableFuture对象，可以继续进行链式调用。</p>
<h2 id="总结"><a class="markdownIt-Anchor" href="#总结"></a> 总结</h2>
<p>CompletableFuture是Java 8中引入的一种新的线程并发处理框架，它可以用于执行异步计算，并处理计算结果。通过学习和使用CompletableFuture，我们可以更好地掌握Java多线程编程的核心思想和实践原则，并为编写高质量、高效的Java程序奠定基础。</p>
]]></content>
      <categories>
        <category>并发编程</category>
        <category>CompletableFuture</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>并发编程</tag>
      </tags>
  </entry>
  <entry>
    <title>CountDownLatch</title>
    <url>/posts/de7c53fe/</url>
    <content><![CDATA[<h2 id="什么是countdownlatch"><a class="markdownIt-Anchor" href="#什么是countdownlatch"></a> 什么是CountdownLatch？</h2>
<blockquote>
<p><code>CountdownLatch</code> 是Java并发包中提供的一种同步工具，用于协调多个线程之间的同步操作。<code>CountdownLatch </code><span style="border-bottom: 2px solid green">内部维护了一个计数器，初始值为指定的数量，当计数器减为0时，所有等待的线程都会被释放，继续向下执行。</span></p>
</blockquote>
<h2 id="countdownlatch的使用方法"><a class="markdownIt-Anchor" href="#countdownlatch的使用方法"></a> CountdownLatch的使用方法</h2>
<p>CountdownLatch有两个主要的方法：</p>
<ul>
<li>countDown()：将计数器减1。</li>
<li>await()：等待计数器变为0。</li>
</ul>
<p>以下是一个使用CountdownLatch的示例代码：</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Worker</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> CountDownLatch startLatch;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> CountDownLatch endLatch;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Worker</span><span class="params">(CountDownLatch startLatch, CountDownLatch endLatch)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.startLatch = startLatch;</span><br><span class="line">        <span class="built_in">this</span>.endLatch = endLatch;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            startLatch.await(); <span class="comment">// 等待开始信号</span></span><br><span class="line">            <span class="comment">// 执行任务...</span></span><br><span class="line">            endLatch.countDown(); <span class="comment">// 发送结束信号</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            Thread.currentThread().interrupt();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">nThreads</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">        <span class="type">CountDownLatch</span> <span class="variable">startLatch</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CountDownLatch</span>(<span class="number">1</span>);</span><br><span class="line">        <span class="type">CountDownLatch</span> <span class="variable">endLatch</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CountDownLatch</span>(nThreads);</span><br><span class="line">        <span class="type">ExecutorService</span> <span class="variable">executorService</span> <span class="operator">=</span> Executors.newFixedThreadPool(nThreads);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; nThreads; i++) &#123;</span><br><span class="line">            executorService.execute(<span class="keyword">new</span> <span class="title class_">Worker</span>(startLatch, endLatch));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 发送开始信号</span></span><br><span class="line">        startLatch.countDown();</span><br><span class="line">        <span class="comment">// 等待所有线程完成任务</span></span><br><span class="line">        endLatch.await();</span><br><span class="line">        executorService.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>在上述示例代码中，启动了10个Worker线程，并通过CountdownLatch实现了对它们的同步控制。首先创建了两个CountdownLatch实例：startLatch和endLatch，分别用于发送开始信号和结束信号。然后创建了一个ExecutorService线程池，并向其中提交了10个Worker任务。在每个Worker任务中，首先调用startLatch.await()方法等待开始信号，然后执行具体的任务，最后调用endLatch.countDown()方法发送结束信号。在主线程中，首先发送开始信号，然后调用endLatch.await()方法等待所有线程完成任务。</p>
<h2 id="优势和应用场景"><a class="markdownIt-Anchor" href="#优势和应用场景"></a> 优势和应用场景</h2>
<h3 id="优势"><a class="markdownIt-Anchor" href="#优势"></a> 优势</h3>
<ul>
<li>可以让多个线程等待某个事件的发生。</li>
<li>可以让某个线程在其他一些线程完成某件事情后再继续执行。</li>
</ul>
<h3 id="应用场景"><a class="markdownIt-Anchor" href="#应用场景"></a> 应用场景</h3>
<ul>
<li>为多个线程协调初始化工作。</li>
<li>实现并发读取大量数据时的同步控制。</li>
<li>实现多个线程间的同步等待。</li>
</ul>
<h2 id="总结"><a class="markdownIt-Anchor" href="#总结"></a> 总结</h2>
<p>CountdownLatch 是 Java 并发包提供的一种同步工具，用于协调多个线程之间的同步操作。它可以帮助多个线程等待某个事件的发生，并可以让某个线程在其他一些线程完成某件事情后再继续执行。CountdownLatch 是实现多线程协作的重要工具之一，对于需要实现多个线程间的同步等待的场景非常有用。</p>
]]></content>
      <categories>
        <category>并发编程</category>
        <category>CountDownLatch</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>并发编程</tag>
      </tags>
  </entry>
  <entry>
    <title>FutureTask</title>
    <url>/posts/9860061d/</url>
    <content><![CDATA[<blockquote>
<p>在Java中，FutureTask是一种基于线程的并发工具类，它可以用于异步计算。通过使用FutureTask，我们可以将一个长时间运行的计算任务提交给另一个线程，并继续执行其他任务。当需要结果时，可以调用get方法获取计算结果，如果计算尚未完成，则会阻塞等待。FutureTask还提供了cancel方法来取消计算任务。</p>
</blockquote>
<h2 id="futuretask的基本用法"><a class="markdownIt-Anchor" href="#futuretask的基本用法"></a> FutureTask的基本用法</h2>
<p>下面是一个使用FutureTask的示例代码：</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">   FutureTask&lt;Integer&gt; task = <span class="keyword">new</span> <span class="title class_">FutureTask</span>&lt;&gt;(<span class="keyword">new</span> <span class="title class_">Callable</span>&lt;Integer&gt;() &#123;</span><br><span class="line">      <span class="meta">@Override</span></span><br><span class="line">      <span class="keyword">public</span> Integer <span class="title function_">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">         <span class="comment">// 在这里编写需要计算的任务</span></span><br><span class="line">         <span class="keyword">return</span> <span class="number">42</span>;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;);</span><br><span class="line">   </span><br><span class="line">   <span class="keyword">new</span> <span class="title class_">Thread</span>(task).start();</span><br><span class="line">   </span><br><span class="line">   <span class="comment">// 在这里做一些其他事情</span></span><br><span class="line">   </span><br><span class="line">   <span class="type">Integer</span> <span class="variable">result</span> <span class="operator">=</span> task.get();</span><br><span class="line">   System.out.println(<span class="string">&quot;计算结果：&quot;</span> + result);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>在这个示例代码中，我们创建了一个名为task的FutureTask对象，并传入一个Callable对象作为参数。在Callable的call方法中，我们编写实际的计算任务，并返回结果（这里简单地返回了数字42）。然后，我们创建一个新线程并启动任务。在任务执行期间，我们可以做一些其他事情，比如继续执行其他任务。最后，我们调用get方法来获取结果。如果计算尚未完成，则该方法会被阻塞，直到计算完成。</p>
<h2 id="futuretask的高级用法"><a class="markdownIt-Anchor" href="#futuretask的高级用法"></a> FutureTask的高级用法</h2>
<p>除了基础用法外，FutureTask还提供了许多高级用法，可以适应不同的需求：</p>
<h3 id="设置超时时间"><a class="markdownIt-Anchor" href="#设置超时时间"></a> 设置超时时间</h3>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Integer</span> <span class="variable">result</span> <span class="operator">=</span> task.get(<span class="number">1</span>, TimeUnit.SECONDS);</span><br></pre></td></tr></table></figure></div>
<p>如果需要在一定时间内获取计算结果，可以调用get方法的另一个重载，并传入超时时间和时间单位。如果在指定时间内没有获取到结果，则会抛出TimeoutException异常。</p>
<h3 id="中断计算任务"><a class="markdownIt-Anchor" href="#中断计算任务"></a> 中断计算任务</h3>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line">task.cancel(<span class="literal">true</span>);</span><br></pre></td></tr></table></figure></div>
<p>在某些情况下，可能需要取消计算任务。为此，可以使用cancel方法。该方法接受一个布尔值参数，指示是否中断任务执行。如果任务正在执行，则会向任务线程发送中断信号。</p>
<h3 id="判断计算完成状态"><a class="markdownIt-Anchor" href="#判断计算完成状态"></a> 判断计算完成状态</h3>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">boolean</span> <span class="variable">isDone</span> <span class="operator">=</span> task.isDone();</span><br></pre></td></tr></table></figure></div>
<p>如果想要确定计算是否已经完成，可以调用isDone方法。它将返回一个布尔值，指示计算是否已经完成。</p>
<h2 id="总结"><a class="markdownIt-Anchor" href="#总结"></a> 总结</h2>
<p>FutureTask是Java中一种基于线程的并发工具类，它可以用于异步计算。通过学习和使用FutureTask，我们可以更好地掌握Java多线程编程的核心思想和实践原则，并为编写高质量、高效的Java程序奠定基础。</p>
]]></content>
      <categories>
        <category>并发编程</category>
        <category>FutureTask</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>并发编程</tag>
      </tags>
  </entry>
  <entry>
    <title>Fork / Join</title>
    <url>/posts/77d3638d/</url>
    <content><![CDATA[<blockquote>
<p>在Java 7中，引入了一种新的并行处理框架 - Fork/Join，它可以用于执行递归算法，并试图使用所有可用的处理器来提高性能。Fork/Join框架是一个基于工作窃取（work stealing）算法实现的线程池，其核心是将大任务分割成小任务进行并行处理，最终将结果合并。</p>
</blockquote>
<h2 id="工作窃取算法"><a class="markdownIt-Anchor" href="#工作窃取算法"></a> 工作窃取算法</h2>
<p>工作窃取算法（work stealing algorithm）是一种负载均衡策略，它通过让某些线程从其他线程的队列里窃取任务来实现。具体而言，每个线程维护自己的双端队列，当一个线程完成自己的任务后，它会查找其他线程队列的末尾，然后从那里窃取一个任务并执行。这样，在某些情况下，可以避免某个线程一直处于繁忙状态，而其他线程却闲置的情况，从而提高整个系统的吞吐量。</p>
<h2 id="基本原理"><a class="markdownIt-Anchor" href="#基本原理"></a> 基本原理</h2>
<p>Fork/Join框架主要包含两个类：ForkJoinPool和ForkJoinTask。其中，ForkJoinPool是线程池的实现类，它继承自AbstractExecutorService类，因此可以使用execute、submit和invoke等方法来提交任务。ForkJoinTask则是一个抽象类，它表示可以使用Fork/Join框架进行并行处理的任务。</p>
<p>在Fork/Join框架中，任务分为两种类型：</p>
<ul>
<li>普通任务（RecursiveTask）：具有返回值的任务。</li>
<li>动作任务（RecursiveAction）：不具有返回值的任务。</li>
</ul>
<p>如果想要使用Fork/Join框架，需要遵循以下步骤：</p>
<ol>
<li>创建一个继承自RecursiveTask或RecursiveAction的任务类。</li>
<li>在任务类中实现compute方法，该方法将任务分解成较小的子任务，并在递归基本情况下计算每个子任务。</li>
<li>创建ForkJoinPool对象。</li>
<li>将任务提交给ForkJoinPool执行。</li>
<li>获取任务结果。</li>
</ol>
<h2 id="示例代码"><a class="markdownIt-Anchor" href="#示例代码"></a> 示例代码</h2>
<p>下面是一个使用Fork/Join框架的示例代码，它演示了如何计算斐波那契数列的第n项：</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Fibonacci</span> <span class="keyword">extends</span> <span class="title class_">RecursiveTask</span>&lt;Integer&gt; &#123;</span><br><span class="line">   <span class="keyword">final</span> <span class="type">int</span> n;</span><br><span class="line">   Fibonacci(<span class="type">int</span> n) &#123; <span class="built_in">this</span>.n = n; &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">protected</span> Integer <span class="title function_">compute</span><span class="params">()</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (n &lt;= <span class="number">1</span>)</span><br><span class="line">         <span class="keyword">return</span> n;</span><br><span class="line">      <span class="type">Fibonacci</span> <span class="variable">f1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Fibonacci</span>(n - <span class="number">1</span>);</span><br><span class="line">      f1.fork();</span><br><span class="line">      <span class="type">Fibonacci</span> <span class="variable">f2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Fibonacci</span>(n - <span class="number">2</span>);</span><br><span class="line">      <span class="keyword">return</span> f2.compute() + f1.join();</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">      <span class="type">ForkJoinPool</span> <span class="variable">pool</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ForkJoinPool</span>();</span><br><span class="line">      <span class="type">Fibonacci</span> <span class="variable">f</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Fibonacci</span>(<span class="number">10</span>);</span><br><span class="line">      <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> pool.invoke(f);</span><br><span class="line">      System.out.println(result);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>在这个示例代码中，我们创建了一个名为 Fibonacci 的类，并继承了 RecursiveTask。在 compute 方法中，我们首先检查n是否小于等于1，如果是，则返回n。否则，我们将任务分解成两个子任务：计算n-1和n-2的斐波那契数列，并使用 fork() 方法异步执行第一个子任务。然后，我们同步执行第二个子任务，并等待第一个子任务完成。最后，我们返回结果。</p>
<p>在main方法中，我们创建了一个ForkJoinPool对象，并使用invoke()方法提交任务并获取结果。</p>
<h2 id="高级用法"><a class="markdownIt-Anchor" href="#高级用法"></a> 高级用法</h2>
<p>除了基础用法外，Fork/Join框架还提供了许多高级用法，可以适应不同的需求：</p>
<h3 id="更改并行度"><a class="markdownIt-Anchor" href="#更改并行度"></a> 更改并行度</h3>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">ForkJoinPool</span> <span class="variable">pool</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ForkJoinPool</span>(<span class="number">4</span>);</span><br></pre></td></tr></table></figure></div>
<p>在默认情况下，Fork/Join框架使用计算机的所有可用核心来执行任务。如果需要更改并行度，可以在创建ForkJoinPool对象时指定并行度。</p>
<h3 id="使用invokeall方法同时执行多个任务"><a class="markdownIt-Anchor" href="#使用invokeall方法同时执行多个任务"></a> 使用invokeAll方法同时执行多个任务</h3>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;Fibonacci&gt; tasks = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">   tasks.add(<span class="keyword">new</span> <span class="title class_">Fibonacci</span>(i));</span><br><span class="line">&#125;</span><br><span class="line">pool.invokeAll(tasks);</span><br></pre></td></tr></table></figure></div>
<p>如果有多个任务需要同时执行，可以使用invokeAll()方法来提交所有任务，并等待它们全部完成。该方法返回一个ForkJoinTask对象列表，其中每个对象对应一个任务。</p>
<h3 id="子任务的取消"><a class="markdownIt-Anchor" href="#子任务的取消"></a> 子任务的取消</h3>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyTask</span> <span class="keyword">extends</span> <span class="title class_">RecursiveTask</span>&lt;Integer&gt; &#123;</span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="keyword">protected</span> Integer <span class="title function_">compute</span><span class="params">()</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (Thread.currentThread().isInterrupted()) &#123;</span><br><span class="line">         <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 在这里编写需要同步处理的代码逻辑</span></span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>如果某些子任务已经无法被处理或不再需要处理，可以考虑取消它们。在Fork/Join框架中，可以使用Thread.interrupt()方法来中断正在执行的线程。在任务的compute方法中，我们可以通过检查当前线程是否被中断来判断是否应该取消任务。</p>
<h2 id="总结"><a class="markdownIt-Anchor" href="#总结"></a> 总结</h2>
<p>Fork/Join 框架是Java 7中引入的一种新的并行处理框架，它可以用于执行递归算法，并试图使用所有可用的处理器来提高性能。在使用Fork/Join框架时，我们需要继承RecursiveTask或RecursiveAction类，并在compute方法中实现任务分解和结果合并逻辑。通过学习和使用Fork/Join框架，我们可以更好地掌握Java多线程编程的核心思想和实践原则，并为编写高质量、高效的Java程序奠定基础。</p>
]]></content>
      <categories>
        <category>并发编程</category>
        <category>Fork / Join</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>并发编程</tag>
      </tags>
  </entry>
  <entry>
    <title>ReentrantLock</title>
    <url>/posts/6e505175/</url>
    <content><![CDATA[<blockquote>
<p>在Java中，线程同步是非常重要的。它可以避免多个线程同时访问共享资源时导致的数据竞争和一致性问题。Java提供了很多种线程同步机制，其中之一就是ReentrantLock。</p>
</blockquote>
<h2 id="什么是reentrantlock"><a class="markdownIt-Anchor" href="#什么是reentrantlock"></a> 什么是ReentrantLock</h2>
<p><code>ReentrantLock</code>是 Java 中的一个锁对象，它可以协调多个线程对共享资源的访问。与内部锁 synchronized 不同的是，ReentrantLock 具有可重入性，即同一个线程可以多次获得这个锁，而不会被自己所阻塞。</p>
<p>ReentrantLock 还支持公平锁和非公平锁，默认情况下为非公平锁。公平锁会按照线程请求的顺序分配锁，而非公平锁则不保证这点。</p>
<h2 id="如何使用reentrantlock"><a class="markdownIt-Anchor" href="#如何使用reentrantlock"></a> 如何使用ReentrantLock</h2>
<p>使用ReentrantLock可以分为三个步骤：创建锁对象、获取锁和释放锁。</p>
<h3 id="创建锁对象"><a class="markdownIt-Anchor" href="#创建锁对象"></a> 创建锁对象</h3>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">ReentrantLock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br></pre></td></tr></table></figure></div>
<h3 id="获取锁"><a class="markdownIt-Anchor" href="#获取锁"></a> 获取锁</h3>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line">lock.lock();</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// 在这里编写需要同步处理的代码逻辑</span></span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    lock.unlock();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<h3 id="释放锁"><a class="markdownIt-Anchor" href="#释放锁"></a> 释放锁</h3>
<p>当获得锁后，我们需要在finally块中释放锁。这样可以确保锁总是会被释放，即使在同步代码块中抛出了异常。</p>
<h2 id="示例代码"><a class="markdownIt-Anchor" href="#示例代码"></a> 示例代码</h2>
<p>下面是一个使用ReentrantLock的示例代码，它演示了如何使用ReentrantLock来同步访问共享资源：</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Example</span> &#123;</span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">ReentrantLock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line"></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">      <span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Worker</span>(), <span class="string">&quot;Thread 1&quot;</span>);</span><br><span class="line">      <span class="type">Thread</span> <span class="variable">t2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Worker</span>(), <span class="string">&quot;Thread 2&quot;</span>);</span><br><span class="line"></span><br><span class="line">      t1.start();</span><br><span class="line">      t2.start();</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Worker</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">      <span class="meta">@Override</span></span><br><span class="line">      <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">         lock.lock();</span><br><span class="line">         <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot; acquired the lock.&quot;</span>);</span><br><span class="line">            <span class="comment">// 执行需要同步处理的操作</span></span><br><span class="line">         &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot; released the lock.&quot;</span>);</span><br><span class="line">            lock.unlock();</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>在这个示例代码中，我们创建了一个名为Example的类，并定义了一个ReentrantLock对象。然后，我们创建两个线程（Thread 1和Thread 2），每个线程都会执行Worker类的run方法。在Worker类的run方法中，我们通过lock.lock()获取锁，并在try语句块中执行需要同步处理的操作。在finally块中，我们使用lock.unlock()释放锁。最后，在控制台上输出哪个线程获得了锁并成功释放了锁。</p>
<h2 id="reentrantlock的高级用法"><a class="markdownIt-Anchor" href="#reentrantlock的高级用法"></a> ReentrantLock的高级用法</h2>
<p>除了基础用法外，ReentrantLock还提供了许多高级用法，可以适应不同的需求：</p>
<h3 id="使用trylock方法尝试获取锁"><a class="markdownIt-Anchor" href="#使用trylock方法尝试获取锁"></a> 使用tryLock方法尝试获取锁</h3>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (lock.tryLock()) &#123;</span><br><span class="line">   <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="comment">// 在这里编写需要同步处理的代码逻辑</span></span><br><span class="line">   &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">      lock.unlock();</span><br><span class="line">   &#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">   <span class="comment">// 如果无法获取锁，则执行其他操作</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>在某些情况下，我们不想一直等待获取锁。此时，可以使用tryLock()方法尝试获取锁。如果在指定时间内没有获取到锁，则返回false。</p>
<h3 id="使用lockinterruptibly方法获取可中断锁"><a class="markdownIt-Anchor" href="#使用lockinterruptibly方法获取可中断锁"></a> 使用lockInterruptibly方法获取可中断锁</h3>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">   <span class="keyword">try</span> &#123;</span><br><span class="line">      lock.lockInterruptibly();</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">         <span class="comment">// 在这里编写需要同步处理的代码逻辑</span></span><br><span class="line">      &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">         lock.unlock();</span><br><span class="line">      &#125;</span><br><span class="line">   &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">      Thread.currentThread().interrupt();</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>在某些情况下，我们希望在等待获取锁时能够相应中断请求。此时，可以使用lockInterruptibly()方法来获取可中断锁。</p>
<h3 id="使用condition实现线程间通信"><a class="markdownIt-Anchor" href="#使用condition实现线程间通信"></a> 使用Condition实现线程间通信</h3>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">Lock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">Condition</span> <span class="variable">condition</span> <span class="operator">=</span> lock.newCondition();</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">   <span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Task</span>(), <span class="string">&quot;Thread 1&quot;</span>);</span><br><span class="line">   t1.start();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Task</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">      lock.lock();</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">         condition.await();</span><br><span class="line">         <span class="comment">// 在这里编写需要同步处理的代码逻辑</span></span><br><span class="line">      &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">         Thread.currentThread().interrupt();</span><br><span class="line">      &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">         lock.unlock();</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>除了基本的锁机制，ReentrantLock还提供了Condition接口来实现线程间通信。可以使用lock.newCondition()方法创建一个Condition对象。在等待某个条件时，可以调用condition.await()方法。当条件满足时，可以调用condition.signal()方法来唤醒等待的线程。</p>
<h2 id="总结"><a class="markdownIt-Anchor" href="#总结"></a> 总结</h2>
<p>在 Java 中，线程同步是非常重要的。ReentrantLock 是 Java 中一个可重入的锁对象，它提供了高级的使用方式，如尝试获取锁、可中断锁和线程间通信等。通过学习和使用 ReentrantLock，我们可以更好地掌握Java多线程编程的核心思想和实践原则，并为编写高质量、高效的Java程序奠定基础。</p>
]]></content>
      <categories>
        <category>并发编程</category>
        <category>ReentrantLock</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>并发编程</tag>
      </tags>
  </entry>
  <entry>
    <title>Synchronized</title>
    <url>/posts/f5dbca44/</url>
    <content><![CDATA[<p>在多线程并发编程中<code>synchronized</code>一直是元老级角色，很多人都会称呼它为重量级锁。但是，随着 Java SE 1.6 对 synchronized 进行了各种优化之后，有些情况下它就并不那么重了。</p>
<h2 id="实现同步基础"><a class="markdownIt-Anchor" href="#实现同步基础"></a> 实现同步基础</h2>
<p><code>Synchronized</code> 是 Java 中的关键字，它用于实现线程同步，确保<span style="border-bottom: 2px solid green">多个线程在访问共享资源时不会产生冲突和数据不一致的问题。</span></p>
<p>当一个线程进入某个对象或方法的 synchronized 块时，它就获得了这个对象的锁，其他线程不能再进入该对象的 synchronized 块，直到该线程释放锁。这样就能保证同一时间只有一个线程访问该对象的共享资源，从而达到线程安全的目的。</p>
<h3 id="java-中的对象都可以作为锁"><a class="markdownIt-Anchor" href="#java-中的对象都可以作为锁"></a> Java 中的对象都可以作为锁</h3>
<blockquote>
<p>Java中的每一个对象都可以作为锁。具体表现为以下3种形式。</p>
</blockquote>
<ul>
<li>普通同步方法，锁是当前实例对象。</li>
</ul>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">increment</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 锁是当前实例对象</span></span><br><span class="line">        count++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>在上述示例中，<code>increment</code> 方法加了 <code>synchronized</code> 关键字，所以这个方法成为了一个同步方法。由于锁是当前实例对象，因此一旦某个线程进入该方法，就会锁定当前实例对象，其他线程将无法再进入该方法，直到该线程执行完毕并释放锁。</p>
<ul>
<li>静态同步方法，锁是当前类的 Class 对象。</li>
</ul>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">increment</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 锁是当前类的 Class 对象</span></span><br><span class="line">        count++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>在上述示例中，<code>increment</code> 方法同样加了 <code>synchronized</code> 关键字，但是由于它是一个静态方法，因此锁是当前类的 Class 对象。一旦某个线程进入该方法，就会锁定当前类的 Class 对象，其他线程将无法进入该方法，直到该线程执行完毕并释放锁。</p>
<ul>
<li>同步方法块，锁是 <code>Synchronized</code> 括号里配置的对象。</li>
</ul>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">Object</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">increment</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 锁是 Synchronized 括号里配置的对象</span></span><br><span class="line">        <span class="keyword">synchronized</span> (lock) &#123;</span><br><span class="line">            count++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>在上述示例中，<code>increment</code> 方法没有加 <code>synchronized</code> 关键字，而是使用同步代码块。这个同步代码块使用了 <code>Synchronized</code> 关键字，并在括号里配置了一个对象 <code>lock</code>。因此，锁定的是 <code>lock</code> 这个对象。只有进入该方法的线程可以获取 <code>lock</code> 对象的锁，其他线程就无法获取该锁，直到该线程执行完同步代码块并释放锁。</p>
<h3 id="monitor"><a class="markdownIt-Anchor" href="#monitor"></a> Monitor</h3>
<p>从 JVM 规范中可以看到 Synchonized 在 JVM 里的实现原理，JVM 基于进入和退出 Monitor 对象来实现方法同步和代码块同步，但两者的实现细节不一样。<span style="border-bottom: 2px solid green">代码块同步是使用 monitorenter 和 monitorexit 指令实现的，而方法同步是使用另外一种方式实现的，细节在 JVM 规范里并没有详细说明。但是，方法的同步同样可以使用这两个指令来实现。</span></p>
<p><span style="border-bottom: 2px solid green"><code>monitorenter</code> 指令是在编译后插入到同步代码块的开始位置，而 <code>monitorexit</code> 是插入到方法结束处和异常处，JVM要保证每个monitorenter 必须有对应的 monitorexit 与之配对。</span>任何对象都有一个 monitor 与之关联，当且一个 monitor 被持有后，它将处于锁定状态。线程执行到 monitorenter 指令时，将会尝试获取对象所对应的 monitor 的所有权，即尝试获得对象的锁。</p>
<h3 id="对象头"><a class="markdownIt-Anchor" href="#对象头"></a> 对象头</h3>
<blockquote>
<p>当一个线程试图访问同步代码块时，它首先必须得到锁，退出或抛出异常时必须释放锁。那么锁到底存在哪里呢？锁里面会存储什么信息呢？</p>
</blockquote>
<p><code>synchronized</code> 用的锁是存在 Java对象头里的。如果对象是数组类型，则虚拟机用3个字宽（Word）存储对象头，如果对象是非数组类型，则用2字宽存储对象头。在32位虚拟机中，1字宽等于4字节，即32bit，如表所示。</p>
<table>
<thead>
<tr>
<th style="text-align:center">长度</th>
<th style="text-align:center">内容</th>
<th style="text-align:center">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">32/64bit</td>
<td style="text-align:center">Mark Word</td>
<td style="text-align:center">存储对象的hashcode或锁信息</td>
</tr>
<tr>
<td style="text-align:center">32/64bit</td>
<td style="text-align:center">Class Metadata Address</td>
<td style="text-align:center">存储到对象类型数据的指针</td>
</tr>
<tr>
<td style="text-align:center">32/64bit</td>
<td style="text-align:center">Array length</td>
<td style="text-align:center">数组的长度（如果当前对象是数组）</td>
</tr>
</tbody>
</table>
<p>Java 对象头里的<code>Mark Word</code>里默认存储对象的 HashCode、分代年龄和锁标记位。在运行期间，Mark Word里存储的数据会随着锁标志位的变化而变化。Mark Word可能变化为存储以下4种数据，如表所示。</p>
<table style="text-align: center;">
	<tr>
		<td rowspan=2>锁状态</td>
		<td colspan=2>25bit</td>
		<td rowspan=2>4bit</td>
		<td>1bit</td>
		<td>2bit</td>
	</tr>
	<tr>
		<td>23bit</td>
		<td>2bit</td>
		<td>是否是偏向锁</td>
		<td>锁标志位</td>
	</tr>
	<tr>
		<td>轻量级锁</td>
		<td colspan=4 >指向栈中锁记录的指针</td>
		<td>00</td>
	</tr>
	<tr>
		<td>重量级锁</td>
		<td colspan=4 >指向互斥量（重量级锁）的指针</td>
		<td>10</td>
	</tr>
	<tr>
		<td>GC 标记</td>
		<td colspan=4 >空</td>
		<td>11</td>
	</tr>
	<tr>
		<td>偏向锁</td>
		<td>线程 ID</td>
		<td>Epoch</td>
		<td>对象分代年龄</td>
		<td>1</td>
		<td>01</td>
	</tr>
</table>
<h3 id="锁的升级"><a class="markdownIt-Anchor" href="#锁的升级"></a> 锁的升级</h3>
<blockquote>
<p>Java SE 1.6为了减少获得锁和释放锁带来的性能消耗，引入了“偏向锁”和“轻量级锁”，在 Java SE 1.6中，<span style="border-bottom:2px solid green">锁一共有4种状态，级别从低到高依次是：无锁状态、偏向锁状态、轻量级锁状态和重量级锁状态，这几个状态会随着竞争情况逐渐升级。</span></p>
</blockquote>
<h4 id="偏向锁"><a class="markdownIt-Anchor" href="#偏向锁"></a> 偏向锁</h4>
<p>HotSpot 的作者经过研究发现，大多数情况下，锁不仅不存在多线程竞争，而且总是由同一线程多次获得，为了让线程获得锁的代价更低而引入了偏向锁。</p>
<h5 id="偏向锁的加锁"><a class="markdownIt-Anchor" href="#偏向锁的加锁"></a> 偏向锁的加锁</h5>
<p>当一个线程访问同步块并获取锁时，会在对象头和栈帧中的锁记录里存储锁偏向的线程 ID，以后该线程在进入和退出同步块时不需要进行 CAS 操作来加锁和解锁，只需简单地测试一下对象头的 Mark Word 里是否存储着指向当前线程的偏向锁。如果测试成功，表示线程已经获得了锁。如果测试失败，则需要再测试一下 Mark Word 中偏向锁的标识是否设置成1（表示当前是偏向锁）：如果没有设置，则使用 CAS 竞争锁；如果设置了，则尝试使用CAS将对象头的偏向锁指向当前线程。</p>
<h5 id="偏向锁的释放"><a class="markdownIt-Anchor" href="#偏向锁的释放"></a> 偏向锁的释放</h5>
<p>偏向锁使用了一种等到竞争出现才释放锁的机制，所以当其他线程尝试竞争偏向锁时，持有偏向锁的线程才会释放锁。偏向锁的撤销，需要等待全局安全点（在这个时间点上没有正在执行的字节码）。它会首先暂停拥有偏向锁的线程，然后检查持有偏向锁的线程是否活着，如果线程不处于活动状态，则将对象头设置成无锁状态；如果线程仍然活着，拥有偏向锁的栈会被执行，遍历偏向对象的锁记录，栈中的锁记录和对象头的Mark Word要么重新偏向于其他线程，要么恢复到无锁或者标记对象不适合作为偏向锁，最后唤醒暂停的线程。下图中的线程1演示了偏向锁初始化的流程，线程2演示了偏向锁撤销的流程。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="synchronized.webp"
                      alt="synchronized.webp" 
                ></p>
<h5 id="关闭偏向锁"><a class="markdownIt-Anchor" href="#关闭偏向锁"></a> 关闭偏向锁</h5>
<p>偏向锁在Java 6和Java 7里是默认启用的，但是它在应用程序启动几秒钟之后才激活，如有必要可以使用JVM参数来关闭延迟：<code>-XX:BiasedLockingStartupDelay=0</code>。如果你确定应用程序里所有的锁通常情况下处于竞争状态，可以通过 JVM 参数关闭偏向锁：<code>-XX:-UseBiasedLocking=false</code>，那么程序默认会进入轻量级锁状态。</p>
<h4 id="轻量级锁"><a class="markdownIt-Anchor" href="#轻量级锁"></a> 轻量级锁</h4>
<h5 id="轻量级锁加锁"><a class="markdownIt-Anchor" href="#轻量级锁加锁"></a> 轻量级锁加锁</h5>
<p>线程在执行同步块之前，JVM会先在当前线程的栈桢中创建用于存储锁记录的空间，并将对象头中的Mark Word复制到锁记录中，官方称为Displaced Mark Word。然后线程尝试使用CAS将对象头中的Mark Word替换为指向锁记录的指针。如果成功，当前线程获得锁，如果失败，表示其他线程竞争锁，当前线程便尝试使用自旋来获取锁。</p>
<h5 id="轻量级锁解锁"><a class="markdownIt-Anchor" href="#轻量级锁解锁"></a> 轻量级锁解锁</h5>
<p>轻量级解锁时，会使用原子的CAS操作将Displaced Mark Word替换回到对象头，如果成功，则表示没有竞争发生。如果失败，表示当前锁存在竞争，锁就会膨胀成重量级锁。下图是两个线程同时争夺锁，导致锁膨胀的流程图。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="synchronized02.webp"
                      alt="synchronized02" 
                ></p>
<h2 id="总结"><a class="markdownIt-Anchor" href="#总结"></a> 总结</h2>
<p>Synchronized关键字是Java中一种常用的多线程并发控制机制，它可以保证对共享资源的互斥访问，并且保证操作的原子性。然而，在实际应用中，需要注意锁的粒度问题和线程间的通信问题，以避免出现死锁、活锁等常见问题。</p>
<p>在JDK1.5之后，Java提供了更为灵活和高效的Lock机制，它可以替代Synchronized关键字，并且提供了更多的功能和特性。因此，在实际开发中，建议优先使用Lock机制来进行多线程并发控制。</p>
<p>同时，在编写多线程程序时，需要遵循一定的规范和约束，例如避免在同步代码块内调用外部方法、避免在锁内等待其他线程执行等待某个条件的操作等。只有在正确使用各种多线程并发控制机制的基础上，才能写出高效、健壮的多线程程序。</p>
]]></content>
      <categories>
        <category>并发编程</category>
        <category>Synchronized</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>并发编程</tag>
      </tags>
  </entry>
  <entry>
    <title>线程池</title>
    <url>/posts/de7c53fe/</url>
    <content><![CDATA[<p>在Java中，每当我们需要创建新的线程时，都会涉及到一些系统资源的分配和初始化操作，这可能会导致性能上的瓶颈。为了避免这种情况，Java提供了线程池来管理一组预定义数量的线程，并将它们维护在一个线程池中，以便快速地重复使用。</p>
<h2 id="实现原理"><a class="markdownIt-Anchor" href="#实现原理"></a> 实现原理</h2>
<p>Java线程池的内部实现主要包括以下几个关键组件：</p>
<ul>
<li>ThreadPoolExecutor：线程池的核心类，负责创建和管理线程池、提交任务、执行任务等操作。</li>
<li>BlockingQueue：阻塞队列，用于存储提交的任务，在线程池中的线程可以从队列中取出任务并执行。</li>
<li>ThreadFactory：线程工厂，用于创建新的线程。</li>
<li>RejectedExecutionHandler：拒绝策略，用于处理当线程池已满时无法接受新任务的情况。</li>
</ul>
<p>具体的实现过程如下：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="threadpool.webp"
                      alt="threadpool.webp" 
                ></p>
<ol>
<li>当我们需要使用线程池时，首先需要创建ThreadPoolExecutor对象，并指定一些基本的参数（例如核心线程数量、最大线程数量、存活时间等）。</li>
<li>然后，我们可以将任务提交给线程池执行。线程池会根据当前的线程数和任务队列来判断是否需要创建新的线程来执行任务。</li>
<li>如果当前线程数小于核心线程数，则会创建新的线程；否则，将任务加入到阻塞队列中等待执行。</li>
<li>如果队列已满且当前线程数小于最大线程数，则会创建新的线程来执行任务。</li>
<li>如果队列已满且当前线程数已达到最大线程数，则会执行指定的拒绝策略，例如抛出异常或者将任务回退到调用者。</li>
<li>当线程池中的某个线程完成了任务后，会从队列中获取下一个任务执行，如果队列中没有任务，则该线程会被释放并回收资源。</li>
</ol>
<p>通过上述过程，Java线程池实现了对线程进行动态管理，可以更好地控制线程的数量和状态，从而提高系统效率和可维护性。</p>
<h2 id="常用方法"><a class="markdownIt-Anchor" href="#常用方法"></a> 常用方法</h2>
<p>ThreadPoolExecutor类提供了许多有用的方法，其中一些常用方法如下：</p>
<ul>
<li>execute(Runnable)：提交一个Runnable任务给线程池执行。</li>
<li>submit(Callable)：提交一个Callable任务给线程池执行，并返回一个Future对象。</li>
<li>shutdown()：关闭线程池，不再接受新的任务提交，但会等待所有已提交的任务执行完成后再关闭线程池。</li>
<li>shutdownNow()：立即关闭线程池，并尝试中断所有正在执行的任务。</li>
<li>awaitTermination(long, TimeUnit)：阻塞当前线程，直到线程池关闭或者超时。</li>
<li>getActiveCount()：返回当前线程池中活动线程的数量。</li>
<li>getCompletedTaskCount()：返回线程池中已经完成的任务数量。</li>
<li>getTaskCount()：返回线程池中已经提交的任务数量。</li>
</ul>
<p>以上方法可以帮助我们更好地管理和监控线程池的状态，并及时发现线程池中可能存在的问题。</p>
<h2 id="优势及注意事项"><a class="markdownIt-Anchor" href="#优势及注意事项"></a> 优势及注意事项</h2>
<p>使用Java线程池有以下几个显著的优点：</p>
<ul>
<li>提高系统效率：线程池可以避免反复创建和销毁线程所带来的额外开销，从而提高系统效率。</li>
<li>提高响应速度：使用线程池可以更快地响应请求，因为无需等待新线程的创建和初始化。</li>
<li>提高线程的可管理性：线程池可以让我们更好地管理线程的数量、状态以及执行的任务，从而更加方便地对整个线程进行监控和调优。</li>
</ul>
<div class="note-large notel-yellow"><div class="notel-title"><p>注意事项</p>
</div><div class="notel-content"><ol>
<li>线程池的大小和任务队列的容量需要根据实际情况进行设置，过小可能会导致任务等待时间过长，而过大则会浪费系统资源。</li>
<li>线程池的生命周期需要正确管理，包括启动、执行任务、关闭等操作。一般建议使用try-with-resources语句或者在finally块中手动关闭线程池。</li>
<li>线程池中的任务需要保证线程安全。如果多个任务之间存在共享状态，需要进行同步处理以避免竞态条件和死锁等问题。</li>
<li>需要根据实际情况选择合适的拒绝策略，例如抛出异常、将任务回退到调用者、丢弃最新的任务等。</li>
</ol>
 </div></div>
<h2 id="使用举栗"><a class="markdownIt-Anchor" href="#使用举栗"></a> 使用举栗</h2>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Example</span> &#123;</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">      <span class="comment">// 创建线程池，其中 corePoolSize 为线程池的基本大小，maximumPoolSize 为线程池最大的大小，</span></span><br><span class="line">      <span class="comment">// keepAliveTime 为线程池中超过其基本大小的线程在执行完任务后返回线程池前要等待的时间，</span></span><br><span class="line">      <span class="comment">// unit 为 keepAliveTime 的单位，workQueue 用于保存等待执行的任务的阻塞队列，当任务要执行时，会从这个队列中取出。</span></span><br><span class="line">      <span class="type">ExecutorService</span> <span class="variable">threadPool</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(<span class="number">5</span>, <span class="number">10</span>, <span class="number">60L</span>, TimeUnit.SECONDS,</span><br><span class="line">         <span class="keyword">new</span> <span class="title class_">LinkedBlockingQueue</span>&lt;Runnable&gt;());</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 提交 15 个任务到线程池中</span></span><br><span class="line">      <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">15</span>; i++) &#123;</span><br><span class="line">         <span class="keyword">final</span> <span class="type">int</span> <span class="variable">taskId</span> <span class="operator">=</span> i;</span><br><span class="line">         threadPool.execute(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">               System.out.println(<span class="string">&quot;Task &quot;</span> + taskId + <span class="string">&quot; is running.&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">         &#125;);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 关闭线程池</span></span><br><span class="line">      threadPool.shutdown();</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>此代码使用 <code>ThreadPoolExecutor</code> 类创建一个线程池，并向该线程池提交 15 个任务。线程池的基本大小为 5，最大大小为 10，当线程池中的线程数超过 5 个时，新的任务将进入阻塞队列等待。当队列已满时，线程池会创建新的线程，直到线程数达到最大值 10。每个线程的空闲时间为 60 秒，即如果一个线程在执行完任务后空闲了 60 秒，它就会被回收。在提交任务后，线程池将逐渐地关闭，并等待所有任务完成。</p>
<h2 id="应用场景"><a class="markdownIt-Anchor" href="#应用场景"></a> 应用场景</h2>
<p>Java线程池可以广泛应用于各种需要大量并发执行任务的场景中，例如：</p>
<ul>
<li>服务器端程序中的请求处理。</li>
<li>多线程编程中的资源管理和任务调度。</li>
<li>并行计算、数据分析、机器学习等需要大量计算的场景。</li>
</ul>
<h2 id="总结"><a class="markdownIt-Anchor" href="#总结"></a> 总结</h2>
<p>Java线程池是Java并发编程中一个非常重要的概念，它可以帮助我们更好地管理线程，提高系统的性能和可维护性。通过学习和使用Java线程池，我们可以更深入地理解多线程编程的核心思想和实践原则，并为编写高质量、高效的Java程序奠定基础。</p>
]]></content>
      <categories>
        <category>并发编程</category>
        <category>线程池</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>并发编程</tag>
      </tags>
  </entry>
  <entry>
    <title>Volatile</title>
    <url>/posts/73afee0/</url>
    <content><![CDATA[<p>在Java中，Volatile是一种多线程同步的机制。它可以用于解决一个线程写入变量时，另一个线程无法看到该变量的最新值的问题。本篇博客将详细介绍Volatile关键字的用途和工作原理。</p>
<h2 id="作用"><a class="markdownIt-Anchor" href="#作用"></a> 作用</h2>
<h3 id="作用-2"><a class="markdownIt-Anchor" href="#作用-2"></a> 作用：</h3>
<ol>
<li>
<p><code>控制一个变量的可见性</code></p>
<p>当一个线程修改了一个共享变量的值时，JVM不会立即将其更新到主内存中，而是先将其缓存在线程的本地内存中。然而，如果另一个线程想要读取这个变量的值，那么它从主内存中读取的就可能不是最新的值，而是之前缓存在本地内存中的旧值。这就是所谓的“可见性”问题。</p>
<p>通过将该变量声明为Volatile，可以保证其他线程能够及时看到这个变量的最新值。例如，一个线程正在等待另一个线程更新某个共享变量的值，那么这个共享变量就应该声明为Volatile，确保多个线程之间的可见性。</p>
</li>
<li>
<p><code>禁止指令重排序优化</code></p>
<p>在Java中，编译器和处理器都会对代码进行指令重排序优化，以提高程序的执行效率。然而，在多线程环境下，这种优化可能会破坏程序的正确性。当一个变量被声明为Volatile时，编译器和处理器会禁止指令重排序优化，从而确保程序的正确性。例如，一个线程正在等待另一个线程更新某个共享变量，并且这个共享变量的更新需要满足特定的顺序要求，那么这个共享变量就应该声明为Volatile。</p>
</li>
</ol>
<div class="note-large notel-yellow"><div class="notel-title"><p>不能保证原子性</p>
</div><div class="notel-content"><p>Volatile <span style="border-bottom: 2px solid yellow">只能解决可见性问题，而不能保证操作的原子性。</span>如果多个线程同时对同一个Volatile变量进行自增或自减等非原子操作（自身参计算的操作），仍然会出现线程安全问题。</p>
 </div></div>
<h3 id="图示"><a class="markdownIt-Anchor" href="#图示"></a> 图示</h3>
<pre class="mermaid">flowchart LR

subgraph Thread1
    A((Thread1 Cache)) -->|Modify|B((Volatile))
end

subgraph Memory
    B -->|Update|C((Main Memory))
end

subgraph Thread2
    C -->|Read|D((Thread2 Cache))
end</pre>
<p>在该图中，<code>Thread1</code> 和 <code>Thread2</code> 分别拥有自己的本地缓存。当 <code>Thread1</code> 修改一个 <code>volatile</code> 变量时，它会立即将这个变化记录在主内存中，并使其他所有线程的本地缓存的地址设置为无效。</p>
<p>所以，在 <code>Thread2</code> 读取相同的 <code>volatile</code> 变量时，本地缓存的值已经是无效的了，它只能从主内存中读取最新的值。</p>
<p>这种实时更新确保了所有线程都可以看到对 <code>volatile</code> 变量所做的更改，从而避免了竞态条件和数据不一致的情况。</p>
<h2 id="实现原理"><a class="markdownIt-Anchor" href="#实现原理"></a> 实现原理</h2>
<p><code>Volatile</code> 关键字的底层实现依靠<code>CPU的缓存一致性协议</code>。当一个变量被声明为 Volatile 时，JVM 会向 CPU 发送一条<code>Lock前缀的指令</code>，告诉 CPU 这个变量是共享的，并且在读写时需要进行全局同步。</p>
<p>当一个线程写入一个 Volatile 变量时，它会先将新值写入到本地内存中，然后向主内存发送一条写回请求。同时，该线程会将自己的本地内存状态置为“无效”，强制重新从主内存中读取该变量的最新值。</p>
<p>而当一个线程读取一个 Volatile 变量时，它会直接从主内存中读取变量的最新值，并且在读取之前会强制刷新本地内存中所有缓存的数据，以保证读取到的是最新的值。</p>
<div class="note-large notel-green"><div class="notel-title"><p>#LOCK指令的作用</p>
</div><div class="notel-content"><ol>
<li>将当前处理器缓存行的数据写回到系统内存。</li>
<li>这个写回内存的操作会使在其他 CPU 里缓存了该内存地址的数据无效。</li>
</ol>
 </div></div>
<h2 id="举个栗子"><a class="markdownIt-Anchor" href="#举个栗子"></a> 举个栗子</h2>
<h3 id="保证可见性"><a class="markdownIt-Anchor" href="#保证可见性"></a> 保证可见性</h3>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">VolatileDemo</span> &#123;</span><br><span class="line">    <span class="comment">// 声明一个 volatile 类型的变量</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> <span class="type">boolean</span> <span class="variable">flag</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">while</span> (!flag) &#123;</span><br><span class="line">                <span class="comment">// do something...</span></span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">&quot;Thread 1: flag has been changed to true.&quot;</span>);</span><br><span class="line">        &#125;).start();</span><br><span class="line"></span><br><span class="line">        Thread.sleep(<span class="number">1000</span>); <span class="comment">// 等待一秒钟</span></span><br><span class="line"></span><br><span class="line">        flag = <span class="literal">true</span>; <span class="comment">// 修改 volatile 类型的变量的值</span></span><br><span class="line">        System.out.println(<span class="string">&quot;Main thread: set flag to true.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>在该示例中，我们声明了一个静态的 <code>volatile</code> 类型的变量 <code>flag</code>，并创建了一个新的线程，在这个线程中不断地检查 <code>flag</code> 的值。主线程等待一秒钟后，将修改<code>flag</code>的值为 <code>true</code>。</p>
<p>由于 <code>flag</code> 是 <code>volatile</code> 类型的变量，任何对它的更改都会立即更新到主内存中，而不是缓存在某个线程的本地内存中。因此，当主线程修改了 <code>flag</code> 的值后，新启动的线程可以立即看到这个更改，并退出循环。</p>
<p>通过使用<code>volatile</code>关键字来声明变量，我们可以确保变量的最新状态对于所有线程都是可见的，从而避免出现竞争条件和其他问题。</p>
<h3 id="防止指令重排"><a class="markdownIt-Anchor" href="#防止指令重排"></a> 防止指令重排</h3>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">VolatileDemo</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> VolatileHolder instance;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; getInstance());</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; getInstance());</span><br><span class="line"></span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            t1.join();</span><br><span class="line">            t2.join();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> VolatileHolder <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 双重校验锁定模式，实例化对象</span></span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="literal">null</span>) &#123; <span class="comment">// step 1</span></span><br><span class="line">            <span class="keyword">synchronized</span> (VolatileDemo.class) &#123;</span><br><span class="line">                <span class="keyword">if</span> (instance == <span class="literal">null</span>) &#123; <span class="comment">// step 2</span></span><br><span class="line">                    instance = <span class="keyword">new</span> <span class="title class_">VolatileHolder</span>(); <span class="comment">// step 3</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">VolatileHolder</span> &#123;</span><br><span class="line">        <span class="comment">// some fields and methods</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>当没有使用<code>volatile</code>关键字时，第一个线程在执行双重检查锁定模式期间，可能会发生以下情况：</p>
<ol>
<li>线程A执行到第一次检查时，发现instance未被初始化，进入同步块等待。</li>
<li>线程B也执行到第一次检查时，由于instance还未被初始化，也进入同步块等待。</li>
<li>线程A获得锁进入同步块后，进行创建实例对象的操作，但是由于JVM为了提高效率，可能会先分配内存空间、初始化实例、然后再将instance指向该对象。</li>
<li>此时线程B尝试获取锁进入同步块，由于instance已经被分配了空间并被标记为已经初始化，于是直接返回instance的引用，但是此时instance对象尚未完成初始化，访问该对象会出现问题。</li>
</ol>
<h3 id="不保证原子性"><a class="markdownIt-Anchor" href="#不保证原子性"></a> 不保证原子性</h3>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">NotAtomicDemo</span> &#123;</span><br><span class="line">    <span class="comment">// 使用 volatile 修饰</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>; </span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">increment</span><span class="params">()</span> &#123;</span><br><span class="line">        count++; <span class="comment">// 自增操作，自身参与操作   == count = count + 1</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">decrement</span><span class="params">()</span> &#123;</span><br><span class="line">        count--; <span class="comment">// 自增操作，自身参与操作   == count = count - 1</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>在这个例子中，<code>count</code>变量被声明为<code>volatile</code>，因此它的值可以被多个线程共享，并且当一个线程修改了它的值时，其他线程会立即看到最新的值。然而，由于<code>increment()</code>和<code>decrement()</code>方法都是非原子性的，即它们不是一次性地执行完所有操作，因此在多线程环境下，<code>count</code>变量可能会出现并发问题。</p>
<p>例如，当两个线程同时调用<code>increment()</code>方法时，它们可能会读取相同的<code>count</code>值，增加它，并将结果写回<code>count</code>变量。如果这两个线程在同一时间更新<code>count</code>变量，则只有一个线程能够成功地将其新值写回变量中，另一个线程的更新将被覆盖。因此，最终的计数器值可能小于预期值。</p>
<p>同样的情况也适用于<code>decrement()</code>方法，如果两个线程同时调用该方法，则可能导致计数器值大于预期值。</p>
<p>要解决这个问题，可以使用Java提供的<code>AtomicInteger</code>类，或者使用<code>synchronized</code>关键字来对<code>increment()</code>和<code>decrement()</code>方法进行同步，以确保它们被单独执行。</p>
<h2 id="总结"><a class="markdownIt-Anchor" href="#总结"></a> 总结</h2>
<p>Volatile关键字是Java中一种非常重要的多线程并发控制机制，它可以保证多个线程之间的可见性，并且禁止指令重排序优化，从而确保程序的正确性。然而，需要注意的是，Volatile 只能解决可见性问题，不能保证操作的原子性。如果需要保证原子性，需要使用其他的同步机制，例如synchronized或者Lock。</p>
<p>在使用Volatile关键字时，需要特别注意变量的并发读写操作。因为Volatile变量的写入操作会强制刷新本地内存中所有缓存的数据，这可能会导致程序的性能问题。因此，在实际应用中，建议只将必要的共享变量声明为Volatile。</p>
<p>同时，在多线程编程中，需要遵循一定的规范和约束，以避免出现死锁、活锁等常见问题。只有在正确使用各种多线程并发控制机制的基础上，才能写出高效、健壮的多线程程序。</p>
]]></content>
      <categories>
        <category>并发编程</category>
        <category>Volatile</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>并发编程</tag>
      </tags>
  </entry>
  <entry>
    <title>分布式锁-基于Redis</title>
    <url>/posts/750a2ea3/</url>
    <content><![CDATA[<blockquote>
<p>在分布式系统中，分布式锁是实现资源并发控制的一种常见方式。本文将介绍如何使用Redis实现分布式锁。</p>
</blockquote>
<h2 id="实现步骤"><a class="markdownIt-Anchor" href="#实现步骤"></a> 实现步骤</h2>
<blockquote>
<p>基于redis如何实现分布式锁？这里一定要看<a class="link"   href="https://redis.io/docs/reference/patterns/distributed-locks/" >Redis的官网 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>的分布式锁的实现这篇文章。</p>
</blockquote>
<h3 id="set-nx-px-lua"><a class="markdownIt-Anchor" href="#set-nx-px-lua"></a> set NX PX + Lua</h3>
<p><strong>加锁</strong>： set NX PX + 重试 + 重试间隔</p>
<p>向Redis发起如下命令: <code>SET productId:lock 0xx9p03001 NX PX 30000</code> 其中，&quot;productId&quot;由自己定义，可以是与本次业务有关的id，&quot;0xx9p03001&quot;是一串随机值，必须保证全局唯一(原因在后文中会提到)，“NX&quot;指的是当且仅当key(也就是案例中的&quot;productId:lock”)在Redis中不存在时，返回执行成功，否则执行失败。&quot;PX 30000&quot;指的是在30秒后，key将被自动删除。执行命令后返回成功，表明服务成功的获得了锁。</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">lock</span><span class="params">(String key, <span class="type">long</span> expire, <span class="type">int</span> retryTimes, <span class="type">long</span> retryDuration)</span> &#123;</span><br><span class="line">    <span class="comment">// use JedisCommands instead of setIfAbsense</span></span><br><span class="line">    <span class="type">boolean</span> <span class="variable">result</span> <span class="operator">=</span> setRedis(key, expire);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// retry if needed</span></span><br><span class="line">    <span class="keyword">while</span> ((!result) &amp;&amp; retryTimes-- &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            log.debug(<span class="string">&quot;lock failed, retrying...&quot;</span> + retryTimes);</span><br><span class="line">            Thread.sleep(retryDuration);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// use JedisCommands instead of setIfAbsense</span></span><br><span class="line">        result = setRedis(key, expire);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">setRedis</span><span class="params">(String key, <span class="type">long</span> expire)</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        RedisCallback&lt;String&gt; redisCallback = connection -&gt; &#123;</span><br><span class="line">            <span class="type">JedisCommands</span> <span class="variable">commands</span> <span class="operator">=</span> (JedisCommands) connection.getNativeConnection();</span><br><span class="line">            <span class="type">String</span> <span class="variable">uuid</span> <span class="operator">=</span> SnowIDUtil.uniqueStr();</span><br><span class="line">            lockFlag.set(uuid);</span><br><span class="line">            <span class="keyword">return</span> commands.set(key, uuid, NX, PX, expire); <span class="comment">// 看这里</span></span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="type">String</span> <span class="variable">result</span> <span class="operator">=</span> redisTemplate.execute(redisCallback);</span><br><span class="line">        <span class="keyword">return</span> !StringUtil.isEmpty(result);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        log.error(<span class="string">&quot;set redis occurred an exception&quot;</span>, e);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p><strong>解锁</strong>：采用lua脚本</p>
<p>在删除key之前，一定要判断服务A持有的value与Redis内存储的value是否一致。如果贸然使用服务A持有的key来删除锁，则会误将服务B的锁释放掉。</p>
<div class="highlight-container" data-rel="Lua"><figure class="iseeu highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> redis.call(<span class="string">&quot;get&quot;</span>, KEYS[<span class="number">1</span>])==ARGV[<span class="number">1</span>] <span class="keyword">then</span></span><br><span class="line">	<span class="keyword">return</span> redis.call(<span class="string">&quot;del&quot;</span>, KEYS[<span class="number">1</span>])</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure></div>
<h3 id="基于redlock实现分布式锁"><a class="markdownIt-Anchor" href="#基于redlock实现分布式锁"></a> 基于RedLock实现分布式锁</h3>
<blockquote>
<p>这是Redis作者推荐的分布式集群情况下的方式，请看这篇文章<a class="link"   href="http://antirez.com/news/101" >Is Redlock safe? <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
</blockquote>
<p>假设有两个服务A、B都希望获得锁，有一个包含了5个redis master的Redis Cluster，执行过程大致如下:</p>
<ol>
<li>客户端获取当前时间戳，单位: 毫秒</li>
<li>服务A轮寻每个master节点，尝试创建锁。(这里锁的过期时间比较短，一般就几十毫秒) RedLock算法会尝试在大多数节点上分别创建锁，假如节点总数为n，那么大多数节点指的是n/2+1。</li>
<li>客户端计算成功建立完锁的时间，如果建锁时间小于超时时间，就可以判定锁创建成功。如果锁创建失败，则依次(遍历master节点)删除锁。</li>
<li>只要有其它服务创建过分布式锁，那么当前服务就必须轮寻尝试获取锁。</li>
</ol>
<h3 id="基于redis的客户端"><a class="markdownIt-Anchor" href="#基于redis的客户端"></a> 基于Redis的客户端</h3>
<blockquote>
<p>这里Redis的客户端（Jedis, Redisson, Lettuce等）都是基于上述两类形式来实现分布式锁的，只是两类形式的封装以及一些优化（比如Redisson的watch dog)。</p>
</blockquote>
<p>以基于Redisson实现分布式锁为例（支持了 单实例、Redis哨兵、redis cluster、redis master-slave等各种部署架构）：</p>
<p><strong>特色</strong></p>
<ol>
<li>redisson所有指令都通过lua脚本执行，保证了操作的原子性</li>
<li>redisson设置了watchdog看门狗，“看门狗”的逻辑保证了没有死锁发生</li>
<li>redisson支持Redlock的实现方式。</li>
</ol>
<p><strong>过程</strong></p>
<ol>
<li>线程去获取锁，获取成功: 执行lua脚本，保存数据到redis数据库。</li>
<li>线程去获取锁，获取失败: 订阅了解锁消息，然后再尝试获取锁，获取成功后，执行lua脚本，保存数据到redis数据库。</li>
</ol>
<p><strong>互斥</strong></p>
<p>如果这个时候客户端B来尝试加锁，执行了同样的一段lua脚本。第一个if判断会执行“exists myLock”，发现myLock这个锁key已经存在。接着第二个if判断，判断myLock锁key的hash数据结构中，是否包含客户端B的ID，但明显没有，那么客户端B会获取到pttl myLock返回的一个数字，代表myLock这个锁key的剩余生存时间。此时客户端B会进入一个while循环，不听的尝试加锁。</p>
<p><strong>watch dog自动延时机制</strong></p>
<p>客户端A加锁的锁key默认生存时间只有30秒，如果超过了30秒，客户端A还想一直持有这把锁，怎么办？其实只要客户端A一旦加锁成功，就会启动一个watch dog看门狗，它是一个后台线程，会每隔10秒检查一下，如果客户端A还持有锁key，那么就会不断的延长锁key的生存时间。</p>
<p><strong>可重入</strong></p>
<p>每次lock会调用incrby，每次unlock会减一。</p>
<h3 id="进一步理解"><a class="markdownIt-Anchor" href="#进一步理解"></a> 进一步理解</h3>
<ol>
<li>借助Redis实现分布式锁时，有一个共同的缺陷: 当获取锁被拒绝后，需要不断的循环，重新发送获取锁(创建key)的请求，直到请求成功。这就造成空转，浪费宝贵的CPU资源。</li>
<li>RedLock算法本身有争议，具体看这篇文章<a class="link"   href="https://martin.kleppmann.com/2016/02/08/how-to-do-distributed-locking.html" >How to do distributed locking <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a> 以及作者的回复<a class="link"   href="http://antirez.com/news/101" >Is Redlock safe?在新窗口打开 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></li>
</ol>
]]></content>
      <categories>
        <category>分布式</category>
        <category>分布式锁</category>
      </categories>
      <tags>
        <tag>分布式锁</tag>
      </tags>
  </entry>
  <entry>
    <title>Lambda 表达式</title>
    <url>/posts/9fa75fc1/</url>
    <content><![CDATA[<p>Lambda表达式是Java 8中新增的一种编程语法，它允许我们将一个函数作为参数传给另一个函数。Lambda表达式可以简化代码，使其更加易读和简洁。本文将介绍Java Lambda表达式的语法。</p>
<h2 id="基本语法"><a class="markdownIt-Anchor" href="#基本语法"></a> 基本语法</h2>
<p>Lambda表达式的基本语法如下：</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line">(parameter list) -&gt; &#123; lambda body &#125;</span><br></pre></td></tr></table></figure></div>
<p>其中，<code>parameter list</code>是参数列表，可以是空的，也可以包含一个或多个参数；<code>lambda body</code>是Lambda表达式的执行体，可以是一个表达式或代码块。</p>
<p>例如，以下Lambda表达式没有任何参数，执行体只有一个输出语句：</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line">() -&gt; System.out.println(<span class="string">&quot;Hello, Lambda!&quot;</span>);</span><br></pre></td></tr></table></figure></div>
<p>以下Lambda表达式有一个参数，执行体是一个表达式：</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line">x -&gt; x * x</span><br></pre></td></tr></table></figure></div>
<p>以下Lambda表达式有两个参数，执行体是一个代码块：</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line">(x, y) -&gt; &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> x + y;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<h2 id="类型推断"><a class="markdownIt-Anchor" href="#类型推断"></a> 类型推断</h2>
<p>在Java 8之前，需要显式地指定Lambda表达式的函数接口类型。但是，在Java 8中引入了类型推断机制，可以根据上下文自动推断Lambda表达式的函数接口类型。例如：</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;String&gt; list = Arrays.asList(<span class="string">&quot;foo&quot;</span>, <span class="string">&quot;bar&quot;</span>);</span><br><span class="line">list.forEach((String s) -&gt; System.out.println(s));</span><br></pre></td></tr></table></figure></div>
<p>由于<code>list</code>是一个<code>List&lt;String&gt;</code>类型的集合，因此Lambda表达式<code>(String s) -&gt; System.out.println(s)</code>的函数接口类型也可以自动推断出来。因此，我们可以省略函数接口类型的显式声明：</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line">list.forEach(s -&gt; System.out.println(s));</span><br></pre></td></tr></table></figure></div>
<h2 id="总结"><a class="markdownIt-Anchor" href="#总结"></a> 总结</h2>
<p>Java Lambda表达式是一种简洁、易读且功能强大的编程语法。它可以使代码更加简单、清晰，并可用于各种场合。掌握Lambda表达式的基本语法和相关技巧，可以让我们更加高效地编写Java代码。</p>
]]></content>
      <categories>
        <category>Java</category>
        <category>函数编程</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Java 8</tag>
        <tag>函数编程</tag>
      </tags>
  </entry>
  <entry>
    <title>分布式锁-基于数据库</title>
    <url>/posts/4ef57d29/</url>
    <content><![CDATA[<blockquote>
<p>在分布式系统中，分布式锁是实现资源并发控制的一种常见方式。本文将介绍如何使用数据库实现基于表的分布式锁。</p>
</blockquote>
<h2 id="实现步骤"><a class="markdownIt-Anchor" href="#实现步骤"></a> 实现步骤</h2>
<h3 id="基于表"><a class="markdownIt-Anchor" href="#基于表"></a> 基于表</h3>
<p>最简单的方式可能就是直接创建一张锁表，然后通过操作该表中的数据来实现了。当我们想要获得锁的时候，就可以在该表中增加一条记录，想要释放锁的时候就删除这条记录。</p>
<h4 id="创建锁表"><a class="markdownIt-Anchor" href="#创建锁表"></a> 创建锁表</h4>
<div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> database_lock (</span><br><span class="line">	`id` <span class="type">BIGINT</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span> AUTO_INCREMENT,</span><br><span class="line">	`resource` <span class="type">int</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;锁定的资源&#x27;</span>,</span><br><span class="line">	`description` <span class="type">varchar</span>(<span class="number">1024</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> &quot;&quot; COMMENT <span class="string">&#x27;描述&#x27;</span>,</span><br><span class="line">	<span class="keyword">PRIMARY</span> KEY (id),</span><br><span class="line">	<span class="keyword">UNIQUE</span> KEY uiq_idx_resource (resource)</span><br><span class="line">) ENGINE<span class="operator">=</span>InnoDB <span class="keyword">DEFAULT</span> CHARSET<span class="operator">=</span>utf8mb4 COMMENT<span class="operator">=</span><span class="string">&#x27;数据库分布式锁表&#x27;</span>;</span><br></pre></td></tr></table></figure></div>
<h4 id="加锁"><a class="markdownIt-Anchor" href="#加锁"></a> 加锁</h4>
<p>当我们想要获得锁时，可以插入一条数据：</p>
<div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> database_lock(resource, description) <span class="keyword">VALUES</span> (<span class="number">1</span>, <span class="string">&#x27;lock&#x27;</span>);</span><br></pre></td></tr></table></figure></div>
<h4 id="释放锁"><a class="markdownIt-Anchor" href="#释放锁"></a> 释放锁</h4>
<p>当需要释放锁的时，可以删除这条数据：</p>
<div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">DELETE</span> <span class="keyword">FROM</span> database_lock <span class="keyword">WHERE</span> resource<span class="operator">=</span><span class="number">1</span>;</span><br></pre></td></tr></table></figure></div>
<h3 id="基于悲观锁"><a class="markdownIt-Anchor" href="#基于悲观锁"></a> 基于悲观锁</h3>
<p><strong>悲观锁实现思路</strong>？</p>
<ol>
<li>在对任意记录进行修改前，先尝试为该记录加上排他锁（exclusive locking）。</li>
<li>如果加锁失败，说明该记录正在被修改，那么当前查询可能要等待或者抛出异常。 具体响应方式由开发者根据实际需要决定。</li>
<li>如果成功加锁，那么就可以对记录做修改，事务完成后就会解锁了。</li>
<li>其间如果有其他对该记录做修改或加排他锁的操作，都会等待我们解锁或直接抛出异常。</li>
</ol>
<p><strong>以MySQL InnoDB中使用悲观锁为例</strong>？</p>
<p>要使用悲观锁，我们必须关闭mysql数据库的自动提交属性，因为MySQL默认使用autocommit模式，也就是说，当你执行一个更新操作后，MySQL会立刻将结果进行提交。set autocommit=0;</p>
<div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="operator">/</span><span class="operator">/</span><span class="number">0.</span>开始事务</span><br><span class="line"><span class="keyword">begin</span>;<span class="operator">/</span><span class="keyword">begin</span> work;<span class="operator">/</span><span class="keyword">start</span> transaction; (三者选一就可以)</span><br><span class="line"><span class="operator">/</span><span class="operator">/</span><span class="number">1.</span>查询出商品信息</span><br><span class="line"><span class="keyword">select</span> status <span class="keyword">from</span> t_goods <span class="keyword">where</span> id<span class="operator">=</span><span class="number">1</span> <span class="keyword">for</span> <span class="keyword">update</span>;</span><br><span class="line"><span class="operator">/</span><span class="operator">/</span><span class="number">2.</span>根据商品信息生成订单</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> t_orders (id,goods_id) <span class="keyword">values</span> (<span class="keyword">null</span>,<span class="number">1</span>);</span><br><span class="line"><span class="operator">/</span><span class="operator">/</span><span class="number">3.</span>修改商品status为<span class="number">2</span></span><br><span class="line"><span class="keyword">update</span> t_goods <span class="keyword">set</span> status<span class="operator">=</span><span class="number">2</span>;</span><br><span class="line"><span class="operator">/</span><span class="operator">/</span><span class="number">4.</span>提交事务</span><br><span class="line"><span class="keyword">commit</span>;<span class="operator">/</span><span class="keyword">commit</span> work;</span><br></pre></td></tr></table></figure></div>
<p>上面的查询语句中，我们使用了<code>select…for update</code>的方式，这样就通过开启排他锁的方式实现了悲观锁。此时在t_goods表中，id为1的 那条数据就被我们锁定了，其它的事务必须等本次事务提交之后才能执行。这样我们可以保证当前的数据不会被其它事务修改。</p>
<p>上面我们提到，使用<code>select…for update</code>会把数据给锁住，不过我们需要注意一些锁的级别，MySQL InnoDB默认行级锁。行级锁都是基于索引的，如果一条SQL语句用不到索引是不会使用行级锁的，会使用表级锁把整张表锁住，这点需要注意。</p>
<h3 id="基于乐观锁"><a class="markdownIt-Anchor" href="#基于乐观锁"></a> 基于乐观锁</h3>
<p>乐观并发控制（又名“乐观锁”，Optimistic Concurrency Control，缩写“OCC”）是一种并发控制的方法。它假设多用户并发的事务在处理时不会彼此互相影响，各事务能够在不产生锁的情况下处理各自影响的那部分数据。在提交数据更新之前，每个事务会先检查在该事务读取数据后，有没有其他事务又修改了该数据。如果其他事务有更新的话，正在提交的事务会进行回滚。</p>
<p><strong>以使用版本号实现乐观锁为例？</strong></p>
<p>使用版本号时，可以在数据初始化时指定一个版本号，每次对数据的更新操作都对版本号执行+1操作。并判断当前版本号是不是该数据的最新的版本号。</p>
<div class="highlight-container" data-rel="Sql"><figure class="iseeu highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>查询出商品信息</span><br><span class="line"><span class="keyword">select</span> (status,status,version) <span class="keyword">from</span> t_goods <span class="keyword">where</span> id<span class="operator">=</span>#&#123;id&#125;</span><br><span class="line"><span class="number">2.</span>根据商品信息生成订单</span><br><span class="line"><span class="number">3.</span>修改商品status为<span class="number">2</span></span><br><span class="line"><span class="keyword">update</span> t_goods </span><br><span class="line"><span class="keyword">set</span> status<span class="operator">=</span><span class="number">2</span>,version<span class="operator">=</span>version<span class="operator">+</span><span class="number">1</span></span><br><span class="line"><span class="keyword">where</span> id<span class="operator">=</span>#&#123;id&#125; <span class="keyword">and</span> version<span class="operator">=</span>#&#123;version&#125;;</span><br></pre></td></tr></table></figure></div>
<div class="note-large notel-yellow"><div class="notel-title"><p>注意</p>
</div><div class="notel-content"><p>需要注意的是，乐观锁机制往往基于系统中数据存储逻辑，因此也具备一定的局限性。由于乐观锁机制是在我们的系统中实现的，对于来自外部系统的用户数据更新操作不受我们系统的控制，因此可能会造成脏数据被更新到数据库中。在系统设计阶段，我们应该充分考虑到这些情况，并进行相应的调整（如将乐观锁策略在数据库存储过程中实现，对外只开放基于此存储过程的数据更新途径，而不是将数据库表直接对外公开）。</p>
 </div></div>
]]></content>
      <categories>
        <category>分布式</category>
        <category>分布式锁</category>
      </categories>
      <tags>
        <tag>分布式锁</tag>
      </tags>
  </entry>
  <entry>
    <title>函数接口</title>
    <url>/posts/a65f2ab8/</url>
    <content><![CDATA[<p>Java 8 中引入了函数式编程的概念，其中函数接口是重要的一部分。函数接口是指只有一个抽象方法的接口，可以使用 lambda 表达式或方法引用来实现该抽象方法。在函数式编程中，函数接口通常用于表示某个操作，例如转换、过滤或消费数据等。通过将函数接口作为参数传递到方法中，可以轻松地实现这些操作。</p>
<h2 id="函数接口是什么"><a class="markdownIt-Anchor" href="#函数接口是什么"></a> 函数接口是什么？</h2>
<h3 id="定义"><a class="markdownIt-Anchor" href="#定义"></a> 定义</h3>
<div class="note note-success icon-padding"><i class="note-icon fa-solid fa-check-circle"></i><p>只有一个抽象方法的接口。</p>
</div>
<h3 id="典例"><a class="markdownIt-Anchor" href="#典例"></a> 典例</h3>
<p>Java 中的 Runnable 接口，就是一个典型的函数接口，请看Code：</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span> <span class="comment">// 声明该接口是函数接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">  <span class="comment">// 该接口中只有一个抽象方法</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<h3 id="functionalinterface"><a class="markdownIt-Anchor" href="#functionalinterface"></a> @FunctionalInterface</h3>
<p>@FunctionalInterface：标识一个接口为函数接口，必须满足函数接口的定义：只有一个抽象方法的接口，否则编译时会报错。</p>
<p>三个接口为例说明，如下：</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Hello</span></span><br><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Hello</span> &#123;</span><br><span class="line">  <span class="keyword">void</span> <span class="title function_">hello</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// NiHao </span></span><br><span class="line"><span class="comment">// ！！！错误</span></span><br><span class="line"><span class="meta">@FunctionalInterface</span> </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Nihao</span> &#123;</span><br><span class="line">  <span class="keyword">void</span> <span class="title function_">nihao</span><span class="params">()</span>;</span><br><span class="line">  <span class="keyword">void</span> <span class="title function_">shijie</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Hi</span></span><br><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Hi</span> &#123;</span><br><span class="line">  <span class="keyword">void</span> <span class="title function_">hi</span><span class="params">()</span>;</span><br><span class="line">  <span class="keyword">default</span> <span class="keyword">void</span> <span class="title function_">shijie</span><span class="params">()</span> &#123;&#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<div class="note note-success icon-padding"><i class="note-icon fa-solid fa-check-circle"></i><p>Hello 接口和 Hi 接口都是函数接口，添加 @FunctionalInterface 注解不会报错。</p>
</div> 
<div class="note note-danger icon-padding"><i class="note-icon fa-solid fa-times-circle"></i><p>Nihao 接口不是函数接口，添加 @FunctionalInterface 注解会报错。</p>
</div>
<h3 id="自定义函数接口"><a class="markdownIt-Anchor" href="#自定义函数接口"></a> 自定义函数接口</h3>
<p>根据函数接口的定义（<code>只有一个抽象方法的接口</code>）来自定义一个函数接口 Me ：</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 几行 Code 定义了一个函数接口，是不是很简单。</span></span><br><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Me</span> &#123;</span><br><span class="line">  <span class="comment">// Me 接口只有一个抽象方法 i()</span></span><br><span class="line">  <span class="keyword">void</span> <span class="title function_">i</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<h3 id="java-内置的函数接口"><a class="markdownIt-Anchor" href="#java-内置的函数接口"></a> Java 内置的函数接口</h3>
<p>Java 8 中引入了函数式编程的概念，其中函数接口是重要的一部分。Java 8 也内置了一些函数接口，主要常用的有 <code>Function&lt;T, R&gt;</code>、<code>Predicate&lt;T&gt;</code>、<code>Consumer&lt;T&gt;</code>、<code>Supplier&lt;T&gt;</code> 这四个函数对象，此外还有一些相对用的少一点的，比如：<code>BiFunction&lt;T, U, R&gt;</code>、<code>BiPredicate&lt;T, U&gt;</code>、<code>BiConsumer&lt;T, U&gt;</code>、<code>UnaryOperator&lt;T&gt;</code>、<code>BinaryOperator&lt;T&gt;</code>。这些函数接口的使用，我会单独写一篇博文进行介绍的，这篇主要是了解到什么是函数接口就OK了。</p>
<h2 id="函数接口的应用"><a class="markdownIt-Anchor" href="#函数接口的应用"></a> 函数接口的应用</h2>
<h3 id="lambda-表达式"><a class="markdownIt-Anchor" href="#lambda-表达式"></a> Lambda 表达式</h3>
<p><code>Lambda 表达式</code>提供了一种简洁的方式来创建函数接口的实例（实现函数接口）。Lambda 表达式可以使用函数接口来描述其参数和返回类型，并且可以通过将Lambda表达式分配给函数接口类型的变量来使用它。因此，Lambda表达式和函数接口密切相关，它们通常一起使用，以实现简洁、灵活的代码。</p>
<p>伪代码如下：</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 函数接口 Hello</span></span><br><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Hello</span> &#123;</span><br><span class="line">  <span class="keyword">void</span> <span class="title function_">hello</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">Hello</span> <span class="variable">h</span> <span class="operator">=</span> () -&gt; &#123;&#125;;</span><br><span class="line"><span class="comment">// Lambda 表达式角度：</span></span><br><span class="line"><span class="comment">//   使用 Lambda 表达式来实现 Hello 接口，并创建了一个 Hello 类型的实例</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数接口角度：</span></span><br><span class="line"><span class="comment">//   使用 Hello 函数接口，描述了 Lambda 表达式</span></span><br><span class="line"><span class="comment">//   返回值为 void，没有入参（其实就是 hello() 方法）</span></span><br></pre></td></tr></table></figure></div>
<h3 id="方法引用"><a class="markdownIt-Anchor" href="#方法引用"></a> 方法引用</h3>
<p><code>方法引用</code>提供了一种更为简洁的方式来创建函数接口的实例，通过引用现有方法而不是编写 <code>Lambda 表达式</code>的方式；直接使用现有方法的名称，从而简化代码并提高可读性。</p>
<p>伪代码如下：</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 内置函数接口 Consumer</span></span><br><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Consumer</span>&lt;T&gt; &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="title function_">accept</span><span class="params">(T t)</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用 Lambda 表达式创建一个 Consumer 类型的实例</span></span><br><span class="line">Consumer&lt;String&gt; consumer = s -&gt; System.out.println(s);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用方法引用创建一个 Consumer 类型的实例</span></span><br><span class="line">Consumer&lt;String&gt; consumer = System.out::println;</span><br></pre></td></tr></table></figure></div>
<h2 id="总结"><a class="markdownIt-Anchor" href="#总结"></a> 总结</h2>
<p>函数接口是 Java 8 中引入函数式编程基础中的基础，它和 Lambda 表达式和方法引用有着密不可分的关系，把这三者的关系理清并掌握后，Java的函数编程那不是小菜一碟，Stream Api 也不是什么大问题 <i class="fa-duotone fa-face-party"></i>。</p>
]]></content>
      <categories>
        <category>Java</category>
        <category>函数编程</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Java 8</tag>
        <tag>函数编程</tag>
      </tags>
  </entry>
  <entry>
    <title>方法引用</title>
    <url>/posts/4b34576e/</url>
    <content><![CDATA[<p>在Java 8中，方法引用（method reference）是一种方便的语法，可以将现有的方法作为Lambda表达式传递。这样做可以简化代码，并且使得代码更加易于理解和修改。本文将介绍Java方法引用的基本概念、语法和使用方法。</p>
<div class="note note-yellow"><p>阅读本篇内容默认认为你已经掌握了<a href="/posts/a65f2ab8/">函数接口</a>、<a href="/posts/9fa75fc1/">Lambda 表达式</a></p>
</div>
<h2 id="什么是方法引用"><a class="markdownIt-Anchor" href="#什么是方法引用"></a> 什么是方法引用？</h2>
<p>方法引用是一种语法，用于将现有的方法作为Lambda表达式传递。通常情况下，我们需要定义一个Lambda表达式来表示一个匿名函数，然后把它传递给另一个函数。但是，如果这个Lambda表达式只是调用了一个已经存在的方法，那么就可以使用方法引用来代替Lambda表达式。方法引用的基本思想是：如果存在一个现有方法，它正好满足Lambda表达式的参数和返回类型，那么就可以使用方法引用来代替Lambda表达式。</p>
<h2 id="方法引用的语法"><a class="markdownIt-Anchor" href="#方法引用的语法"></a> 方法引用的语法</h2>
<p>方法引用使用<code>::</code>符号来表示。它的语法有以下几种形式：</p>
<ul>
<li>静态方法引用：<code>ClassName::methodName</code></li>
<li>实例方法引用：<code>objectName::methodName</code></li>
<li>特定类的任意对象方法引用：<code>ClassName::methodName</code></li>
<li>构造方法引用：<code>ClassName::new</code></li>
</ul>
<p>其中，静态方法引用和实例方法引用是最常用的两种形式。其他两种形式通常用于特殊情况。</p>
<h3 id="静态方法引用"><a class="markdownIt-Anchor" href="#静态方法引用"></a> 静态方法引用</h3>
<p>静态方法引用使用<code>ClassName::methodName</code>的形式。例如，如果存在一个静态方法<code>Integer.parseInt(String)</code>，我们可以使用如下的代码来引用它：</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line">Function&lt;String, Integer&gt; parser = Integer::parseInt;</span><br></pre></td></tr></table></figure></div>
<p>上面的代码将<code>Integer.parseInt()</code>方法作为一个函数对象赋值给了<code>parser</code>变量。这样，在程序中就可以像使用其他函数一样使用这个函数对象了。</p>
<h3 id="实例方法引用"><a class="markdownIt-Anchor" href="#实例方法引用"></a> 实例方法引用</h3>
<p>实例方法引用使用<code>objectName::methodName</code>的形式。例如，如果存在一个实例方法<code>String.toUpperCase()</code>，我们可以使用如下的代码来引用它：</p>
<div class="highlight-container" data-rel="Java"><figure class="iseeu highlight java"><table><tr><td class="code"><pre><span class="line">UnaryOperator&lt;String&gt; converter = String::toUpperCase;</span><br></pre></td></tr></table></figure></div>
<p>上面的代码将<code>String.toUpperCase()</code>方法作为一个函数对象赋值给了<code>converter</code>变量。这样，在程序中就可以像使用其他函数一样使用这个函数对象了。注意：在这个例子中，<code>String::toUpperCase</code>是一个无参方法，因此返回值类型必须与函数接口的返回值类型相同（即<code>UnaryOperator&lt;String&gt;</code>）。</p>
<h2 id="总结"><a class="markdownIt-Anchor" href="#总结"></a> 总结</h2>
<p>Java方法引用是一种方便的语法，用于简化Lambda表达式并使代码更加易于理解和修改。方法引用通常可以用于函数式接口的参数或者返回值，以便将现有方法转换成函数式接口的实例。掌握方法引用的基本语法和相关技巧，可以让我们更加高效地编写Java代码。</p>
]]></content>
      <categories>
        <category>Java</category>
        <category>函数编程</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Java 8</tag>
        <tag>函数编程</tag>
      </tags>
  </entry>
</search>
